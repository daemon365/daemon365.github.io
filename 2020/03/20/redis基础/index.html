<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=HandheldFriendly content="True"><meta http-equiv=X-UA-Compatible content="IE=edge"><meta http-equiv=Cache-Control content="no-transform"><meta http-equiv=Cache-Control content="no-siteapp"><meta name=generator content="Hugo 0.128.1"><link rel="shortcut icon" href=/imgs/icons/favicon.ico><title>redis基础 - Daemon</title>
<meta name=author content="daemon365"><meta name=description content="Don't let yourself stop."><meta name=keywords content="redis"><meta property="og:title" content="redis基础"><meta name=twitter:title content="redis基础"><meta property="og:type" content="article"><meta property="og:url" content="https://daemon365.dev/2020/03/20/redis%E5%9F%BA%E7%A1%80/"><meta property="og:description" content="redis介绍 Redis 是完全开源的，遵守 BSD 协议，是一个高性能的 key-value 数据库。 Redis 与其他 key - value 缓存产品有以下三个特点： Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。 Re"><meta name=twitter:description content="redis介绍 Redis 是完全开源的，遵守 BSD 协议，是一个高性能的 key-value 数据库。 Redis 与其他 key - value 缓存产品有以下三个特点： Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。 Re"><meta property="og:image" content="https://daemon365.dev/imgs/icons/favicon.ico"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://daemon365.dev/imgs/icons/favicon.ico"><meta property="article:published_time" content="2020-03-20T00:00:00+08:00"><meta property="article:modified_time" content="2020-03-20T00:00:00+08:00"><style>@media(prefers-color-scheme:dark){body[data-theme=auto] img{filter:brightness(60%)}}body[data-theme=dark] img{filter:brightness(60%)}</style><link rel=stylesheet href=https://daemon365.dev/assets/css/fuji.min.4e0456c767a797dadceacfba968921e887d900af9fd8d0953bebc1524ea1dec6c6a4a5ec0c0b77280884a642028ce374f31206dd96c6d7d143d5ee3c372f2c31.css integrity="sha512-TgRWx2enl9rc6s+6lokh6IfZAK+f2NCVO+vBUk6h3sbGpKXsDAt3KAiEpkICjON08xIG3ZbG19FD1e48Ny8sMQ=="></head><body data-theme=light data-theme-auto=false><script data-cfasync=false>var fujiThemeData=localStorage.getItem("fuji_data-theme");fujiThemeData?fujiThemeData!=="auto"&&document.body.setAttribute("data-theme",fujiThemeData==="dark"?"dark":"light"):localStorage.setItem("fuji_data-theme","auto")</script><header><div class="container-lg clearfix"><div class="col-12 header"><a class=title-main href=https://daemon365.dev/>Daemon</a>
<span class=title-sub>Don't let yourself stop.</span></div></div></header><main><div class="container-lg clearfix"><div class="col-12 col-md-9 float-left content"><article><h2 class="post-item post-title"><a href=https://daemon365.dev/2020/03/20/redis%E5%9F%BA%E7%A1%80/>redis基础</a></h2><div class="post-item post-meta"><span><i class="iconfont icon-today-sharp"></i>&nbsp;2020-03-20</span>
<span><i class="iconfont icon-file-tray-sharp"></i>&nbsp;7580 words</span>
<span><i class="iconfont icon-pricetags-sharp"></i>&nbsp;<a href=/tags/redis>redis</a>&nbsp;</span></div><div class="post-content markdown-body"><h2 id=redis介绍>redis介绍</h2><p>Redis 是完全开源的，遵守 BSD 协议，是一个高性能的 key-value 数据库。</p><p>Redis 与其他 key - value 缓存产品有以下三个特点：</p><ul><li>Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</li><li>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。</li><li>Redis支持数据的备份，即master-slave模式的数据备份。</li></ul><h3 id=redis的安装>redis的安装</h3><pre><code class=language-bash>brew install redis(mac)
yum install redis(centos)
apt-get install redis(ubuntu)
</code></pre><h2 id=redis的命令网站>redis的命令网站</h2><p><a href=http://doc.redisfans.com/ target=_blank>Redis 命令参考 — Redis 命令参考 (redisfans.com)</a></p><h2 id=redis的基本操作>redis的基本操作</h2><h3 id=redis的五大数据类型>redis的五大数据类型</h3><p>redis的五大数据类型是: <strong>String(字符串)、Hash(哈希)、List(列表)、Set(集合)、和zset(sorted set:有序集合)</strong></p><h3 id=redis键操作>redis键操作</h3><ul><li><code>keys *</code>查看当前库所有key (匹配：keys *1)</li><li><code>exists key</code>判断某个key是否存在</li><li><code>type key</code> 查看你的key是什么类型</li><li><code>del key</code> 删除指定的key数据</li><li><code>unlink key</code> 根据value选择非阻塞删除 仅将keys从keyspace元数据中删除，真正的删除会在后续异步操作。</li><li><code>expire key 10 </code>10秒钟：为给定的key设置过期时间</li><li><code>ttl key</code> 查看还有多少秒过期，-1表示永不过期，-2表示已过期</li><li><code>select</code>命令切换数据库</li><li><code>dbsize</code>查看当前数据库的key的数量</li><li><code>flushdb</code>清空当前库</li><li><code>flushall</code>通杀全部库</li></ul><h3 id=字符串string>字符串(String)</h3><h4 id=简介>简介</h4><p>String是Redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。</p><p>String类型是二进制安全的。意味着Redis的string可以包含任何数据。比如jpg图片或者序列化的对象。</p><p>String类型是Redis最基本的数据类型，一个Redis中字符串value最多可以是512M</p><h4 id=常用命令>常用命令</h4><ul><li><code>set &lt;key>&lt;value></code>添加键值对</li><li><code>get &lt;key></code>查询对应键值</li><li><code>append &lt;key>&lt;value></code>将给定的<value> 追加到原值的末尾</li><li><code>strlen &lt;key></code>获得值的长度</li><li><code>setnx &lt;key>&lt;value></code>只有在 key 不存在时 设置 key 的值</li><li><code>incr &lt;key> </code>将 key 中储存的数字值增1 只能对数字值操作，如果为空，新增值为1</li><li><code>decr &lt;key></code> 将 key 中储存的数字值减1 只能对数字值操作，如果为空，新增值为-1</li><li><code>incrby / decrby &lt;key>&lt;步长></code>将 key 中储存的数字值增减。自定义步长。</li></ul><h4 id=数据结构>数据结构</h4><p>String的数据结构为简单动态字符串(Simple Dynamic String,缩写SDS)。是可以修改的字符串，内部结构实现上类似于Java的ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配.</p><p><img class=img-zoomable src=/images/f5606772-f15c-49ef-9c08-6b7f1e6495ea.png alt></p><p>如图中所示，内部为当前字符串实际分配的空间capacity一般要高于实际字符串长度len。当字符串长度小于1M时，扩容都是加倍现有的空间，如果超过1M，扩容时一次只会多扩1M的空间。需要注意的是字符串最大长度为512M。</p><h3 id=列表list>列表(List)</h3><h4 id=简介-1>简介</h4><p>单键多值</p><p>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</p><p>它的底层实际是个双向链表，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。</p><p><img class=img-zoomable src=/images/e7492d9c-c6d9-4de0-83b5-fd6482bc3c51.png alt></p><h4 id=常用命令-1>常用命令</h4><ul><li><code>lpush/rpush &lt;key>&lt;value1>&lt;value2>&lt;value3> ....</code> 从左边/右边插入一个或多个值。</li><li><code>lpop/rpop &lt;key></code>从左边/右边吐出一个值。值在键在，值光键亡。</li><li><code>rpoplpush &lt;key1>&lt;key2></code>从<key1>列表右边吐出一个值，插到<key2>列表左边。</li><li><code>lrange &lt;key>&lt;start>&lt;stop></code> 按照索引下标获得元素(从左到右)</li><li><code>lrange mylist 0 -1</code> 0左边第一个，-1右边第一个，（0-1表示获取所有）</li><li><code>lindex &lt;key>&lt;index></code>按照索引下标获得元素(从左到右)</li><li><code>llen &lt;key></code>获得列表长度</li><li><code>linsert &lt;key> before &lt;value>&lt;newvalue></code>在<value>的后面插入<newvalue>插入值</li><li><code>lrem &lt;key>&lt;n>&lt;value></code>从左边删除n个value(从左到右)</li><li><code>lset&lt;key>&lt;index>&lt;value></code>将列表key下标为index的值替换成value</li></ul><h4 id=数据结构-1>数据结构</h4><p>List的数据结构为快速链表quickList。</p><p>首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是ziplist，也即是压缩列表。它将所有的元素紧挨着一起存储，分配的是一块连续的内存。当数据量比较多的时候才会改成quicklist。因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只是int类型的数据，结构上还需要两个额外的指针prev和next。</p><p><img class=img-zoomable src=/images/810b0d87-7a3c-416a-87ac-66ad441e8a0a.png alt></p><p>Redis将链表和ziplist结合起来组成了quicklist。也就是将多个ziplist使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。</p><h3 id=集合set>集合(Set)</h3><h4 id=简介-2>简介</h4><p>Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以****自动排重****的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。</p><p>Redis的Set是string类型的无序集合。它底层其实是一个value为null的hash表，所以添加，删除，查找的****复杂度都是O(1)****。</p><p>一个算法，随着数据的增加，执行时间的长短，如果是O(1)，数据增加，查找数据的时间不变</p><h4 id=常用命令-2>常用命令</h4><ul><li><code>sadd &lt;key>&lt;value1>&lt;value2> ..... </code>将一个或多个 member 元素加入到集合 key 中，已经存在的 member 元素将被忽略</li><li><code>smembers &lt;key></code>取出该集合的所有值。</li><li><code>sismember &lt;key>&lt;value></code>判断集合<key>是否为含有该<value>值，有1，没有0</li><li><code>scard&lt;key></code>返回该集合的元素个数。</li><li><code>srem &lt;key>&lt;value1>&lt;value2> ....</code> 删除集合中的某个元素。</li><li><code>spop &lt;key></code><em><strong>*随机从该集合中吐出一个值。*</strong></em></li><li><code>srandmember &lt;key>&lt;n></code>随机从该集合中取出n个值。不会从集合中删除 。</li><li><code>smove &lt;source>&lt;destination></code>value把集合中一个值从一个集合移动到另一个集合</li><li><code>sinter &lt;key1>&lt;key2></code>返回两个集合的交集元素。</li><li><code>sunion &lt;key1>&lt;key2></code>返回两个集合的并集元素。</li><li><code>sdiff &lt;key1>&lt;key2></code>返回两个集合的****差集****元素(key1中的，不包含key2中的)</li></ul><h4 id=数据结构-2>数据结构</h4><p>Set数据结构是dict字典，字典是用哈希表实现的。
Java中HashSet的内部实现使用的是HashMap，只不过所有的value都指向同一个对象。Redis的set结构也是一样，它的内部也使用hash结构，所有的value都指向同一个内部值。</p><h3 id=哈希hash>哈希(Hash)</h3><h4 id=简介-3>简介</h4><p>Redis hash 是一个键值对集合。</p><p>Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。</p><h4 id=常用命令-3>常用命令</h4><ul><li><code>hset &lt;key>&lt;field>&lt;value></code>给<key>集合中的 <field>键赋值<value></li><li><code>hget &lt;key1>&lt;field></code>从<key1>集合<field>取出 value</li><li><code>hmset &lt;key1>&lt;field1>&lt;value1>&lt;field2>&lt;value2>... </code>批量设置hash的值</li><li><code>hexists&lt;key1>&lt;field></code>查看哈希表 key 中，给定域 field 是否存在。</li><li><code>hkeys &lt;key></code>列出该hash集合的所有field</li><li><code>hvals &lt;key></code>列出该hash集合的所有value</li><li><code>hincrby &lt;key>&lt;field>&lt;increment></code>为哈希表 key 中的域 field 的值加上增量 1 -1</li><li><code>hsetnx &lt;key>&lt;field>&lt;value></code>将哈希表 key 中的域 field 的值设置为 value ，当且仅当域 field 不存在 .</li></ul><h4 id=数据结构-3>数据结构</h4><p>Hash类型对应的数据结构是两种：ziplist（压缩列表），hashtable（哈希表）。当field-value长度较短且个数较少时，使用ziplist，否则使用hashtable。</p><h3 id=有序集合zsetsorted-set>有序集合Zset(sorted set)</h3><h4 id=简介-4>简介</h4><p>Redis有序集合zset与普通集合set非常相似，是一个没有重复元素的字符串集合。</p><p>不同之处是有序集合的每个成员都关联了一个****评分（score）****,这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是评分可以是重复了 。</p><p>因为元素是有序的, 所以你也可以很快的根据评分（score）或者次序（position）来获取一个范围的元素。</p><p>访问有序集合的中间元素也是非常快的,因此你能够使用有序集合作为一个没有重复成员的智能列表。</p><h4 id=常用命令-4>常用命令</h4><ul><li><code>zadd &lt;key>&lt;score1>&lt;value1>&lt;score2>&lt;value2>… </code>将一个或多个 member 元素及其 score 值加入到有序集 key 当中。</li><li><code>zrange &lt;key>&lt;start>&lt;stop> [WITHSCORES] </code>返回有序集 key 中，下标在<start><stop>之间的元素带WITHSCORES，可以让分数一起和值返回到结果集。</li><li><code>zrangebyscore key minmax [withscores] [limit offset count]</code> 返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列。</li><li><code>zrevrangebyscore key maxmin [withscores] [limit offset count] </code>同上，改为从大到小排列。</li><li><code>zincrby &lt;key>&lt;increment>&lt;value></code> 为元素的score加上增量</li><li><code>zrem &lt;key>&lt;value></code>删除该集合下，指定值的元素</li><li><code>zcount &lt;key>&lt;min>&lt;max></code>统计该集合，分数区间内的元素个数</li><li><code>zrank &lt;key>&lt;value></code>返回该值在集合中的排名，从0开始。</li></ul><h4 id=数据结构-4>数据结构</h4><p>SortedSet(zset)是Redis提供的一个非常特别的数据结构，一方面它等价于Java的数据结构Map&lt;String, Double>，可以给每一个元素value赋予一个权重score，另一方面它又类似于TreeSet，内部的元素会按照权重score进行排序，可以得到每个元素的名次，还可以通过score的范围来获取元素的列表。</p><p>zset底层使用了两个数据结构</p><ol><li>hash，hash的作用就是关联元素value和权重score，保障元素value的唯一性，可以通过元素value找到相应的score值。</li><li>跳跃表，跳跃表的目的在于给元素value排序，根据score的范围获取元素列表。</li></ol><h2 id=redis新数据类型>Redis新数据类型</h2><h3 id=bitmaps>Bitmaps</h3><h4 id=简介-5>简介</h4><p>现代计算机用二进制（位） 作为信息的基础单位， 1个字节等于8位， 例如“abc”字符串是由3个字节组成， 但实际在计算机存储时将其用二进制表示， “abc”分别对应的ASCII码分别是97、 98、 99， 对应的二进制分别是01100001、 01100010和01100011，如下图</p><p><img class=img-zoomable src=/images/4ba572ec-0cd0-471d-8321-46012e72f259.png alt></p><p>合理地使用操作位能够有效地提高内存使用率和开发效率。</p><p>Redis提供了Bitmaps这个“数据类型”可以实现对位的操作：</p><ol><li>Bitmaps本身不是一种数据类型， 实际上它就是字符串（key-value） ， 但是它可以对字符串的位进行操作。</li><li>Bitmaps单独提供了一套命令， 所以在Redis中使用Bitmaps和使用字符串的方法不太相同。 可以把Bitmaps想象成一个以位为单位的数组， 数组的每个单元只能存储0和1， 数组的下标在Bitmaps中叫做偏移量。</li></ol><p><img class=img-zoomable src=/images/38fcab8e-c732-4d37-9712-712a307f36d1.png alt></p><h4 id=命令>命令</h4><ol><li>setbit</li></ol><p>（1）格式</p><p><code>setbit&lt;key>&lt;offset>&lt;value></code>设置Bitmaps中某个偏移量的值（0或1）</p><p><img class=img-zoomable src=/images/82e8f396-ad55-40db-b4b5-6dc9201c6e33.png alt></p><p>*offset:偏移量从0开始</p><p>（2）实例</p><p>每个独立用户是否访问过网站存放在Bitmaps中， 将访问的用户记做1， 没有访问的用户记做0， 用偏移量作为用户的id。</p><p>设置键的第offset个位的值（从0算起） ， 假设现在有20个用户，userid=1， 6， 11， 15， 19的用户对网站进行了访问， 那么当前Bitmaps初始化结果如图</p><p><img class=img-zoomable src=/images/b881197f-9c5a-44f1-a9ec-2f68364ca122.png alt></p><p>unique:users:20201106代表2020-11-06这天的独立访问用户的Bitmaps</p><p><img class=img-zoomable src=/images/906ce509-1af2-45c6-9238-4ba96f69eef0.png alt></p><p>注：</p><p>很多应用的用户id以一个指定数字（例如10000） 开头， 直接将用户id和Bitmaps的偏移量对应势必会造成一定的浪费， 通常的做法是每次做setbit操作时将用户id减去这个指定数字。</p><p>在第一次初始化Bitmaps时， 假如偏移量非常大， 那么整个初始化过程执行会比较慢， 可能会造成Redis的阻塞。</p><ol start=2><li>getbit</li></ol><p>（1）格式
getbit<key><offset>获取Bitmaps中某个偏移量的值</p><p>获取键的第offset位的值（从0开始算）</p><p>（2）实例
获取id=8的用户是否在2020-11-06这天访问过， 返回0说明没有访问过</p><p><img class=img-zoomable src=/images/7585a845-40ec-4482-8c9f-03e904de86f1.png alt></p><p>注：因为100根本不存在，所以也是返回0</p><ol start=3><li>bitcount</li></ol><p>统计字符串被设置为1的bit数。一般情况下，给定的整个字符串都会被进行计数，通过指定额外的 start 或 end 参数，可以让计数只在特定的位上进行。start 和 end 参数的设置，都可以使用负数值：比如 -1 表示最后一个位，而 -2 表示倒数第二个位，start、end 是指bit组的字节的下标数，二者皆包含。
（1）格式
bitcount<key>[start end] 统计字符串从start字节到end字节比特值为1的数量</p><p>（2）实例
计算2022-11-06这天的独立访问用户数量</p><p>start和end代表起始和结束字节数， 下面操作计算用户id在第1个字节到第3个字节之间的独立访问用户数， 对应的用户id是11， 15， 19。</p><pre><code>举例： K1 【01000001 01000000  00000000 00100001】，对应【0，1，2，3】
bitcount K1 1 2  ： 统计下标1、2字节组中bit=1的个数，即01000000  00000000
--》bitcount K1 1 2 　　--》1

bitcount K1 1 3  ： 统计下标1、2字节组中bit=1的个数，即01000000  00000000 00100001
--》bitcount K1 1 3　　--》3

bitcount K1 0 -2  ： 统计下标0到下标倒数第2，字节组中bit=1的个数，即01000001  01000000   00000000
--》bitcount K1 0 -2　　--》3
</code></pre><p>注意：redis的setbit设置或清除的是bit位置，而bitcount计算的是byte位置。</p><ol start=4><li>bitop</li></ol><p>(1)格式
bitop and(or/not/xor) <destkey>[key…]</p><p><img class=img-zoomable src=/images/8a7cd908-8bf4-4a7e-8811-9c572487fea9.png alt></p><p>bitop是一个复合操作， 它可以做多个Bitmaps的and（交集） 、 or（并集） 、 not（非） 、 xor（异或） 操作并将结果保存在destkey中。</p><p>(2)实例</p><p>2020-11-04 日访问网站的userid=1,2,5,9。</p><p>setbit unique:users:20201104 1 1</p><p>setbit unique:users:20201104 2 1</p><p>setbit unique:users:20201104 5 1</p><p>setbit unique:users:20201104 9 1</p><p>2020-11-03 日访问网站的userid=0,1,4,9。</p><p>setbit unique:users:20201103 0 1</p><p>setbit unique:users:20201103 1 1</p><p>setbit unique:users:20201103 4 1</p><p>setbit unique:users:20201103 9 1</p><p>计算出两天都访问过网站的用户数量</p><p>bitop and unique:users:and:20201104_03</p><p>unique:users:20201103unique:users:20201104</p><p><img class=img-zoomable src=/images/06377b31-60a0-455e-97c8-7febdf1a07ea.png alt></p><p><img class=img-zoomable src=/images/7ee5ed4d-b2bd-43d4-b7a7-5c26c7562a28.png alt></p><p>计算出任意一天都访问过网站的用户数量（例如月活跃就是类似这种） ， 可以使用or求并集</p><p><img class=img-zoomable src=/images/0a8dfb0f-51f5-4caa-a615-0304b5f4bbf9.png alt></p><h4 id=bitmaps与set对比>Bitmaps与set对比</h4><p>假设网站有1亿用户， 每天独立访问的用户有5千万， 如果每天用集合类型和Bitmaps分别存储活跃用户可以得到表</p><table><thead><tr><th>set和Bitmaps存储一天活跃用户对比</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>数据类型</td><td>每个用户id占用空间</td><td>需要存储的用户量</td><td>全部内存量</td></tr><tr><td>集合类型</td><td>64位</td><td>50000000</td><td>64位*50000000 = 400MB</td></tr><tr><td>Bitmaps</td><td>1位</td><td>100000000</td><td>1位*100000000 = 12.5MB</td></tr></tbody></table><p>很明显， 这种情况下使用Bitmaps能节省很多的内存空间， 尤其是随着时间推移节省的内存还是非常可观的</p><table><thead><tr><th>set和Bitmaps存储独立用户空间对比</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>数据类型</td><td>一天</td><td>一个月</td><td>一年</td></tr><tr><td>集合类型</td><td>400MB</td><td>12GB</td><td>144GB</td></tr><tr><td>Bitmaps</td><td>12.5MB</td><td>375MB</td><td>4.5GB</td></tr></tbody></table><p>但Bitmaps并不是万金油， 假如该网站每天的独立访问用户很少， 例如只有10万（大量的僵尸用户） ， 那么两者的对比如下表所示， 很显然， 这时候使用Bitmaps就不太合适了， 因为基本上大部分位都是0。</p><table><thead><tr><th>set和Bitmaps存储一天活跃用户对比（独立用户比较少）</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>数据类型</td><td>每个userid占用空间</td><td>需要存储的用户量</td><td>全部内存量</td></tr><tr><td>集合类型</td><td>64位</td><td>100000</td><td>64位*100000 = 800KB</td></tr><tr><td>Bitmaps</td><td>1位</td><td>100000000</td><td>1位*100000000 = 12.5MB</td></tr></tbody></table><h3 id=hyperloglog>HyperLogLog</h3><h4 id=简介-6>简介</h4><p>在工作当中，我们经常会遇到与统计相关的功能需求，比如统计网站PV（PageView页面访问量）,可以使用Redis的incr、incrby轻松实现。
但像UV（UniqueVisitor，独立访客）、独立IP数、搜索记录数等需要去重和计数的问题如何解决？这种求集合中不重复元素个数的问题称为基数问题。
解决基数问题有很多种方案：
（1）数据存储在MySQL表中，使用distinct count计算不重复个数</p><p>（2）使用Redis提供的hash、set、bitmaps等数据结构来处理</p><p>以上的方案结果精确，但随着数据不断增加，导致占用空间越来越大，对于非常大的数据集是不切实际的。</p><p>能否能够降低一定的精度来平衡存储空间？Redis推出了HyperLogLog</p><p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。</p><p>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p><p>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p><p>什么是基数?</p><p>比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。</p><h4 id=命令-1>命令</h4><p>1、pfadd</p><p>（1）格式</p><p>pfadd <key>&lt; element> [element &mldr;] 添加指定元素到 HyperLogLog 中</p><p><img class=img-zoomable src=/images/62e21699-dc0f-46bd-82cb-029f3222fbc7.png alt></p><p>（2）实例</p><p><img class=img-zoomable src=/images/c2f7d56a-b3f5-4a35-9b22-d974527449b0.png alt></p><p>​ 将所有元素添加到指定HyperLogLog数据结构中。如果执行命令后HLL估计的近似基数发生变化，则返回1，否则返回0。</p><p>2、pfcount</p><p>（1）格式</p><p>pfcount<key> [key &mldr;] 计算HLL的近似基数，可以计算多个HLL，比如用HLL存储每天的UV，计算一周的UV可以使用7天的UV合并计算即可</p><p><img class=img-zoomable src=/images/f809026c-fc64-48fe-be04-706e6cc41f44.png alt></p><p>（2）实例</p><p><img class=img-zoomable src=/images/f5b58b59-9932-4057-bd8f-60432b157770.png alt></p><p>3、pfmerge</p><p>（1）格式</p><p>pfmerge<destkey><sourcekey> [sourcekey &mldr;] 将一个或多个HLL合并后的结果存储在另一个HLL中，比如每月活跃用户可以使用每天的活跃用户来合并计算可得</p><p><img class=img-zoomable src=/images/631183a5-9ff4-48b7-ac89-fbdd7789d129.png alt></p><p>（2）实例</p><p><img class=img-zoomable src=/images/dfd3ee89-78e6-42ce-a229-dc9cefd1cec4.png alt></p><h3 id=geospatial>Geospatial</h3><h4 id=简介-7>简介</h4><p>Redis 3.2 中增加了对GEO类型的支持。GEO，Geographic，地理信息的缩写。该类型，就是元素的2维坐标，在地图上就是经纬度。redis基于该类型，提供了经纬度设置，查询，范围查询，距离查询，经纬度Hash等常见操作。</p><h4 id=命令-2>命令</h4><p>1、geoadd</p><p>（1）格式</p><p>geoadd<key>&lt; longitude><latitude><member> [longitude latitude member&mldr;] 添加地理位置（经度，纬度，名称）</p><p><img class=img-zoomable src=/images/05ef798c-3889-4c03-91d4-90b1f15c9956.png alt></p><p>2）实例</p><p>geoadd china:city 121.47 31.23 shanghai</p><p>geoadd china:city 106.50 29.53 chongqing 114.05 22.52 shenzhen 116.38 39.90 beijing</p><p><img class=img-zoomable src=/images/8ac8b0f3-9cfb-40e5-9cb9-8ef5b49ec1b6.png alt></p><p>两极无法直接添加，一般会下载城市数据，直接通过 Java 程序一次性导入。</p><p>有效的经度从 -180 度到 180 度。有效的纬度从 -85.05112878 度到 85.05112878 度。</p><p>当坐标位置超出指定范围时，该命令将会返回一个错误。</p><p>已经添加的数据，是无法再次往里面添加的。</p><p>2、geopos</p><p>（1）格式</p><p>geopos <key><member>[member&mldr;] 获得指定地区的坐标值</p><p><img class=img-zoomable src=/images/d0233779-9639-4787-8e99-3283ac7e855e.png alt></p><p>（2）实例</p><p><img class=img-zoomable src=/images/71ab3c6c-66ca-4a71-b6d2-f16555a3e548.png alt></p><p>3、geodist</p><p>（1）格式</p><p>geodist<key><member1><member2> [m|km|ft|mi ] 获取两个位置之间的直线距离</p><p><img class=img-zoomable src=/images/ed4cb462-5939-4c09-9392-bd6c6b50dec6.png alt></p><p>（2）实例</p><p>获取两个位置之间的直线距离</p><p><img class=img-zoomable src=/images/c5817ee3-a137-430a-9734-c3a51179382f.png alt></p><p>单位：</p><p>m 表示单位为米[默认值]。</p><p>km 表示单位为千米。</p><p>mi 表示单位为英里。</p><p>ft 表示单位为英尺。</p><p>如果用户没有显式地指定单位参数， 那么 GEODIST 默认使用米作为单位</p><p>4、georadius</p><p>（1）格式</p><p>georadius<key>&lt; longitude><latitude>radius m|km|ft|mi 以给定的经纬度为中心，找出某一半径内的元素</p><p><img class=img-zoomable src=/images/63d0253a-d296-4b59-9b3a-0cda8db7167f.png alt></p><p>经度 纬度 距离 单位</p><p>（2）实例</p><p><img class=img-zoomable src=/images/bd56b575-3eab-442e-aa42-fb8768d47bb1.png alt></p></div></article><div class="license markdown-body"><blockquote><p>Unless otherwise noted, the content of this site is licensed under <a rel=license href=http://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank>CC BY-NC-SA 4.0</a>.</p></blockquote></div></div><aside class="col-12 col-md-3 float-left sidebar"><div class="sidebar-item sidebar-pages"><h3>Pages</h3><ul><li><a href=/>Home</a></li><li><a href=/archives/>Archives</a></li><li><a href=/index.xml>RSS</a></li><li><a href=/about/>About</a></li><li><a href=/search/>Search</a></li></ul></div><div class="sidebar-item sidebar-links"><h3>Links</h3><ul><li><a href=https://github.com/daemon365 target=_blank><span>My GitHub</span></a></li></ul></div><div class="sidebar-item sidebar-tags"><h3>Tags</h3><div><span><a href=/tags/bbr/>BBR</a>
</span><span><a href=/tags/boltdb/>Boltdb</a>
</span><span><a href=/tags/breaker/>Breaker</a>
</span><span><a href=/tags/cdi/>Cdi</a>
</span><span><a href=/tags/cgroup/>Cgroup</a>
</span><span><a href=/tags/client-go/>Client-Go</a>
</span><span><a href=/tags/cni/>Cni</a>
</span><span><a href=/tags/containerd/>Containerd</a>
</span><span><a href=/tags/containerd-shim/>Containerd-Shim</a>
</span><span><a href=/tags/cri/>Cri</a>
</span><span><a href=/tags/csi/>Csi</a>
</span><span><a href=/tags/docker/>Docker</a>
</span><span><a href=/tags/etcd/>Etcd</a>
</span><span><a href=/tags/gin/>Gin</a>
</span><span><a href=/tags/go/>Go</a>
</span><span><a href=/tags/golang/>Golang</a>
</span><span><a href=/tags/grpc/>Grpc</a>
</span><span><a href=/tags/iptables/>Iptables</a>
</span><span><a href=/tags/ipvs/>Ipvs</a>
</span><span><a href=/tags/istio/>Istio</a>
</span><span><a href=/tags/kratos/>Kratos</a>
</span><span><a href=/tags/kube-proxy/>Kube-Proxy</a>
</span><span><a href=/tags/kubelet/>Kubelet</a>
</span><span><a href=/tags/kubernetes/>Kubernetes</a>
</span><span><a href=/tags/linux/>Linux</a>
</span><span><a href=/tags/lua/>Lua</a>
</span><span><a href=/tags/makefile/>Makefile</a>
</span><span><a href=/tags/mysql/>Mysql</a>
</span><span><a href=/tags/namespace/>Namespace</a>
</span><span><a href=/tags/network/>Network</a>
</span><span><a href=/tags/nginx/>Nginx</a>
</span><span><a href=/tags/opentelemetry/>Opentelemetry</a>
</span><span><a href=/tags/prometheus/>Prometheus</a>
</span><span><a href=/tags/protobuf/>Protobuf</a>
</span><span><a href=/tags/rabbitmq/>RabbitMQ</a>
</span><span><a href=/tags/redis/>Redis</a>
</span><span><a href=/tags/runc/>Runc</a>
</span><span><a href=/tags/service-mesh/>Service Mesh</a>
</span><span><a href=/tags/sidecar/>Sidecar</a>
</span><span><a href=/tags/sqlx/>Sqlx</a>
</span><span><a href=/tags/thrift/>Thrift</a>
</span><span><a href=/tags/unionfs/>UnionFS</a>
</span><span><a href=/tags/viper/>Viper</a>
</span><span><a href=/tags/vscode/>Vscode</a>
</span><span><a href=/tags/wire/>Wire</a>
</span><span><a href=/tags/zap/>Zap</a>
</span><span><a href=/tags/%E4%BA%8B%E5%8A%A1/>事务</a>
</span><span><a href=/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/>数据库</a>
</span><span><a href=/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/>源码分析</a>
</span><span><a href=/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>设计模式</a></span></div></div><div class="sidebar-item sidebar-toc"><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#redis介绍>redis介绍</a><ul><li><a href=#redis的安装>redis的安装</a></li></ul></li><li><a href=#redis的命令网站>redis的命令网站</a></li><li><a href=#redis的基本操作>redis的基本操作</a><ul><li><a href=#redis的五大数据类型>redis的五大数据类型</a></li><li><a href=#redis键操作>redis键操作</a></li><li><a href=#字符串string>字符串(String)</a></li><li><a href=#列表list>列表(List)</a></li><li><a href=#集合set>集合(Set)</a></li><li><a href=#哈希hash>哈希(Hash)</a></li><li><a href=#有序集合zsetsorted-set>有序集合Zset(sorted set)</a></li></ul></li><li><a href=#redis新数据类型>Redis新数据类型</a><ul><li><a href=#bitmaps>Bitmaps</a></li><li><a href=#hyperloglog>HyperLogLog</a></li><li><a href=#geospatial>Geospatial</a></li></ul></li></ul></nav></div></aside></div><div class=btn><div class=btn-menu id=btn-menu><i class="iconfont icon-grid-sharp"></i></div><div class=btn-toggle-mode><i class="iconfont icon-contrast-sharp"></i></div><div class=btn-scroll-top><i class="iconfont icon-chevron-up-circle-sharp"></i></div></div><aside class=sidebar-mobile style=display:none><div class=sidebar-wrapper><div class="sidebar-item sidebar-pages"><h3>Pages</h3><ul><li><a href=/>Home</a></li><li><a href=/archives/>Archives</a></li><li><a href=/index.xml>RSS</a></li><li><a href=/about/>About</a></li><li><a href=/search/>Search</a></li></ul></div><div class="sidebar-item sidebar-links"><h3>Links</h3><ul><li><a href=https://github.com/daemon365 target=_blank><span>My GitHub</span></a></li></ul></div><div class="sidebar-item sidebar-tags"><h3>Tags</h3><div><span><a href=/tags/bbr/>BBR</a>
</span><span><a href=/tags/boltdb/>Boltdb</a>
</span><span><a href=/tags/breaker/>Breaker</a>
</span><span><a href=/tags/cdi/>Cdi</a>
</span><span><a href=/tags/cgroup/>Cgroup</a>
</span><span><a href=/tags/client-go/>Client-Go</a>
</span><span><a href=/tags/cni/>Cni</a>
</span><span><a href=/tags/containerd/>Containerd</a>
</span><span><a href=/tags/containerd-shim/>Containerd-Shim</a>
</span><span><a href=/tags/cri/>Cri</a>
</span><span><a href=/tags/csi/>Csi</a>
</span><span><a href=/tags/docker/>Docker</a>
</span><span><a href=/tags/etcd/>Etcd</a>
</span><span><a href=/tags/gin/>Gin</a>
</span><span><a href=/tags/go/>Go</a>
</span><span><a href=/tags/golang/>Golang</a>
</span><span><a href=/tags/grpc/>Grpc</a>
</span><span><a href=/tags/iptables/>Iptables</a>
</span><span><a href=/tags/ipvs/>Ipvs</a>
</span><span><a href=/tags/istio/>Istio</a>
</span><span><a href=/tags/kratos/>Kratos</a>
</span><span><a href=/tags/kube-proxy/>Kube-Proxy</a>
</span><span><a href=/tags/kubelet/>Kubelet</a>
</span><span><a href=/tags/kubernetes/>Kubernetes</a>
</span><span><a href=/tags/linux/>Linux</a>
</span><span><a href=/tags/lua/>Lua</a>
</span><span><a href=/tags/makefile/>Makefile</a>
</span><span><a href=/tags/mysql/>Mysql</a>
</span><span><a href=/tags/namespace/>Namespace</a>
</span><span><a href=/tags/network/>Network</a>
</span><span><a href=/tags/nginx/>Nginx</a>
</span><span><a href=/tags/opentelemetry/>Opentelemetry</a>
</span><span><a href=/tags/prometheus/>Prometheus</a>
</span><span><a href=/tags/protobuf/>Protobuf</a>
</span><span><a href=/tags/rabbitmq/>RabbitMQ</a>
</span><span><a href=/tags/redis/>Redis</a>
</span><span><a href=/tags/runc/>Runc</a>
</span><span><a href=/tags/service-mesh/>Service Mesh</a>
</span><span><a href=/tags/sidecar/>Sidecar</a>
</span><span><a href=/tags/sqlx/>Sqlx</a>
</span><span><a href=/tags/thrift/>Thrift</a>
</span><span><a href=/tags/unionfs/>UnionFS</a>
</span><span><a href=/tags/viper/>Viper</a>
</span><span><a href=/tags/vscode/>Vscode</a>
</span><span><a href=/tags/wire/>Wire</a>
</span><span><a href=/tags/zap/>Zap</a>
</span><span><a href=/tags/%E4%BA%8B%E5%8A%A1/>事务</a>
</span><span><a href=/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/>数据库</a>
</span><span><a href=/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/>源码分析</a>
</span><span><a href=/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>设计模式</a></span></div></div><div class="sidebar-item sidebar-toc"><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#redis介绍>redis介绍</a><ul><li><a href=#redis的安装>redis的安装</a></li></ul></li><li><a href=#redis的命令网站>redis的命令网站</a></li><li><a href=#redis的基本操作>redis的基本操作</a><ul><li><a href=#redis的五大数据类型>redis的五大数据类型</a></li><li><a href=#redis键操作>redis键操作</a></li><li><a href=#字符串string>字符串(String)</a></li><li><a href=#列表list>列表(List)</a></li><li><a href=#集合set>集合(Set)</a></li><li><a href=#哈希hash>哈希(Hash)</a></li><li><a href=#有序集合zsetsorted-set>有序集合Zset(sorted set)</a></li></ul></li><li><a href=#redis新数据类型>Redis新数据类型</a><ul><li><a href=#bitmaps>Bitmaps</a></li><li><a href=#hyperloglog>HyperLogLog</a></li><li><a href=#geospatial>Geospatial</a></li></ul></li></ul></nav></div></div></aside></main><footer><div class="container-lg clearfix"><div class="col-12 footer"><span>&copy; 2019-2024
<a href=https://daemon365.dev/>daemon365</a>
| Powered by <a href=https://github.com/dsrkafuu/hugo-theme-fuji/ target=_blank>Fuji-v2</a> & <a href=https://gohugo.io/ target=_blank>Hugo</a></span></div></div></footer><script defer src=https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js integrity="sha512-q583ppKrCRc7N5O0n2nzUiJ+suUv7Et1JGels4bXOaMFQcamPk9HjdUknZuuFjBNs7tsMuadge5k9RzdmO+1GQ==" crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1.27.0/components/prism-core.min.js integrity="sha512-LCKPTo0gtJ74zCNMbWw04ltmujpzSR4oW+fgN+Y1YclhM5ZrHCZQAJE4quEodcI/G122sRhSGU2BsSRUZ2Gu3w==" crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1.27.0/plugins/autoloader/prism-autoloader.min.js integrity="sha512-GP4x8UWxWyh4BMbyJGOGneiTbkrWEF5izsVJByzVLodP8CuJH/n936+yQDMJJrOPUHLgyPbLiGw2rXmdvGdXHA==" crossorigin=anonymous></script><script defer src=/assets/js/fuji.min.645f1123be695831f419ab54c1bcba327325895c740014006e57070d4f3e5d6b553e929c4b46f40ea707249e9c7f7c2a446d32a39ce7319f80a34525586a8e0f.js integrity="sha512-ZF8RI75pWDH0GatUwby6MnMliVx0ABQAblcHDU8+XWtVPpKcS0b0DqcHJJ6cf3wqRG0yo5znMZ+Ao0UlWGqODw=="></script></body></html>