<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=HandheldFriendly content="True"><meta http-equiv=X-UA-Compatible content="IE=edge"><meta http-equiv=Cache-Control content="no-transform"><meta http-equiv=Cache-Control content="no-siteapp"><meta name=generator content="Hugo 0.128.2"><link rel="shortcut icon" href=/imgs/icons/favicon.ico><title>golang channel原理 - Daemon</title>
<meta name=author content="daemon365"><meta name=description content="Don't let yourself stop."><meta name=keywords content="go,源码分析"><meta property="og:title" content="golang channel原理"><meta name=twitter:title content="golang channel原理"><meta property="og:type" content="article"><meta property="og:url" content="https://daemon365.dev/2021/02/21/golang-channel%E5%8E%9F%E7%90%86/"><meta property="og:description" content="channel介绍 channel一个类型管道，通过它可以在goroutine之间发送和接收消息。它是Golang在语言层面提供的goroutine间的通信方式。 众所周知，Go依赖于称为CSP（Comm"><meta name=twitter:description content="channel介绍 channel一个类型管道，通过它可以在goroutine之间发送和接收消息。它是Golang在语言层面提供的goroutine间的通信方式。 众所周知，Go依赖于称为CSP（Comm"><meta property="og:image" content="https://daemon365.dev/imgs/icons/favicon.ico"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://daemon365.dev/imgs/icons/favicon.ico"><meta property="article:published_time" content="2021-02-21T00:00:00+08:00"><meta property="article:modified_time" content="2021-02-21T00:00:00+08:00"><style>@media(prefers-color-scheme:dark){body[data-theme=auto] img{filter:brightness(60%)}}body[data-theme=dark] img{filter:brightness(60%)}</style><link rel=stylesheet href=https://daemon365.dev/assets/css/fuji.min.4705982b44df69092424841b031cb53013b315bd3fc70b72a14573d9be9705d6c11ab2f470b6bfab457823a2d1514588c57fa2a790745edd3d30f0ca51c06e4f.css integrity="sha512-RwWYK0TfaQkkJIQbAxy1MBOzFb0/xwtyoUVz2b6XBdbBGrL0cLa/q0V4I6LRUUWIxX+ip5B0Xt09MPDKUcBuTw=="></head><body data-theme=light data-theme-auto=false><script data-cfasync=false>var fujiThemeData=localStorage.getItem("fuji_data-theme");fujiThemeData?fujiThemeData!=="auto"&&document.body.setAttribute("data-theme",fujiThemeData==="dark"?"dark":"light"):localStorage.setItem("fuji_data-theme","auto")</script><header><div class="container-lg clearfix"><div class="col-12 header"><a class=title-main href=https://daemon365.dev/>Daemon</a>
<span class=title-sub>Don't let yourself stop.</span></div></div></header><main><div class="container-lg clearfix"><div class="col-12 col-md-9 float-left content"><article><h2 class="post-item post-title"><a href=https://daemon365.dev/2021/02/21/golang-channel%E5%8E%9F%E7%90%86/>golang channel原理</a></h2><div class="post-item post-meta"><span><i class="iconfont icon-today-sharp"></i>&nbsp;2021-02-21</span>
<span><i class="iconfont icon-file-tray-sharp"></i>&nbsp;3917 words</span>
<span><i class="iconfont icon-pricetags-sharp"></i>&nbsp;<a href=/tags/go>go</a>&nbsp;<a href=/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90>源码分析</a>&nbsp;</span></div><div class="post-content markdown-body"><h2 id=channel介绍>channel介绍</h2><p>channel一个类型管道，通过它可以在goroutine之间发送和接收消息。它是Golang在语言层面提供的goroutine间的通信方式。</p><p>众所周知，Go依赖于称为CSP（Communicating Sequential Processes）的并发模型，通过Channel实现这种同步模式。Go并发的核心哲学是不要通过共享内存进行通信; 相反，通过沟通分享记忆。</p><p>下面以简单的示例来演示Go如何通过channel来实现通信。</p><pre><code class=language-go>package main
import (
    &quot;fmt&quot;
    &quot;time&quot;
)
func goRoutineA(a &lt;-chan int) {
    val := &lt;-a
    fmt.Println(&quot;goRoutineA received the data&quot;, val)
}
func goRoutineB(b chan int) {
    val := &lt;-b
    fmt.Println(&quot;goRoutineB  received the data&quot;, val)
}
func main() {
    ch := make(chan int, 3)
    go goRoutineA(ch)
    go goRoutineB(ch)
    ch &lt;- 3
    time.Sleep(time.Second * 1)
}
</code></pre><p>结果为：<code>goRoutineA received the data 3</code></p><p>上面只是个简单的例子，只输出goRoutineA ，没有执行goRoutineB，说明channel仅允许被一个goroutine读写。</p><p>go并发知识：<a href=https://www.cnblogs.com/yuemoxi/p/15161276.html target=_blank>链接</a></p><p>说道channel这里不得不提通道的结构hchan。</p><h2 id=hchan>hchan</h2><p>源代码在src/runtime/chan.go</p><pre><code class=language-go>type hchan struct {
   qcount   uint           // total data in the queue
   dataqsiz uint           // size of the circular queue
   buf      unsafe.Pointer // points to an array of dataqsiz elements
   elemsize uint16
   closed   uint32
   elemtype *_type // element type
   sendx    uint   // send index
   recvx    uint   // receive index
   recvq    waitq  // list of recv waiters
   sendq    waitq  // list of send waiters

   // lock protects all fields in hchan, as well as several
   // fields in sudogs blocked on this channel.
   //
   // Do not change another G's status while holding this lock
   // (in particular, do not ready a G), as this can deadlock
   // with stack shrinking.
   lock mutex
}
type waitq struct {
    first *sudog
    last  *sudog
}
</code></pre><p>说明：</p><ul><li><strong>qcount</strong> uint // 当前队列中剩余元素个数</li><li><strong>dataqsiz</strong> uint // 环形队列长度，即缓冲区的大小，即make（chan T，N），N.</li><li><strong>buf</strong> unsafe.Pointer // 环形队列指针</li><li><strong>elemsize</strong> uint16 // 每个元素的大小</li><li><strong>closed</strong> uint32 // 表示当前通道是否处于关闭状态。创建通道后，该字段设置为0，即通道打开; 通过调用close将其设置为1，通道关闭。</li><li><strong>elemtype</strong> *_type // 元素类型，用于数据传递过程中的赋值；</li><li><strong>sendx</strong> uint和<strong>recvx</strong> uint是环形缓冲区的状态字段，它指示缓冲区的当前索引 - 支持数组，它可以从中发送数据和接收数据。</li><li><strong>recvq</strong> waitq // 等待读消息的goroutine队列</li><li><strong>sendq</strong> waitq // 等待写消息的goroutine队列</li><li><strong>lock</strong> mutex // 互斥锁，为每个读写操作锁定通道，因为发送和接收必须是互斥操作。</li></ul><p>这里<strong>sudog代表goroutine。</strong></p><h2 id=make-chan>make chan</h2><p>make函数在创建channel的时候会在该进程的heap区申请一块内存，创建一个hchan结构体，返回执行该内存的指针，所以获取的的ch变量本身就是一个指针，在函数之间传递的时候是同一个channel。</p><p>hchan结构体使<strong>用一个环形队列</strong>来保存groutine之间传递的数据(如果是缓存channel的话)，使用<strong>两个list</strong>保存像该chan发送和从该chan接收数据的goroutine，还有一个mutex来保证操作这些结构的安全。</p><p>创建channel 有两种，一种是带缓冲的channel，一种是不带缓冲的channel</p><pre><code class=language-go>// 带缓冲
ch := make(chan Task, 3)
// 不带缓冲
ch := make(chan int)
</code></pre><p>这里我们先讨论带缓冲</p><pre><code class=language-go>ch := make(chan int, 3)
</code></pre><p>创建通道后的缓冲通道结构</p><pre><code class=language-go>hchan struct {
    qcount uint : 0 
    dataqsiz uint : 3 
    buf unsafe.Pointer : 0xc00007e0e0 
    elemsize uint16 : 8 
    closed uint32 : 0 
    elemtype *runtime._type : &amp;{
        size:8 
        ptrdata:0 
        hash:4149441018 
        tflag:7 
        align:8 
        fieldalign:8 
        kind:130 
        alg:0x55cdf0 
        gcdata:0x4d61b4 
        str:1055 
        ptrToThis:45152
        }
    sendx uint : 0 
    recvx uint : 0 
    recvq runtime.waitq : 
        {first:&lt;nil&gt; last:&lt;nil&gt;}
    sendq runtime.waitq : 
        {first:&lt;nil&gt; last:&lt;nil&gt;}
    lock runtime.mutex : 
        {key:0}
}
</code></pre><p>源代码</p><pre><code class=language-go>func makechan(t *chantype, size int) *hchan {

   elem := t.elem
   ...
}
</code></pre><p>如果我们创建一个带buffer的channel，底层的数据模型如下图：</p><p><img class=img-zoomable src=/images/44becf0e-3cef-4a92-ad1b-74b0d3be075d.png alt></p><h2 id=发送和接受数据>发送和接受数据</h2><p>向channel发送和从channel接收数据主要涉及hchan里的四个成员变量，借用Kavya ppt里的图示，来分析发送和接收的过程。</p><p><img class=img-zoomable src=/images/1c0e0400-0356-483d-9144-1ed65764ec37.png alt></p><h3 id=向channel写入数据>向channel写入数据</h3><pre><code class=language-go>ch &lt;- 3
</code></pre><p>底层hchan数据流程如图</p><p><img class=img-zoomable src=/images/dbd15c57-37a3-4d27-b110-d78695a1ed23.png alt>
<img class=img-zoomable src=/images/aeb25cf7-f059-4086-a8e7-26efb72aa85e.png alt></p><p>发送操作概要</p><p>1、锁定整个通道结构。</p><p>2、确定写入。尝试<code>recvq</code>从等待队列中等待goroutine，然后将元素直接写入goroutine。</p><p>3、如果recvq为Empty，则确定缓冲区是否可用。如果可用，从当前goroutine复制数据到缓冲区。</p><p>4、如果缓冲区已满，<strong>则要</strong>写入的元素将保存在当前正在执行的goroutine的结构中，并且当前goroutine将在<strong>sendq中</strong>排队并从运行时挂起。</p><p>5、写入完成释放锁。</p><p>这里我们要注意几个属性buf、sendx、lock的变化。</p><p>流程图</p><p><img class=img-zoomable src=/images/45ec829d-b33d-49df-8be8-a2adb1f6c2f2.png alt></p><h3 id=从channel读取操作>从channel读取操作</h3><p>几乎和写入操作相同</p><p>代码</p><pre><code class=language-go>func goRoutineA(a &lt;-chan int) {
   val := &lt;-a
   fmt.Println(&quot;goRoutineA received the data&quot;, val)
}
</code></pre><p>底层hchan数据流程如图</p><p><img class=img-zoomable src=/images/35c33001-5ed0-43b5-88bb-78d533a3174d.png alt>
<img class=img-zoomable src=/images/0386fc04-eeb6-4fb8-bcca-dec41f787ddd.png alt></p><p>这里我们要注意几个属性buf、sendx、recvx、lock的变化。</p><p>读取操作概要</p><ol><li>先获取channel全局锁</li><li>尝试sendq从等待队列中获取等待的goroutine，</li><li>如有等待的goroutine，没有缓冲区，取出goroutine并读取数据，然后唤醒这个goroutine，结束读取释放锁。</li><li>如有等待的goroutine，且有缓冲区（此时缓冲区已满），从缓冲区队首取出数据，再从sendq取出一个goroutine，将goroutine中的数据存入buf队尾，结束读取释放锁。</li><li>如没有等待的goroutine，且缓冲区有数据，直接读取缓冲区数据，结束读取释放锁。</li><li>如没有等待的goroutine，且没有缓冲区或缓冲区为空，将当前的goroutine加入<strong>recvq</strong>排队，进入睡眠，等待被写goroutine唤醒。结束读取释放锁。</li></ol><p>流程图</p><p><img class=img-zoomable src=/images/3f234e37-388e-4070-ae49-5e3b22f59382.png alt></p><h2 id=recvq和sendq-结构>recvq和sendq 结构</h2><p>recvq和sendq基本上是链表，看起来基本如下</p><p><img class=img-zoomable src=/images/d46ef751-eb47-4517-bdf7-a9e0b42a169e.png alt></p><h2 id=goroutine-pauseresume>Goroutine Pause/Resume</h2><p>goroutine是Golang实现的用户空间的轻量级的线程，有runtime调度器调度，与操作系统的thread有多对一的关系，相关的数据结构如下图:</p><p><img class=img-zoomable src=/images/982fea32-4940-4297-bf63-b608f4e04e44.png alt></p><p>其中M是操作系统的线程，G是用户启动的goroutine，P是与调度相关的context，每个M都拥有一个P，P维护了一个能够运行的goutine队列，用于该线程执行。</p><p>当G1向buf已经满了的ch发送数据的时候，当runtine检测到对应的hchan的buf已经满了，会通知调度器，调度器会将G1的状态设置为waiting, 移除与线程M的联系，然后从P的runqueue中选择一个goroutine在线程M中执行，此时G1就是阻塞状态，但是不是操作系统的线程阻塞，所以这个时候只用消耗少量的资源。</p><p>那么G1设置为waiting状态后去哪了？怎们去resume呢？我们再回到hchan结构体，注意到hchan有个sendq的成员，其类型是waitq，查看源码如下：</p><pre><code class=language-go>type hchan struct { 
    ... 
    recvq waitq // list of recv waiters 
    sendq waitq // list of send waiters 
    ... 
} 
// 
type waitq struct { 
    first *sudog 
    last *sudog 
} 
</code></pre><p>实际上，当G1变为waiting状态后，会创建一个代表自己的sudog的结构，然后放到sendq这个list中，sudog结构中保存了channel相关的变量的指针(如果该Goroutine是sender，那么保存的是待发送数据的变量的地址，如果是receiver则为接收数据的变量的地址，之所以是地址，前面我们提到在传输数据的时候使用的是copy的方式)</p><p><img class=img-zoomable src=/images/f8569a70-a969-44db-bd7f-e777dcaa597e.png alt></p><p>当G2从ch中接收一个数据时，会通知调度器，设置G1的状态为runnable，然后将加入P的runqueue里，等待线程执行.</p><p><img class=img-zoomable src=/images/770ea2fb-2a34-4061-b34b-a1e600e62be8.png alt></p><h2 id=wait-empty-channel>wait empty channel</h2><p>前面我们是假设G1先运行，如果G2先运行会怎么样呢？如果G2先运行，那么G2会从一个empty的channel里取数据，这个时候G2就会阻塞，和前面介绍的G1阻塞一样，G2也会创建一个sudog结构体，保存接收数据的变量的地址，但是该sudog结构体是放到了recvq列表里，当G1向ch发送数据的时候，<strong>runtime并没有对hchan结构体题的buf进行加锁，而是直接将G1里的发送到ch的数据copy到了G2 sudog里对应的elem指向的内存地址！</strong></p><p><img class=img-zoomable src=/images/daa8420b-64fe-4672-8de1-e68160550fe7.png alt></p><h2 id=select>select</h2><p>select就是用来监听和channel有关的IO操作，当 IO 操作发生时，触发相应的动作。</p><p>一个简单的示例如下</p><pre><code class=language-go>package main

import (
   &quot;fmt&quot;
   &quot;time&quot;
)

func goRoutineD(ch chan int, i int) {
   time.Sleep(time.Second * 3)
   ch &lt;- i
}
func goRoutineE(chs chan string, i string) {
   time.Sleep(time.Second * 3)
   chs &lt;- i

}

func main() {
   ch := make(chan int, 5)
   chs := make(chan string, 5)

   go goRoutineD(ch, 5)
   go goRoutineE(chs, &quot;ok&quot;)

    select {
    case msg := &lt;-ch:
        fmt.Println(&quot; received the data &quot;, msg)
    case msgs := &lt;-chs:
        fmt.Println(&quot; received the data &quot;, msgs)
    default:
        fmt.Println(&quot;no data received &quot;)
        time.Sleep(time.Second * 1)
    }

}
</code></pre><p>运行程序，因为当前时间没有到3s，所以select 选择defult</p><p><code>no data received</code></p><p>修改程序，我们注释掉default，并多执行几次结果为</p><pre><code>received the data 5

received the data ok

received the data ok

received the data ok
</code></pre><p>select语句会阻塞，直到监测到一个可以执行的IO操作为止，而这里goRoutineD和goRoutineE睡眠时间是相同的，都是3s，从输出可看出，从channel中读出数据的顺序是随机的。</p><p>再修改代码，goRoutineD睡眠时间改成4s</p><pre><code class=language-go>func goRoutineD(ch chan int, i int) {
   time.Sleep(time.Second * 4)
   ch &lt;- i
}
</code></pre><p>此时会先执行goRoutineE，select 选择case msgs := &lt;-chs。</p><h2 id=range>range</h2><p>可以持续从channel读取数据，一直到channel被关闭，当channel中没有数据时会阻塞当前goroutine，与读channel时阻塞处理机制一样。</p><pre><code class=language-go>package main

import (
   &quot;fmt&quot;
   &quot;time&quot;
)

func goRoutineD(ch chan int, i int) {
   for   i := 1; i &lt;= 5; i++{
      ch &lt;- i
   }

}
func chanRange(chanName chan int) {
   for e := range chanName {
      fmt.Printf(&quot;Get element from chan: %d\n&quot;, e)
      if len(chanName) &lt;= 0 { // 如果现有数据量为0，跳出循环
            break
      }
   }
}
func main() {
   ch := make(chan int, 5)
   go goRoutineD(ch, 5)
   chanRange(ch)

}
</code></pre><p>结果：</p><pre><code>Get element from chan: 1
Get element from chan: 2
Get element from chan: 3
Get element from chan: 4
Get element from chan: 5
</code></pre><h2 id=死锁deadlock>死锁（deadlock）</h2><p>指两个或两个以上的协程的执行过程中，由于竞争资源或由于彼此通信而造成的一种阻塞的现象。</p><p>在非缓冲信道若发生只流入不流出，或只流出不流入，就会发生死锁。</p><p>下面是一些死锁的例子</p><p>1、</p><pre><code>package main

func main() {
   ch := make(chan int)
   ch &lt;- 3
}
</code></pre><p>上面情况，向非缓冲通道写数据会发生阻塞，导致死锁。解决办法创建缓冲区 ch := make(chan int，3)</p><p>2、</p><pre><code class=language-go>package main

import (
   &quot;fmt&quot;
)

func main() {
   ch := make(chan int)
   fmt.Println(&lt;-ch)
}
</code></pre><p>向非缓冲通道读取数据会发生阻塞，导致死锁。 解决办法开启缓冲区，先向channel写入数据。</p><p>3、</p><pre><code class=language-go>package main

func main() {
   ch := make(chan int, 3)
   ch &lt;- 3
   ch &lt;- 4
   ch &lt;- 5
   ch &lt;- 6
}
</code></pre><p>写入数据超过缓冲区数量也会发生死锁。解决办法将写入数据取走。</p><p>死锁的情况有很多这里不再赘述。
还有一种情况，向关闭的channel写入数据，不会产生死锁，产生panic。</p><pre><code class=language-go>package main

func main() {
    ch := make(chan int, 3)
    ch &lt;- 1
    close(ch)
    ch &lt;- 2
}
</code></pre><p>解决办法别向关闭的channel写入数据。</p><h2 id=参考文章>参考文章</h2><ul><li><a href=https://segmentfault.com/a/1190000019172554 target=_blank>Go channel 实现原理分析</a></li><li><a href=https://zhuanlan.zhihu.com/p/27917262 target=_blank>深入理解Golang Channel</a></li></ul></div></article><div class="license markdown-body"><blockquote><p>Unless otherwise noted, the content of this site is licensed under <a rel=license href=http://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank>CC BY-NC-SA 4.0</a>.</p></blockquote></div><div class=post-comment data-comment=utterances><span class=post-comment-notloaded><i class="iconfont icon-chatbox-ellipses-sharp"></i>&nbsp;Load comments
</span><script>function loadComment(){var e,n=document.querySelector(".post-comment"),t=document.body.getAttribute("data-theme");t==="auto"?t=window.matchMedia("(prefers-color-scheme: dark)").matches?"photon-dark":"github-light":t=t==="dark"?"photon-dark":"github-light",e=document.createElement("script"),e.src="https://utteranc.es/client.js",e.setAttribute("repo","daemon365/daemon365.github.io"),e.setAttribute("issue-term","pathname"),e.setAttribute("theme",t),e.setAttribute("crossorigin","anonymous"),e.setAttribute("async",""),document.querySelector(".post-comment").appendChild(e),document.querySelector("span.post-comment-notloaded").setAttribute("style","display: none;")}</script></div></div><aside class="col-12 col-md-3 float-left sidebar"><div class="sidebar-item sidebar-pages"><h3>Pages</h3><ul><li><a href=/>Home</a></li><li><a href=/archives/>Archives</a></li><li><a href=/index.xml>RSS</a></li><li><a href=/about/>About</a></li><li><a href=/search/>Search</a></li></ul></div><div class="sidebar-item sidebar-links"><h3>Links</h3><ul><li><a href=https://github.com/daemon365 target=_blank><span>My GitHub</span></a></li></ul></div><div class="sidebar-item sidebar-tags"><h3>Tags</h3><div><span><a href=/tags/bbr/>BBR</a>
</span><span><a href=/tags/boltdb/>Boltdb</a>
</span><span><a href=/tags/breaker/>Breaker</a>
</span><span><a href=/tags/cdi/>Cdi</a>
</span><span><a href=/tags/cgroup/>Cgroup</a>
</span><span><a href=/tags/client-go/>Client-Go</a>
</span><span><a href=/tags/cni/>Cni</a>
</span><span><a href=/tags/containerd/>Containerd</a>
</span><span><a href=/tags/containerd-shim/>Containerd-Shim</a>
</span><span><a href=/tags/cri/>Cri</a>
</span><span><a href=/tags/csi/>Csi</a>
</span><span><a href=/tags/docker/>Docker</a>
</span><span><a href=/tags/etcd/>Etcd</a>
</span><span><a href=/tags/gin/>Gin</a>
</span><span><a href=/tags/go/>Go</a>
</span><span><a href=/tags/golang/>Golang</a>
</span><span><a href=/tags/grpc/>Grpc</a>
</span><span><a href=/tags/iptables/>Iptables</a>
</span><span><a href=/tags/ipvs/>Ipvs</a>
</span><span><a href=/tags/istio/>Istio</a>
</span><span><a href=/tags/kratos/>Kratos</a>
</span><span><a href=/tags/kube-proxy/>Kube-Proxy</a>
</span><span><a href=/tags/kubelet/>Kubelet</a>
</span><span><a href=/tags/kubernetes/>Kubernetes</a>
</span><span><a href=/tags/linux/>Linux</a>
</span><span><a href=/tags/lua/>Lua</a>
</span><span><a href=/tags/makefile/>Makefile</a>
</span><span><a href=/tags/mysql/>Mysql</a>
</span><span><a href=/tags/namespace/>Namespace</a>
</span><span><a href=/tags/network/>Network</a>
</span><span><a href=/tags/nginx/>Nginx</a>
</span><span><a href=/tags/opentelemetry/>Opentelemetry</a>
</span><span><a href=/tags/prometheus/>Prometheus</a>
</span><span><a href=/tags/protobuf/>Protobuf</a>
</span><span><a href=/tags/rabbitmq/>RabbitMQ</a>
</span><span><a href=/tags/redis/>Redis</a>
</span><span><a href=/tags/runc/>Runc</a>
</span><span><a href=/tags/service-mesh/>Service Mesh</a>
</span><span><a href=/tags/sidecar/>Sidecar</a>
</span><span><a href=/tags/sqlx/>Sqlx</a>
</span><span><a href=/tags/thrift/>Thrift</a>
</span><span><a href=/tags/unionfs/>UnionFS</a>
</span><span><a href=/tags/viper/>Viper</a>
</span><span><a href=/tags/vscode/>Vscode</a>
</span><span><a href=/tags/wire/>Wire</a>
</span><span><a href=/tags/zap/>Zap</a>
</span><span><a href=/tags/%E4%BA%8B%E5%8A%A1/>事务</a>
</span><span><a href=/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/>数据库</a>
</span><span><a href=/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/>源码分析</a>
</span><span><a href=/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>设计模式</a></span></div></div><div class="sidebar-item sidebar-toc"><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#channel介绍>channel介绍</a></li><li><a href=#hchan>hchan</a></li><li><a href=#make-chan>make chan</a></li><li><a href=#发送和接受数据>发送和接受数据</a><ul><li><a href=#向channel写入数据>向channel写入数据</a></li><li><a href=#从channel读取操作>从channel读取操作</a></li></ul></li><li><a href=#recvq和sendq-结构>recvq和sendq 结构</a></li><li><a href=#goroutine-pauseresume>Goroutine Pause/Resume</a></li><li><a href=#wait-empty-channel>wait empty channel</a></li><li><a href=#select>select</a></li><li><a href=#range>range</a></li><li><a href=#死锁deadlock>死锁（deadlock）</a></li><li><a href=#参考文章>参考文章</a></li></ul></nav></div></aside></div><div class=btn><div class=btn-menu id=btn-menu><i class="iconfont icon-grid-sharp"></i></div><div class=btn-toggle-mode><i class="iconfont icon-contrast-sharp"></i></div><div class=btn-scroll-top><i class="iconfont icon-chevron-up-circle-sharp"></i></div></div><aside class=sidebar-mobile style=display:none><div class=sidebar-wrapper><div class="sidebar-item sidebar-pages"><h3>Pages</h3><ul><li><a href=/>Home</a></li><li><a href=/archives/>Archives</a></li><li><a href=/index.xml>RSS</a></li><li><a href=/about/>About</a></li><li><a href=/search/>Search</a></li></ul></div><div class="sidebar-item sidebar-links"><h3>Links</h3><ul><li><a href=https://github.com/daemon365 target=_blank><span>My GitHub</span></a></li></ul></div><div class="sidebar-item sidebar-tags"><h3>Tags</h3><div><span><a href=/tags/bbr/>BBR</a>
</span><span><a href=/tags/boltdb/>Boltdb</a>
</span><span><a href=/tags/breaker/>Breaker</a>
</span><span><a href=/tags/cdi/>Cdi</a>
</span><span><a href=/tags/cgroup/>Cgroup</a>
</span><span><a href=/tags/client-go/>Client-Go</a>
</span><span><a href=/tags/cni/>Cni</a>
</span><span><a href=/tags/containerd/>Containerd</a>
</span><span><a href=/tags/containerd-shim/>Containerd-Shim</a>
</span><span><a href=/tags/cri/>Cri</a>
</span><span><a href=/tags/csi/>Csi</a>
</span><span><a href=/tags/docker/>Docker</a>
</span><span><a href=/tags/etcd/>Etcd</a>
</span><span><a href=/tags/gin/>Gin</a>
</span><span><a href=/tags/go/>Go</a>
</span><span><a href=/tags/golang/>Golang</a>
</span><span><a href=/tags/grpc/>Grpc</a>
</span><span><a href=/tags/iptables/>Iptables</a>
</span><span><a href=/tags/ipvs/>Ipvs</a>
</span><span><a href=/tags/istio/>Istio</a>
</span><span><a href=/tags/kratos/>Kratos</a>
</span><span><a href=/tags/kube-proxy/>Kube-Proxy</a>
</span><span><a href=/tags/kubelet/>Kubelet</a>
</span><span><a href=/tags/kubernetes/>Kubernetes</a>
</span><span><a href=/tags/linux/>Linux</a>
</span><span><a href=/tags/lua/>Lua</a>
</span><span><a href=/tags/makefile/>Makefile</a>
</span><span><a href=/tags/mysql/>Mysql</a>
</span><span><a href=/tags/namespace/>Namespace</a>
</span><span><a href=/tags/network/>Network</a>
</span><span><a href=/tags/nginx/>Nginx</a>
</span><span><a href=/tags/opentelemetry/>Opentelemetry</a>
</span><span><a href=/tags/prometheus/>Prometheus</a>
</span><span><a href=/tags/protobuf/>Protobuf</a>
</span><span><a href=/tags/rabbitmq/>RabbitMQ</a>
</span><span><a href=/tags/redis/>Redis</a>
</span><span><a href=/tags/runc/>Runc</a>
</span><span><a href=/tags/service-mesh/>Service Mesh</a>
</span><span><a href=/tags/sidecar/>Sidecar</a>
</span><span><a href=/tags/sqlx/>Sqlx</a>
</span><span><a href=/tags/thrift/>Thrift</a>
</span><span><a href=/tags/unionfs/>UnionFS</a>
</span><span><a href=/tags/viper/>Viper</a>
</span><span><a href=/tags/vscode/>Vscode</a>
</span><span><a href=/tags/wire/>Wire</a>
</span><span><a href=/tags/zap/>Zap</a>
</span><span><a href=/tags/%E4%BA%8B%E5%8A%A1/>事务</a>
</span><span><a href=/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/>数据库</a>
</span><span><a href=/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/>源码分析</a>
</span><span><a href=/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>设计模式</a></span></div></div><div class="sidebar-item sidebar-toc"><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#channel介绍>channel介绍</a></li><li><a href=#hchan>hchan</a></li><li><a href=#make-chan>make chan</a></li><li><a href=#发送和接受数据>发送和接受数据</a><ul><li><a href=#向channel写入数据>向channel写入数据</a></li><li><a href=#从channel读取操作>从channel读取操作</a></li></ul></li><li><a href=#recvq和sendq-结构>recvq和sendq 结构</a></li><li><a href=#goroutine-pauseresume>Goroutine Pause/Resume</a></li><li><a href=#wait-empty-channel>wait empty channel</a></li><li><a href=#select>select</a></li><li><a href=#range>range</a></li><li><a href=#死锁deadlock>死锁（deadlock）</a></li><li><a href=#参考文章>参考文章</a></li></ul></nav></div></div></aside></main><footer><div class="container-lg clearfix"><div class="col-12 footer"><span>&copy; 2019-2024
<a href=https://daemon365.dev/>daemon365</a>
| Powered by <a href=https://github.com/dsrkafuu/hugo-theme-fuji/ target=_blank>Fuji-v2</a> & <a href=https://gohugo.io/ target=_blank>Hugo</a></span></div></div></footer><script defer src=https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js integrity="sha512-q583ppKrCRc7N5O0n2nzUiJ+suUv7Et1JGels4bXOaMFQcamPk9HjdUknZuuFjBNs7tsMuadge5k9RzdmO+1GQ==" crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1.27.0/components/prism-core.min.js integrity="sha512-LCKPTo0gtJ74zCNMbWw04ltmujpzSR4oW+fgN+Y1YclhM5ZrHCZQAJE4quEodcI/G122sRhSGU2BsSRUZ2Gu3w==" crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1.27.0/plugins/autoloader/prism-autoloader.min.js integrity="sha512-GP4x8UWxWyh4BMbyJGOGneiTbkrWEF5izsVJByzVLodP8CuJH/n936+yQDMJJrOPUHLgyPbLiGw2rXmdvGdXHA==" crossorigin=anonymous></script><script defer src=/assets/js/fuji.min.645f1123be695831f419ab54c1bcba327325895c740014006e57070d4f3e5d6b553e929c4b46f40ea707249e9c7f7c2a446d32a39ce7319f80a34525586a8e0f.js integrity="sha512-ZF8RI75pWDH0GatUwby6MnMliVx0ABQAblcHDU8+XWtVPpKcS0b0DqcHJJ6cf3wqRG0yo5znMZ+Ao0UlWGqODw=="></script></body></html>