<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=HandheldFriendly content="True"><meta http-equiv=X-UA-Compatible content="IE=edge"><meta http-equiv=Cache-Control content="no-transform"><meta http-equiv=Cache-Control content="no-siteapp"><meta name=generator content="Hugo 0.128.1"><link rel="shortcut icon" href=/imgs/icons/favicon.ico><title>kratos 日志库的使用姿势 - Daemon</title>
<meta name=author content="daemon365"><meta name=description content="Don't let yourself stop."><meta name=keywords content="go,kratos"><meta property="og:title" content="kratos 日志库的使用姿势"><meta name=twitter:title content="kratos 日志库的使用姿势"><meta property="og:type" content="article"><meta property="og:url" content="https://daemon365.dev/2021/08/19/kratos-%E6%97%A5%E5%BF%97%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/"><meta property="og:description" content="什么是日志 所谓日志（Log）是指系统所指定对象的某些操作和其操作结果按时间有序的集合。log文件就是日志文件，log文件记录了系统和系统的用户之间交互的信息，是自动捕获人与系统终端之间交互的类型、内容"><meta name=twitter:description content="什么是日志 所谓日志（Log）是指系统所指定对象的某些操作和其操作结果按时间有序的集合。log文件就是日志文件，log文件记录了系统和系统的用户之间交互的信息，是自动捕获人与系统终端之间交互的类型、内容"><meta property="og:image" content="https://daemon365.dev/imgs/icons/favicon.ico"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://daemon365.dev/imgs/icons/favicon.ico"><meta property="article:published_time" content="2021-08-19T18:11:50+08:00"><meta property="article:modified_time" content="2021-08-19T18:11:50+08:00"><style>@media(prefers-color-scheme:dark){body[data-theme=auto] img{filter:brightness(60%)}}body[data-theme=dark] img{filter:brightness(60%)}</style><link rel=stylesheet href=https://daemon365.dev/assets/css/fuji.min.4e0456c767a797dadceacfba968921e887d900af9fd8d0953bebc1524ea1dec6c6a4a5ec0c0b77280884a642028ce374f31206dd96c6d7d143d5ee3c372f2c31.css integrity="sha512-TgRWx2enl9rc6s+6lokh6IfZAK+f2NCVO+vBUk6h3sbGpKXsDAt3KAiEpkICjON08xIG3ZbG19FD1e48Ny8sMQ=="></head><body data-theme=light data-theme-auto=false><script data-cfasync=false>var fujiThemeData=localStorage.getItem("fuji_data-theme");fujiThemeData?fujiThemeData!=="auto"&&document.body.setAttribute("data-theme",fujiThemeData==="dark"?"dark":"light"):localStorage.setItem("fuji_data-theme","auto")</script><header><div class="container-lg clearfix"><div class="col-12 header"><a class=title-main href=https://daemon365.dev/>Daemon</a>
<span class=title-sub>Don't let yourself stop.</span></div></div></header><main><div class="container-lg clearfix"><div class="col-12 col-md-9 float-left content"><article><h2 class="post-item post-title"><a href=https://daemon365.dev/2021/08/19/kratos-%E6%97%A5%E5%BF%97%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/>kratos 日志库的使用姿势</a></h2><div class="post-item post-meta"><span><i class="iconfont icon-today-sharp"></i>&nbsp;2021-08-19</span>
<span><i class="iconfont icon-file-tray-sharp"></i>&nbsp;2512 words</span>
<span><i class="iconfont icon-pricetags-sharp"></i>&nbsp;<a href=/tags/go>go</a>&nbsp;<a href=/tags/kratos>kratos</a>&nbsp;</span></div><div class="post-content markdown-body"><h2 id=什么是日志>什么是日志</h2><blockquote><p>所谓日志（Log）是指系统所指定对象的某些操作和其操作结果按时间有序的集合。log文件就是日志文件，log文件记录了系统和系统的用户之间交互的信息，是自动捕获人与系统终端之间交互的类型、内容或时间的数据收集方法。</p></blockquote><p>日志是用来记录，用户操作，系统状态，错误信息等等内容的文件，是一个软件系统的重要组成部分。一个良好的日志规范，对于系统运行状态的分析，以及线上问题的解决具有重大的意义。</p><h3 id=日志规范>日志规范</h3><p>在开发软件打印日志时，需要注意一些问题，举例可能不全，可以自行百度相关文章或查看文章底部文献：</p><ul><li>重要功能日志尽可能的完善。</li><li>不要随意打印无用的日志，过多无用的日志会增加分析日志的难度。</li><li>日志要区分等级 如 debug，warn，info，error 等。</li><li>捕获到未处理错误时最好打印错误堆栈信息</li></ul><h3 id=go-语言常用的日志库>Go 语言常用的日志库</h3><p>Go 语言标准库中就为我们提供了一个日志库 <strong>log</strong>，除了这个以外还有很多日志库，如 <strong>logrus</strong>，<strong>glog</strong>，<strong>logx</strong>，<strong>Uber</strong> 的 <strong>zap</strong> 等等，例如 <strong>zap</strong> 就有很多的优点：</p><ul><li>高性能</li><li>配置项丰富</li><li>多种日志级别</li><li>支持Hook</li><li>丰富的工具包</li><li>提供了sugar log</li><li>多种日志打印格式</li><li>&mldr;</li></ul><h5 id=简单使用>简单使用</h5><pre><code class=language-golang>package main

import (
	&quot;errors&quot;
	&quot;go.uber.org/zap&quot;
)

var logger *zap.Logger

func init() {
	logger, _ = zap.NewProduction()
}
func main() {
	logger.Error(
		&quot;My name is baobao&quot;,
		zap.String(&quot;from&quot;, &quot;Hulun Buir&quot;),
		zap.Error(errors.New(&quot;no good&quot;)))

	logger.Info(&quot;Worked in the Ministry of national development of China!&quot;,
		zap.String(&quot;key&quot;, &quot;eat🍚&quot;),
		zap.String(&quot;key&quot;, &quot;sleep😴&quot;))
	defer logger.Sync()
}
</code></pre><h2 id=kratos-日志库原理解析>Kratos 日志库原理解析</h2><blockquote><p>在私下与 <strong>Tony老师</strong> 沟通时关于日志库的实现理念时，<strong>Tony老师</strong> 说：由于目前日志库非常多并且好用，在 <strong>Kratos</strong> 的日志中，主要考虑以下几个问题：</p><ol><li>统一日志接口设计</li><li>组织结构化日志</li><li>并且需要有友好的日志级别使用</li><li>支持多输出源对接需求，如log-agent 或者 3rd 日志库</li></ol></blockquote><p><strong>kratos</strong> 的日志库，不强制具体实现方式，只提供适配器，用户可以自行实现日志功能，只需要实现<strong>kratos/log</strong> 的 <strong>Logger interface</strong> 即可接入自己喜欢的日志系统。</p><p><strong>kratos</strong> 的日志库，在设计阶段，参考了很多优秀的开源项目和大厂的日志系统实现，经历了多次改动后才呈现给大家。</p><h3 id=log库的组成>log库的组成</h3><p><strong>kratos</strong> 的 <strong>log</strong> 库主要由以下几个文件组成</p><ul><li><strong>level.go</strong> 定义日志级别</li><li><strong>log.go</strong> 日志核心</li><li><strong>helper.go</strong> <strong>log</strong>的<strong>helper</strong></li><li><strong>value.go</strong> 实现动态值</li></ul><h3 id=源码分析>源码分析</h3><p><strong>kratos</strong> 的 <strong>log</strong> 库中, 核心部分就是 <strong>log.go</strong> 代码非常简洁，符合 <strong>kratos</strong> 的设计理念。 <strong>log.go</strong> 中声明了 <strong>Logger interface</strong>，用户只需要实现接口，即可引入自己的日志实现，主要代码如下：</p><h4 id=loggo><strong>log.go</strong></h4><pre><code class=language-golang>package log

import (
	&quot;context&quot;
	&quot;log&quot;
)

var (
	// DefaultLogger is default logger.
	DefaultLogger Logger = NewStdLogger(log.Writer())
)

// Logger 接口, 后面实现自定义日志库的时候，就是要实现这个接口。
type Logger interface {
	Log(level Level, keyvals ...interface{}) error
}

type logger struct {
	logs      []Logger // logger 数组
	prefix    []interface{} // 一些默认打印的值,例如通过 With 绑定的 Valuer
	hasValuer bool // 是否包含 Valuer 
	ctx       context.Context // 上下文
}

func (c *logger) Log(level Level, keyvals ...interface{}) error {
	kvs := make([]interface{}, 0, len(c.prefix)+len(keyvals))
	kvs = append(kvs, c.prefix...)
        // 判断是否存在 valuer
	if c.hasValuer {
                // 绑定 valuer
		bindValues(c.ctx, kvs)
	}
	kvs = append(kvs, keyvals...)
        // 遍历 logs，调用所有的 logger 进行日志打印。
	for _, l := range c.logs {
		if err := l.Log(level, kvs...); err != nil {
			return err
		}
	}
	return nil
}

// With with logger fields.
func With(l Logger, kv ...interface{}) Logger {
	// 判断是否能 把传入的 logger 断言成 *logger
	if c, ok := l.(*logger); ok {
		// 预分配内存,make了一个空间长度为 c.prefix + keyvals长度的 interface数组
		kvs := make([]interface{}, 0, len(c.prefix)+len(kv))
		// 处理打印的内容
		kvs = append(kvs, kv...)
		kvs = append(kvs, c.prefix...)
		// containsValuer()用来判断 kvs 里面是否存在 valuer
		return &amp;logger{
			logs:      c.logs,
			prefix:    kvs,
			hasValuer: containsValuer(kvs),
			ctx:       c.ctx,
		}
	}
	return &amp;logger{logs: []Logger{l}, prefix: kv, hasValuer: containsValuer(kv)}
}

// WithContext 绑定 ctx,注意 ctx 必须非空
func WithContext(ctx context.Context, l Logger) Logger {
	if c, ok := l.(*logger); ok {
		return &amp;logger{
			logs:      c.logs,
			prefix:    c.prefix,
			hasValuer: c.hasValuer,
			ctx:       ctx,
		}
	}
	return &amp;logger{logs: []Logger{l}, ctx: ctx}
}

// MultiLogger 包装多个logger，简单说就是同时使用多个logger打印
func MultiLogger(logs ...Logger) Logger {
	return &amp;logger{logs: logs}
}

</code></pre><h4 id=valuego>value.go</h4><pre><code class=language-golang>// 返回 valuer 函数.
func Value(ctx context.Context, v interface{}) interface{} {
	if v, ok := v.(Valuer); ok {
		return v(ctx)
	}
	return v
}

// ...省略一些内置的 valuer 实现

// 绑定 valuer
func bindValues(ctx context.Context, keyvals []interface{}) {
	for i := 1; i &lt; len(keyvals); i += 2 {
		if v, ok := keyvals[i].(Valuer); ok {
			keyvals[i] = v(ctx)
		}
	}
}

// 是否包含 valuer
func containsValuer(keyvals []interface{}) bool {
	for i := 1; i &lt; len(keyvals); i += 2 {
		if _, ok := keyvals[i].(Valuer); ok {
			return true
		}
	}
	return false
}
</code></pre><h4 id=helpergo>helper.go</h4><pre><code class=language-golang>package log

import (
	&quot;context&quot;
	&quot;fmt&quot;
)

// Helper is a logger helper.
type Helper struct {
	logger Logger
}

// 创建一个 logger helper 实例
func NewHelper(logger Logger) *Helper {
	return &amp;Helper{
		logger: logger,
	}
}

// 通过 WithContext() 返回包含 ctx 的一个日志的帮助类，包含一些定义好的按级别打印日志的方法
func (h *Helper) WithContext(ctx context.Context) *Helper {
	return &amp;Helper{
		logger: WithContext(ctx, h.logger),
	}
}

func (h *Helper) Log(level Level, keyvals ...interface{}) {
	h.logger.Log(level, keyvals...)
}

func (h *Helper) Debug(a ...interface{}) {
	h.logger.Log(LevelDebug, &quot;msg&quot;, fmt.Sprint(a...))
}

func (h *Helper) Debugf(format string, a ...interface{}) {
	h.logger.Log(LevelDebug, &quot;msg&quot;, fmt.Sprintf(format, a...))
}

// ...省略一些重复的方法

</code></pre><h4 id=通过单元测试了解调用逻辑>通过单元测试了解调用逻辑</h4><pre><code class=language-golang>func TestInfo(t *testing.T) {
	logger := DefaultLogger
	logger = With(logger, &quot;ts&quot;, DefaultTimestamp, &quot;caller&quot;, DefaultCaller)
	logger.Log(LevelInfo, &quot;key1&quot;, &quot;value1&quot;)
}
</code></pre><ol><li>单测中首先声明了一个 <strong>logger</strong> ，用的默认的 <strong>DefaultLogger</strong></li><li>调用 <strong>log.go</strong> 中的 <strong>With()</strong> 函数， 传入了 <strong>logger</strong> ,和两个动态值， <strong>DefaultTimestamp</strong> 和 <strong>DefaultCaller</strong>。</li><li>With方法被调用，判断是否能将参数 <strong>l</strong> 类型转换成 <strong>*logger</strong></li><li>如果可以转换，将传入的KV，赋值给 <strong>logger.prefix</strong> 上，然后调用 <strong>value.go</strong> 中的 <strong>containsValuer()</strong> 判断传入的KV中是否存在 Valuer类型的值，将结果赋值给 <strong>context.hasValuer</strong>，最后返回 <strong>Logger</strong> 对象</li><li>否则则直接返回一个 <strong>&amp;logger{logs: []Logger{l}, prefix: kv, hasValuer: containsValuer(kv)}</strong></li><li>然后打印日志时，<strong>logger struct</strong> 的 <strong>Log</strong> 方法被调用</li><li><strong>Log()</strong> 方法首先预分配了 <strong>keyvals</strong> 的空间，然后判断 <strong>hasValuer</strong>，如果为 <strong>true</strong>，则调用 <strong>valuer.go</strong> 中的 <strong>bindValuer()</strong> 并传入了 <strong>ctx</strong> 然后获取 <strong>valuer</strong> 的值<code>if v, ok := v.(Valuer); ok { return v() }</code></li></ol><p>8.最后遍历 <strong>logger.logs</strong> 打印日志</p><h2 id=使用方法>使用方法</h2><h3 id=使用-logger-打印日志>使用 Logger 打印日志</h3><pre><code class=language-go>logger := log.DefaultLogger
logger.Log(LevelInfo, &quot;key1&quot;, &quot;value1&quot;)
</code></pre><h3 id=使用-helper-打印日志>使用 Helper 打印日志</h3><pre><code class=language-go>log := log.NewHelper(DefaultLogger)
log.Debug(&quot;test debug&quot;)
log.Info(&quot;test info&quot;)
log.Warn(&quot;test warn&quot;)
log.Error(&quot;test error&quot;)
</code></pre><h3 id=使用-valuer>使用 valuer</h3><pre><code class=language-go>logger := DefaultLogger
logger = With(logger, &quot;ts&quot;, DefaultTimestamp, &quot;caller&quot;, DefaultCaller)
logger.Log(LevelInfo, &quot;msg&quot;, &quot;helloworld&quot;)
</code></pre><h3 id=同时打印多个-logger>同时打印多个 logger</h3><pre><code class=language-go>out := log.NewStdLogger(os.Stdout)
err := log.NewStdLogger(os.Stderr)
l := log.With(MultiLogger(out, err))
l.Log(LevelInfo, &quot;msg&quot;, &quot;test&quot;)
</code></pre><h3 id=使用-context>使用 context</h3><pre><code class=language-go>logger := log.With(NewStdLogger(os.Stdout),
	&quot;trace&quot;, Trace(),
)
log := log.NewHelper(logger)
ctx := context.WithValue(context.Background(), &quot;trace_id&quot;, &quot;2233&quot;)
log.WithContext(ctx).Info(&quot;got trace!&quot;)
</code></pre><h3 id=使用-filter-过滤日志>使用 filter 过滤日志</h3><p>如果需要过滤日志中某些不应该被打印明文的字段如 password 等，可以通过 log.NewFilter() 来实现过滤功能。</p><h4 id=通过-level-过滤日志>通过 level 过滤日志</h4><pre><code class=language-go>l := log.NewHelper(log.NewFilter(log.DefaultLogger, log.FilterLevel(log.LevelWarn)))
l.Log(LevelDebug, &quot;msg1&quot;, &quot;te1st debug&quot;)
l.Debug(&quot;test debug&quot;)
l.Debugf(&quot;test %s&quot;, &quot;debug&quot;)
l.Debugw(&quot;log&quot;, &quot;test debug&quot;)
l.Warn(&quot;warn log&quot;)
</code></pre><h4 id=通过-key-过滤日志>通过 key 过滤日志</h4><pre><code class=language-go>l := log.NewHelper(log.NewFilter(log.DefaultLogger, log.FilterKey(&quot;password&quot;)))
l.Debugw(&quot;password&quot;, &quot;123456&quot;)
</code></pre><h5 id=通过-value-过滤日志>通过 value 过滤日志</h5><pre><code class=language-go>l := log.NewHelper(log.NewFilter(log.DefaultLogger, log.FilterValue(&quot;kratos&quot;)))
l.Debugw(&quot;name&quot;, &quot;kratos&quot;)
</code></pre><h4 id=通过-hook-func-过滤日志>通过 hook func 过滤日志</h4><pre><code class=language-go>l := log.NewHelper(log.NewFilter(log.DefaultLogger, log.FilterFunc(testFilterFunc)))
l.Debug(&quot;debug level&quot;)
l.Infow(&quot;password&quot;, &quot;123456&quot;)
func testFilterFunc(level Level, keyvals ...interface{}) bool {
	if level == LevelWarn {
		return true
	}
	for i := 0; i &lt; len(keyvals); i++ {
		if keyvals[i] == &quot;password&quot; {
			keyvals[i+1] = &quot;***&quot;
		}
	}
	return false
}
</code></pre><h2 id=用-zap-实现-kratos-的日志接口>用 Zap 实现 kratos 的日志接口</h2><p>实现的代码十分简单，仅有不到100 行代码，仅供大家参考。</p><h3 id=实现>实现</h3><pre><code class=language-golang>// kratos/examples/log/zap.go
package logger

import (
	&quot;fmt&quot;
        &quot;os&quot;
        
	&quot;github.com/go-kratos/kratos/v2/log&quot;
	&quot;go.uber.org/zap&quot;
	&quot;go.uber.org/zap/zapcore&quot;
	&quot;gopkg.in/natefinch/lumberjack.v2&quot;
)

var _ log.Logger = (*ZapLogger)(nil)

// Zap 结构体
type ZapLogger struct {
	log  *zap.Logger
	Sync func() error
}

// 创建一个 ZapLogger 实例
func NewZapLogger(encoder zapcore.EncoderConfig, level zap.AtomicLevel, opts ...zap.Option) *ZapLogger {
	writeSyncer := getLogWriter()
	// 设置 zapcore
	core := zapcore.NewCore(
		zapcore.NewConsoleEncoder(encoder),
		zapcore.NewMultiWriteSyncer(
			zapcore.AddSync(os.Stdout),
		), level)
	//  new 一个 *zap.Logger
	zapLogger := zap.New(core, opts...)
	return &amp;ZapLogger{log: zapLogger, Sync: zapLogger.Sync}
}

// Log 方法实现了 kratos/log/log.go 中的 Logger interface
func (l *ZapLogger) Log(level log.Level, keyvals ...interface{}) error {
	if len(keyvals) == 0 || len(keyvals)%2 != 0{
        	l.log.Warn(fmt.Sprint(&quot;Keyvalues must appear in pairs: &quot;, keyvals))
		return nil
	}
	// 按照 KV 传入的时候,使用的 zap.Field
	var data []zap.Field
	for i := 0; i &lt; len(keyvals); i += 2 {
		data = append(data, zap.Any(fmt.Sprint(keyvals[i]), fmt.Sprint(keyvals[i+1])))
	}
	switch level {
	case log.LevelDebug:
		l.log.Debug(&quot;&quot;, data...)
	case log.LevelInfo:
		l.log.Info(&quot;&quot;, data...)
	case log.LevelWarn:
		l.log.Warn(&quot;&quot;, data...)
	case log.LevelError:
		l.log.Error(&quot;&quot;, data...)
	}
	return nil
}

// 日志自动切割，采用 lumberjack 实现的
func getLogWriter() zapcore.WriteSyncer {
	lumberJackLogger := &amp;lumberjack.Logger{
		Filename:   &quot;./test.log&quot;,
		MaxSize:    10,
		MaxBackups: 5,
		MaxAge:     30,
		Compress:   false,
	}
	return zapcore.AddSync(lumberJackLogger)
}

</code></pre><h3 id=使用方法-1>使用方法</h3><pre><code class=language-golang>// kratos/examples/log/zap_test.go
package logger

import (
	&quot;testing&quot;

	&quot;github.com/go-kratos/kratos/v2/log&quot;
	&quot;go.uber.org/zap&quot;
	&quot;go.uber.org/zap/zapcore&quot;
)

func TestZapLogger(t *testing.T) {
	encoder := zapcore.EncoderConfig{
		TimeKey:        &quot;t&quot;,
		LevelKey:       &quot;level&quot;,
		NameKey:        &quot;logger&quot;,
		CallerKey:      &quot;caller&quot;,
		MessageKey:     &quot;msg&quot;,
		StacktraceKey:  &quot;stack&quot;,
		EncodeTime:     zapcore.ISO8601TimeEncoder,
		LineEnding:     zapcore.DefaultLineEnding,
		EncodeLevel:    zapcore.LowercaseLevelEncoder,
		EncodeDuration: zapcore.SecondsDurationEncoder,
		EncodeCaller:   zapcore.FullCallerEncoder,
	}
	logger := NewZapLogger(
		encoder,
		zap.NewAtomicLevelAt(zapcore.DebugLevel),
		zap.AddStacktrace(
			zap.NewAtomicLevelAt(zapcore.ErrorLevel)),
		zap.AddCallerSkip(2),
		zap.Development(),
	)
	zlog := log.NewHelper(logger)
	zlog.Infow(&quot;name&quot;,&quot;go 语言进阶&quot;)
	defer logger.Sync()
}
</code></pre><h2 id=参考文献>参考文献</h2><ul><li>关于 log 库的讨论 <a href=https://github.com/go-kratos/kratos/issues/882 target=_blank>issue</a></li><li>Uber 的日志库 Zap <a href=https://github.com/uber-go/zap target=_blank>uber/zap</a></li><li>日志割接库 <a href=https://github.com/natefinch/lumberjack target=_blank>lumberjack</a></li><li>基于 zap 的日志demo <a href=https://github.com/go-kratos/kratos/tree/main/examples/log target=_blank>log example</a></li></ul><p><img class=img-zoomable src=/images/df29de7c-11e2-4f40-94b1-699617bbc438.png alt></p></div></article><div class="license markdown-body"><blockquote><p>Unless otherwise noted, the content of this site is licensed under <a rel=license href=http://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank>CC BY-NC-SA 4.0</a>.</p></blockquote></div><div class=post-comment data-comment=utterances><span class=post-comment-notloaded><i class="iconfont icon-chatbox-ellipses-sharp"></i>&nbsp;Load comments
</span><script>function loadComment(){var e,n=document.querySelector(".post-comment"),t=document.body.getAttribute("data-theme");t==="auto"?t=window.matchMedia("(prefers-color-scheme: dark)").matches?"photon-dark":"github-light":t=t==="dark"?"photon-dark":"github-light",e=document.createElement("script"),e.src="https://utteranc.es/client.js",e.setAttribute("repo","daemon365/daemon365.github.io"),e.setAttribute("issue-term","pathname"),e.setAttribute("theme",t),e.setAttribute("crossorigin","anonymous"),e.setAttribute("async",""),document.querySelector(".post-comment").appendChild(e),document.querySelector("span.post-comment-notloaded").setAttribute("style","display: none;")}</script></div></div><aside class="col-12 col-md-3 float-left sidebar"><div class="sidebar-item sidebar-pages"><h3>Pages</h3><ul><li><a href=/>Home</a></li><li><a href=/archives/>Archives</a></li><li><a href=/index.xml>RSS</a></li><li><a href=/about/>About</a></li><li><a href=/search/>Search</a></li></ul></div><div class="sidebar-item sidebar-links"><h3>Links</h3><ul><li><a href=https://github.com/daemon365 target=_blank><span>My GitHub</span></a></li></ul></div><div class="sidebar-item sidebar-tags"><h3>Tags</h3><div><span><a href=/tags/bbr/>BBR</a>
</span><span><a href=/tags/boltdb/>Boltdb</a>
</span><span><a href=/tags/breaker/>Breaker</a>
</span><span><a href=/tags/cdi/>Cdi</a>
</span><span><a href=/tags/cgroup/>Cgroup</a>
</span><span><a href=/tags/client-go/>Client-Go</a>
</span><span><a href=/tags/cni/>Cni</a>
</span><span><a href=/tags/containerd/>Containerd</a>
</span><span><a href=/tags/containerd-shim/>Containerd-Shim</a>
</span><span><a href=/tags/cri/>Cri</a>
</span><span><a href=/tags/csi/>Csi</a>
</span><span><a href=/tags/docker/>Docker</a>
</span><span><a href=/tags/etcd/>Etcd</a>
</span><span><a href=/tags/gin/>Gin</a>
</span><span><a href=/tags/go/>Go</a>
</span><span><a href=/tags/golang/>Golang</a>
</span><span><a href=/tags/grpc/>Grpc</a>
</span><span><a href=/tags/iptables/>Iptables</a>
</span><span><a href=/tags/ipvs/>Ipvs</a>
</span><span><a href=/tags/istio/>Istio</a>
</span><span><a href=/tags/kratos/>Kratos</a>
</span><span><a href=/tags/kube-proxy/>Kube-Proxy</a>
</span><span><a href=/tags/kubelet/>Kubelet</a>
</span><span><a href=/tags/kubernetes/>Kubernetes</a>
</span><span><a href=/tags/linux/>Linux</a>
</span><span><a href=/tags/lua/>Lua</a>
</span><span><a href=/tags/makefile/>Makefile</a>
</span><span><a href=/tags/mysql/>Mysql</a>
</span><span><a href=/tags/namespace/>Namespace</a>
</span><span><a href=/tags/network/>Network</a>
</span><span><a href=/tags/nginx/>Nginx</a>
</span><span><a href=/tags/opentelemetry/>Opentelemetry</a>
</span><span><a href=/tags/prometheus/>Prometheus</a>
</span><span><a href=/tags/protobuf/>Protobuf</a>
</span><span><a href=/tags/rabbitmq/>RabbitMQ</a>
</span><span><a href=/tags/redis/>Redis</a>
</span><span><a href=/tags/runc/>Runc</a>
</span><span><a href=/tags/service-mesh/>Service Mesh</a>
</span><span><a href=/tags/sidecar/>Sidecar</a>
</span><span><a href=/tags/sqlx/>Sqlx</a>
</span><span><a href=/tags/thrift/>Thrift</a>
</span><span><a href=/tags/unionfs/>UnionFS</a>
</span><span><a href=/tags/viper/>Viper</a>
</span><span><a href=/tags/vscode/>Vscode</a>
</span><span><a href=/tags/wire/>Wire</a>
</span><span><a href=/tags/zap/>Zap</a>
</span><span><a href=/tags/%E4%BA%8B%E5%8A%A1/>事务</a>
</span><span><a href=/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/>数据库</a>
</span><span><a href=/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/>源码分析</a>
</span><span><a href=/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>设计模式</a></span></div></div><div class="sidebar-item sidebar-toc"><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#什么是日志>什么是日志</a><ul><li><a href=#日志规范>日志规范</a></li><li><a href=#go-语言常用的日志库>Go 语言常用的日志库</a></li></ul></li><li><a href=#kratos-日志库原理解析>Kratos 日志库原理解析</a><ul><li><a href=#log库的组成>log库的组成</a></li><li><a href=#源码分析>源码分析</a></li></ul></li><li><a href=#使用方法>使用方法</a><ul><li><a href=#使用-logger-打印日志>使用 Logger 打印日志</a></li><li><a href=#使用-helper-打印日志>使用 Helper 打印日志</a></li><li><a href=#使用-valuer>使用 valuer</a></li><li><a href=#同时打印多个-logger>同时打印多个 logger</a></li><li><a href=#使用-context>使用 context</a></li><li><a href=#使用-filter-过滤日志>使用 filter 过滤日志</a></li></ul></li><li><a href=#用-zap-实现-kratos-的日志接口>用 Zap 实现 kratos 的日志接口</a><ul><li><a href=#实现>实现</a></li><li><a href=#使用方法-1>使用方法</a></li></ul></li><li><a href=#参考文献>参考文献</a></li></ul></nav></div></aside></div><div class=btn><div class=btn-menu id=btn-menu><i class="iconfont icon-grid-sharp"></i></div><div class=btn-toggle-mode><i class="iconfont icon-contrast-sharp"></i></div><div class=btn-scroll-top><i class="iconfont icon-chevron-up-circle-sharp"></i></div></div><aside class=sidebar-mobile style=display:none><div class=sidebar-wrapper><div class="sidebar-item sidebar-pages"><h3>Pages</h3><ul><li><a href=/>Home</a></li><li><a href=/archives/>Archives</a></li><li><a href=/index.xml>RSS</a></li><li><a href=/about/>About</a></li><li><a href=/search/>Search</a></li></ul></div><div class="sidebar-item sidebar-links"><h3>Links</h3><ul><li><a href=https://github.com/daemon365 target=_blank><span>My GitHub</span></a></li></ul></div><div class="sidebar-item sidebar-tags"><h3>Tags</h3><div><span><a href=/tags/bbr/>BBR</a>
</span><span><a href=/tags/boltdb/>Boltdb</a>
</span><span><a href=/tags/breaker/>Breaker</a>
</span><span><a href=/tags/cdi/>Cdi</a>
</span><span><a href=/tags/cgroup/>Cgroup</a>
</span><span><a href=/tags/client-go/>Client-Go</a>
</span><span><a href=/tags/cni/>Cni</a>
</span><span><a href=/tags/containerd/>Containerd</a>
</span><span><a href=/tags/containerd-shim/>Containerd-Shim</a>
</span><span><a href=/tags/cri/>Cri</a>
</span><span><a href=/tags/csi/>Csi</a>
</span><span><a href=/tags/docker/>Docker</a>
</span><span><a href=/tags/etcd/>Etcd</a>
</span><span><a href=/tags/gin/>Gin</a>
</span><span><a href=/tags/go/>Go</a>
</span><span><a href=/tags/golang/>Golang</a>
</span><span><a href=/tags/grpc/>Grpc</a>
</span><span><a href=/tags/iptables/>Iptables</a>
</span><span><a href=/tags/ipvs/>Ipvs</a>
</span><span><a href=/tags/istio/>Istio</a>
</span><span><a href=/tags/kratos/>Kratos</a>
</span><span><a href=/tags/kube-proxy/>Kube-Proxy</a>
</span><span><a href=/tags/kubelet/>Kubelet</a>
</span><span><a href=/tags/kubernetes/>Kubernetes</a>
</span><span><a href=/tags/linux/>Linux</a>
</span><span><a href=/tags/lua/>Lua</a>
</span><span><a href=/tags/makefile/>Makefile</a>
</span><span><a href=/tags/mysql/>Mysql</a>
</span><span><a href=/tags/namespace/>Namespace</a>
</span><span><a href=/tags/network/>Network</a>
</span><span><a href=/tags/nginx/>Nginx</a>
</span><span><a href=/tags/opentelemetry/>Opentelemetry</a>
</span><span><a href=/tags/prometheus/>Prometheus</a>
</span><span><a href=/tags/protobuf/>Protobuf</a>
</span><span><a href=/tags/rabbitmq/>RabbitMQ</a>
</span><span><a href=/tags/redis/>Redis</a>
</span><span><a href=/tags/runc/>Runc</a>
</span><span><a href=/tags/service-mesh/>Service Mesh</a>
</span><span><a href=/tags/sidecar/>Sidecar</a>
</span><span><a href=/tags/sqlx/>Sqlx</a>
</span><span><a href=/tags/thrift/>Thrift</a>
</span><span><a href=/tags/unionfs/>UnionFS</a>
</span><span><a href=/tags/viper/>Viper</a>
</span><span><a href=/tags/vscode/>Vscode</a>
</span><span><a href=/tags/wire/>Wire</a>
</span><span><a href=/tags/zap/>Zap</a>
</span><span><a href=/tags/%E4%BA%8B%E5%8A%A1/>事务</a>
</span><span><a href=/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/>数据库</a>
</span><span><a href=/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/>源码分析</a>
</span><span><a href=/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>设计模式</a></span></div></div><div class="sidebar-item sidebar-toc"><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#什么是日志>什么是日志</a><ul><li><a href=#日志规范>日志规范</a></li><li><a href=#go-语言常用的日志库>Go 语言常用的日志库</a></li></ul></li><li><a href=#kratos-日志库原理解析>Kratos 日志库原理解析</a><ul><li><a href=#log库的组成>log库的组成</a></li><li><a href=#源码分析>源码分析</a></li></ul></li><li><a href=#使用方法>使用方法</a><ul><li><a href=#使用-logger-打印日志>使用 Logger 打印日志</a></li><li><a href=#使用-helper-打印日志>使用 Helper 打印日志</a></li><li><a href=#使用-valuer>使用 valuer</a></li><li><a href=#同时打印多个-logger>同时打印多个 logger</a></li><li><a href=#使用-context>使用 context</a></li><li><a href=#使用-filter-过滤日志>使用 filter 过滤日志</a></li></ul></li><li><a href=#用-zap-实现-kratos-的日志接口>用 Zap 实现 kratos 的日志接口</a><ul><li><a href=#实现>实现</a></li><li><a href=#使用方法-1>使用方法</a></li></ul></li><li><a href=#参考文献>参考文献</a></li></ul></nav></div></div></aside></main><footer><div class="container-lg clearfix"><div class="col-12 footer"><span>&copy; 2019-2024
<a href=https://daemon365.dev/>daemon365</a>
| Powered by <a href=https://github.com/dsrkafuu/hugo-theme-fuji/ target=_blank>Fuji-v2</a> & <a href=https://gohugo.io/ target=_blank>Hugo</a></span></div></div></footer><script defer src=https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js integrity="sha512-q583ppKrCRc7N5O0n2nzUiJ+suUv7Et1JGels4bXOaMFQcamPk9HjdUknZuuFjBNs7tsMuadge5k9RzdmO+1GQ==" crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1.27.0/components/prism-core.min.js integrity="sha512-LCKPTo0gtJ74zCNMbWw04ltmujpzSR4oW+fgN+Y1YclhM5ZrHCZQAJE4quEodcI/G122sRhSGU2BsSRUZ2Gu3w==" crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1.27.0/plugins/autoloader/prism-autoloader.min.js integrity="sha512-GP4x8UWxWyh4BMbyJGOGneiTbkrWEF5izsVJByzVLodP8CuJH/n936+yQDMJJrOPUHLgyPbLiGw2rXmdvGdXHA==" crossorigin=anonymous></script><script defer src=/assets/js/fuji.min.645f1123be695831f419ab54c1bcba327325895c740014006e57070d4f3e5d6b553e929c4b46f40ea707249e9c7f7c2a446d32a39ce7319f80a34525586a8e0f.js integrity="sha512-ZF8RI75pWDH0GatUwby6MnMliVx0ABQAblcHDU8+XWtVPpKcS0b0DqcHJJ6cf3wqRG0yo5znMZ+Ao0UlWGqODw=="></script></body></html>