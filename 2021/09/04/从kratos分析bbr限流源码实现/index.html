<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=HandheldFriendly content="True"><meta http-equiv=X-UA-Compatible content="IE=edge"><meta http-equiv=Cache-Control content="no-transform"><meta http-equiv=Cache-Control content="no-siteapp"><meta name=generator content="Hugo 0.128.1"><link rel="shortcut icon" href=/imgs/icons/favicon.ico><title>从kratos分析BBR限流源码实现 - Daemon</title>
<meta name=author content="daemon365"><meta name=description content="Don't let yourself stop."><meta name=keywords content="go,kratos,BBR,源码分析"><meta property="og:title" content="从kratos分析BBR限流源码实现"><meta name=twitter:title content="从kratos分析BBR限流源码实现"><meta property="og:type" content="article"><meta property="og:url" content="https://daemon365.dev/2021/09/04/%E4%BB%8Ekratos%E5%88%86%E6%9E%90bbr%E9%99%90%E6%B5%81%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0/"><meta property="og:description" content="什么是自适应限流 自适应限流从整体维度对应用入口流量进行控制，结合应用的 Load、CPU 使用率、总体平均 RT、入口 QPS 和并发线程数等几个维度的监控指标，通过自适应的流控策略，让系统的入口流量和系统的负载达"><meta name=twitter:description content="什么是自适应限流 自适应限流从整体维度对应用入口流量进行控制，结合应用的 Load、CPU 使用率、总体平均 RT、入口 QPS 和并发线程数等几个维度的监控指标，通过自适应的流控策略，让系统的入口流量和系统的负载达"><meta property="og:image" content="https://daemon365.dev/imgs/icons/favicon.ico"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://daemon365.dev/imgs/icons/favicon.ico"><meta property="article:published_time" content="2021-09-04T00:00:00+08:00"><meta property="article:modified_time" content="2021-09-04T00:00:00+08:00"><style>@media(prefers-color-scheme:dark){body[data-theme=auto] img{filter:brightness(60%)}}body[data-theme=dark] img{filter:brightness(60%)}</style><link rel=stylesheet href=https://daemon365.dev/assets/css/fuji.min.4e0456c767a797dadceacfba968921e887d900af9fd8d0953bebc1524ea1dec6c6a4a5ec0c0b77280884a642028ce374f31206dd96c6d7d143d5ee3c372f2c31.css integrity="sha512-TgRWx2enl9rc6s+6lokh6IfZAK+f2NCVO+vBUk6h3sbGpKXsDAt3KAiEpkICjON08xIG3ZbG19FD1e48Ny8sMQ=="></head><body data-theme=light data-theme-auto=false><script data-cfasync=false>var fujiThemeData=localStorage.getItem("fuji_data-theme");fujiThemeData?fujiThemeData!=="auto"&&document.body.setAttribute("data-theme",fujiThemeData==="dark"?"dark":"light"):localStorage.setItem("fuji_data-theme","auto")</script><header><div class="container-lg clearfix"><div class="col-12 header"><a class=title-main href=https://daemon365.dev/>Daemon</a>
<span class=title-sub>Don't let yourself stop.</span></div></div></header><main><div class="container-lg clearfix"><div class="col-12 col-md-9 float-left content"><article><h2 class="post-item post-title"><a href=https://daemon365.dev/2021/09/04/%E4%BB%8Ekratos%E5%88%86%E6%9E%90bbr%E9%99%90%E6%B5%81%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0/>从kratos分析BBR限流源码实现</a></h2><div class="post-item post-meta"><span><i class="iconfont icon-today-sharp"></i>&nbsp;2021-09-04</span>
<span><i class="iconfont icon-file-tray-sharp"></i>&nbsp;1775 words</span>
<span><i class="iconfont icon-pricetags-sharp"></i>&nbsp;<a href=/tags/go>go</a>&nbsp;<a href=/tags/kratos>kratos</a>&nbsp;<a href=/tags/bbr>BBR</a>&nbsp;<a href=/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90>源码分析</a>&nbsp;</span></div><div class="post-content markdown-body"><h2 id=什么是自适应限流>什么是自适应限流</h2><p>自适应限流从整体维度对应用入口流量进行控制，结合应用的 Load、CPU 使用率、总体平均 RT、入口 QPS 和并发线程数等几个维度的监控指标，通过自适应的流控策略，让系统的入口流量和系统的负载达到一个平衡，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性。</p><p><strong>核心目标：</strong></p><ul><li>自动嗅探负载和 qps，减少人工配置</li><li>削顶，保证超载时系统不被拖垮，并能以高水位 qps 继续运行</li></ul><h2 id=限流规则>限流规则</h2><p><img class=img-zoomable src=/images/fdc8a49d-6a85-4ad6-b266-994260aa8350.png alt></p><p><strong>计算吞吐量：利特尔法则 <code>L = λ * W</code></strong></p><p>如上图所示，如果我们开一个小店，平均每分钟进店 2 个客人(λ)，每位客人从等待到完成交易需要 4 分钟(W)，那我们店里能承载的客人数量就是 2 * 4 = 8 个人</p><p>同理，我们可以将 <code>λ</code> 当做 QPS， <code>W</code> 呢是每个请求需要花费的时间，那我们的系统的吞吐就是 <code>L = λ * W</code> ，所以我们可以使用利特尔法则来计算系统的吞吐量。</p><h3 id=指标介绍>指标介绍</h3><table><thead><tr><th>指标名称</th><th>指标含义</th></tr></thead><tbody><tr><td>cpu</td><td>最近 1s 的 CPU 使用率均值，使用滑动平均计算，采样周期是 250ms</td></tr><tr><td>inflight</td><td>当前处理中正在处理的请求数量</td></tr><tr><td>pass</td><td>请求处理成功的量</td></tr><tr><td>rt</td><td>请求成功的响应耗时</td></tr></tbody></table><h3 id=滑动窗口>滑动窗口</h3><p>在自适应限流保护中，采集到的指标的时效性非常强，系统只需要采集最近一小段时间内的 qps、rt 即可，对于较老的数据，会自动丢弃。为了实现这个效果，kratos 使用了滑动窗口来保存采样数据。</p><p><img class=img-zoomable src=/images/d3cc3465-12f9-4400-bc50-8a7af654570c.png alt></p><p>如上图，展示了一个具有两个桶（bucket）的滑动窗口（rolling window）。整个滑动窗口用来保存最近 1s 的采样数据，每个小的桶用来保存 500ms 的采样数据。 当时间流动之后，过期的桶会自动被新桶的数据覆盖掉，在图中，在 1000-1500ms 时，bucket 1 的数据因为过期而被丢弃，之后 bucket 3 的数据填到了窗口的头部。</p><h3 id=限流公式>限流公式</h3><p>判断是否丢弃当前请求的算法如下：</p><pre><code class=language-go>cpu &gt; 800 AND (Now - PrevDrop) &lt; 1s AND (MaxPass * MinRt * windows / 1000) &lt; InFlight
</code></pre><p>MaxPass 表示最近 5s 内，单个采样窗口中最大的请求数。 MinRt 表示最近 5s 内，单个采样窗口中最小的响应时间。 windows 表示一秒内采样窗口的数量，默认配置中是 5s 50 个采样，那么 windows 的值为 10。</p><h2 id=源码分析>源码分析</h2><h2 id=代码地址>代码地址：</h2><ul><li><a href=https://github.com/go-kratos/aegis/tree/main/ratelimit/bbr target=_blank>https://github.com/go-kratos/aegis/tree/main/ratelimit/bbr</a></li></ul><h3 id=bbr-struct>BBR struct</h3><pre><code class=language-go>type BBR struct {
	cpu             cpuGetter
	passStat        window.RollingCounter
	rtStat          window.RollingCounter
	inFlight        int64
	bucketPerSecond int64
	bucketSize      time.Duration

	// prevDropTime defines previous start drop since initTime
	prevDropTime atomic.Value
	maxPASSCache atomic.Value
	minRtCache   atomic.Value

	opts *options
}
</code></pre><ol><li><code>cpu</code><ul><li>cpu的指标函数，CPU的使用率， 这里为了减小误差，把数字扩大化，乘以1000，比赛使用率60%，也就是0.6 cpu的值就为600</li></ul></li><li><code>passStat</code><ul><li>请求数的采样数据，使用滑动窗口进行统计</li></ul></li><li><code>rtStat</code><ul><li>响应时间的采样数据，同样使用滑动窗口进行统计</li></ul></li><li><code>inFlight</code><ul><li>当前系统中的请求数，数据得来方法是：中间件原理在处理前+1，处理handle之后不管成功失败都减去1</li></ul></li><li><code>bucketPerSecond</code><ul><li>一个 bucket 的时间</li></ul></li><li><code>bucketSize</code><ul><li>桶的数量</li></ul></li><li><code>prevDropTime</code><ul><li>上次触发限流时间</li></ul></li><li><code>maxPASSCache</code><ul><li>单个采样窗口中最大的请求数的缓存数据</li></ul></li><li><code>minRtCache</code><ul><li>单个采样窗口中最小的响应时间的缓存数据</li></ul></li></ol><h2 id=allow接口>Allow接口</h2><pre><code class=language-go>// Allow checks all inbound traffic.
// Once overload is detected, it raises limit.ErrLimitExceed error.
func (l *BBR) Allow(ctx context.Context) (func(), error) {
	if l.shouldDrop() { // shouldDrop 判断是否需要限流，如果true表示拒绝 之后重点讲
		return nil, ErrLimitExceed
	}
	atomic.AddInt64(&amp;l.inFlight, 1) // 之前说的，正在处理数+1
	stime := time.Since(initTime) // 现在时间减去程序初始化时间 表示程序开始执行时刻
	return func() { // allow返回函数 在中间件（拦截器）中handle执行完成后调用
		rt := int64((time.Since(initTime) - stime) / time.Millisecond)  // 执行完handle的时间减去stime 表示 程序执行的总时间 单位ms
		l.rtStat.Add(rt) // 把处理时间放进采样数据window
		atomic.AddInt64(&amp;l.inFlight, -1) // 正在处理数-1 便是处理完成
		l.passStat.Add(1) // 成功了，把通过数的采样数据window加1
	}, nil
}
</code></pre><h3 id=shoulddrop方法>shouldDrop方法</h3><pre><code class=language-go>func (l *BBR) shouldDrop() bool {
	curTime := time.Since(initTime)
	if l.cpu() &lt; l.opts.CPUThreshold {
		// current cpu payload below the threshold
		prevDropTime, _ := l.prevDropTime.Load().(time.Duration)
		if prevDropTime == 0 {
			// haven't start drop,
			// accept current request
			return false
		}
		if curTime-prevDropTime &lt;= time.Second {
			// just start drop one second ago,
			// check current inflight count
			inFlight := atomic.LoadInt64(&amp;l.inFlight)
			return inFlight &gt; 1 &amp;&amp; inFlight &gt; l.maxInFlight()
		}
		l.prevDropTime.Store(time.Duration(0))
		return false
	}

	// current cpu payload exceeds the threshold
	inFlight := atomic.LoadInt64(&amp;l.inFlight)
	drop := inFlight &gt; 1 &amp;&amp; inFlight &gt; l.maxInFlight()
	if drop {
		prevDrop, _ := l.prevDropTime.Load().(time.Duration)
		if prevDrop != 0 {
			// already started drop, return directly
			return drop
		}
		// store start drop time
		l.prevDropTime.Store(curTime)
	}
	return drop
}

</code></pre><p><strong>maxInFlight()方法代表过去的负载</strong></p><pre><code class=language-go>int64(math.Floor(float64(l.maxPASS()*l.minRT()*l.bucketPerSecond)/1000.0) + 0.5)
</code></pre><p>参考算法：https://github.com/alibaba/Sentinel/wiki/%E7%B3%BB%E7%BB%9F%E8%87%AA%E9%80%82%E5%BA%94%E9%99%90%E6%B5%81</p><ul><li>maxPass * bucketPerSecond / 1000 为每毫秒处理的请求数</li><li>l.minRT() 为 单个采样窗口中最小的响应时间</li><li>T ≈ QPS * Avg(RT)</li><li><code>+ 0.5</code>为向上取整</li></ul><h3 id=流程图>流程图</h3><p><img class=img-zoomable src=/images/c13f3623-a858-4322-9695-f1db1a4f85a5.png alt></p><h2 id=压测报告>压测报告</h2><p>场景1，请求以每秒增加1个的速度不停上升，压测效果如下：</p><p><img class=img-zoomable src=/images/fcae1ea8-da01-470a-823d-ab394851b01a.png alt></p><p>左测是没有限流的压测效果，右侧是带限流的压测效果。 可以看到，没有限流的场景里，系统在 700qps 时开始抖动，在 1k qps 时被拖垮，几乎没有新的请求能被放行，然而在使用限流之后，系统请求能够稳定在 600 qps 左右，rt 没有暴增，服务也没有被打垮，可见，限流有效的保护了服务。</p><h2 id=原文地址>原文地址：</h2><ul><li><a href=https://zhaohaiyu.com/posts/microservice/overload/ target=_blank>https://zhaohaiyu.com/posts/microservice/overload/</a></li></ul><p>参考文章：</p><ul><li><a href=https://v1.go-kratos.dev/#/ratelimit target=_blank>https://v1.go-kratos.dev/#/ratelimit</a></li><li><a href=https://github.com/alibaba/Sentinel/wiki/%E7%B3%BB%E7%BB%9F%E8%87%AA%E9%80%82%E5%BA%94%E9%99%90%E6%B5%81 target=_blank>https://github.com/alibaba/Sentinel/wiki/%E7%B3%BB%E7%BB%9F%E8%87%AA%E9%80%82%E5%BA%94%E9%99%90%E6%B5%81</a></li></ul><hr><p><img class=img-zoomable src=/images/f3c8339b-cae8-4cde-9f92-dd68eba61462.png alt></p><p><img class=img-zoomable src=/images/cec35d8f-b7d4-4c38-adb3-1fe46b6c7a1b.gif alt></p></div></article><div class="license markdown-body"><blockquote><p>Unless otherwise noted, the content of this site is licensed under <a rel=license href=http://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank>CC BY-NC-SA 4.0</a>.</p></blockquote></div></div><aside class="col-12 col-md-3 float-left sidebar"><div class="sidebar-item sidebar-pages"><h3>Pages</h3><ul><li><a href=/>Home</a></li><li><a href=/archives/>Archives</a></li><li><a href=/index.xml>RSS</a></li><li><a href=/about/>About</a></li><li><a href=/search/>Search</a></li></ul></div><div class="sidebar-item sidebar-links"><h3>Links</h3><ul><li><a href=https://github.com/daemon365 target=_blank><span>My GitHub</span></a></li></ul></div><div class="sidebar-item sidebar-tags"><h3>Tags</h3><div><span><a href=/tags/bbr/>BBR</a>
</span><span><a href=/tags/boltdb/>Boltdb</a>
</span><span><a href=/tags/breaker/>Breaker</a>
</span><span><a href=/tags/cdi/>Cdi</a>
</span><span><a href=/tags/cgroup/>Cgroup</a>
</span><span><a href=/tags/client-go/>Client-Go</a>
</span><span><a href=/tags/cni/>Cni</a>
</span><span><a href=/tags/containerd/>Containerd</a>
</span><span><a href=/tags/containerd-shim/>Containerd-Shim</a>
</span><span><a href=/tags/cri/>Cri</a>
</span><span><a href=/tags/csi/>Csi</a>
</span><span><a href=/tags/docker/>Docker</a>
</span><span><a href=/tags/etcd/>Etcd</a>
</span><span><a href=/tags/gin/>Gin</a>
</span><span><a href=/tags/go/>Go</a>
</span><span><a href=/tags/golang/>Golang</a>
</span><span><a href=/tags/grpc/>Grpc</a>
</span><span><a href=/tags/iptables/>Iptables</a>
</span><span><a href=/tags/ipvs/>Ipvs</a>
</span><span><a href=/tags/istio/>Istio</a>
</span><span><a href=/tags/kratos/>Kratos</a>
</span><span><a href=/tags/kube-proxy/>Kube-Proxy</a>
</span><span><a href=/tags/kubelet/>Kubelet</a>
</span><span><a href=/tags/kubernetes/>Kubernetes</a>
</span><span><a href=/tags/linux/>Linux</a>
</span><span><a href=/tags/lua/>Lua</a>
</span><span><a href=/tags/makefile/>Makefile</a>
</span><span><a href=/tags/mysql/>Mysql</a>
</span><span><a href=/tags/namespace/>Namespace</a>
</span><span><a href=/tags/network/>Network</a>
</span><span><a href=/tags/nginx/>Nginx</a>
</span><span><a href=/tags/opentelemetry/>Opentelemetry</a>
</span><span><a href=/tags/prometheus/>Prometheus</a>
</span><span><a href=/tags/protobuf/>Protobuf</a>
</span><span><a href=/tags/rabbitmq/>RabbitMQ</a>
</span><span><a href=/tags/redis/>Redis</a>
</span><span><a href=/tags/runc/>Runc</a>
</span><span><a href=/tags/service-mesh/>Service Mesh</a>
</span><span><a href=/tags/sidecar/>Sidecar</a>
</span><span><a href=/tags/sqlx/>Sqlx</a>
</span><span><a href=/tags/thrift/>Thrift</a>
</span><span><a href=/tags/unionfs/>UnionFS</a>
</span><span><a href=/tags/viper/>Viper</a>
</span><span><a href=/tags/vscode/>Vscode</a>
</span><span><a href=/tags/wire/>Wire</a>
</span><span><a href=/tags/zap/>Zap</a>
</span><span><a href=/tags/%E4%BA%8B%E5%8A%A1/>事务</a>
</span><span><a href=/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/>数据库</a>
</span><span><a href=/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/>源码分析</a>
</span><span><a href=/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>设计模式</a></span></div></div><div class="sidebar-item sidebar-toc"><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#什么是自适应限流>什么是自适应限流</a></li><li><a href=#限流规则>限流规则</a><ul><li><a href=#指标介绍>指标介绍</a></li><li><a href=#滑动窗口>滑动窗口</a></li><li><a href=#限流公式>限流公式</a></li></ul></li><li><a href=#源码分析>源码分析</a></li><li><a href=#代码地址>代码地址：</a><ul><li><a href=#bbr-struct>BBR struct</a></li></ul></li><li><a href=#allow接口>Allow接口</a><ul><li><a href=#shoulddrop方法>shouldDrop方法</a></li><li><a href=#流程图>流程图</a></li></ul></li><li><a href=#压测报告>压测报告</a></li><li><a href=#原文地址>原文地址：</a></li></ul></nav></div></aside></div><div class=btn><div class=btn-menu id=btn-menu><i class="iconfont icon-grid-sharp"></i></div><div class=btn-toggle-mode><i class="iconfont icon-contrast-sharp"></i></div><div class=btn-scroll-top><i class="iconfont icon-chevron-up-circle-sharp"></i></div></div><aside class=sidebar-mobile style=display:none><div class=sidebar-wrapper><div class="sidebar-item sidebar-pages"><h3>Pages</h3><ul><li><a href=/>Home</a></li><li><a href=/archives/>Archives</a></li><li><a href=/index.xml>RSS</a></li><li><a href=/about/>About</a></li><li><a href=/search/>Search</a></li></ul></div><div class="sidebar-item sidebar-links"><h3>Links</h3><ul><li><a href=https://github.com/daemon365 target=_blank><span>My GitHub</span></a></li></ul></div><div class="sidebar-item sidebar-tags"><h3>Tags</h3><div><span><a href=/tags/bbr/>BBR</a>
</span><span><a href=/tags/boltdb/>Boltdb</a>
</span><span><a href=/tags/breaker/>Breaker</a>
</span><span><a href=/tags/cdi/>Cdi</a>
</span><span><a href=/tags/cgroup/>Cgroup</a>
</span><span><a href=/tags/client-go/>Client-Go</a>
</span><span><a href=/tags/cni/>Cni</a>
</span><span><a href=/tags/containerd/>Containerd</a>
</span><span><a href=/tags/containerd-shim/>Containerd-Shim</a>
</span><span><a href=/tags/cri/>Cri</a>
</span><span><a href=/tags/csi/>Csi</a>
</span><span><a href=/tags/docker/>Docker</a>
</span><span><a href=/tags/etcd/>Etcd</a>
</span><span><a href=/tags/gin/>Gin</a>
</span><span><a href=/tags/go/>Go</a>
</span><span><a href=/tags/golang/>Golang</a>
</span><span><a href=/tags/grpc/>Grpc</a>
</span><span><a href=/tags/iptables/>Iptables</a>
</span><span><a href=/tags/ipvs/>Ipvs</a>
</span><span><a href=/tags/istio/>Istio</a>
</span><span><a href=/tags/kratos/>Kratos</a>
</span><span><a href=/tags/kube-proxy/>Kube-Proxy</a>
</span><span><a href=/tags/kubelet/>Kubelet</a>
</span><span><a href=/tags/kubernetes/>Kubernetes</a>
</span><span><a href=/tags/linux/>Linux</a>
</span><span><a href=/tags/lua/>Lua</a>
</span><span><a href=/tags/makefile/>Makefile</a>
</span><span><a href=/tags/mysql/>Mysql</a>
</span><span><a href=/tags/namespace/>Namespace</a>
</span><span><a href=/tags/network/>Network</a>
</span><span><a href=/tags/nginx/>Nginx</a>
</span><span><a href=/tags/opentelemetry/>Opentelemetry</a>
</span><span><a href=/tags/prometheus/>Prometheus</a>
</span><span><a href=/tags/protobuf/>Protobuf</a>
</span><span><a href=/tags/rabbitmq/>RabbitMQ</a>
</span><span><a href=/tags/redis/>Redis</a>
</span><span><a href=/tags/runc/>Runc</a>
</span><span><a href=/tags/service-mesh/>Service Mesh</a>
</span><span><a href=/tags/sidecar/>Sidecar</a>
</span><span><a href=/tags/sqlx/>Sqlx</a>
</span><span><a href=/tags/thrift/>Thrift</a>
</span><span><a href=/tags/unionfs/>UnionFS</a>
</span><span><a href=/tags/viper/>Viper</a>
</span><span><a href=/tags/vscode/>Vscode</a>
</span><span><a href=/tags/wire/>Wire</a>
</span><span><a href=/tags/zap/>Zap</a>
</span><span><a href=/tags/%E4%BA%8B%E5%8A%A1/>事务</a>
</span><span><a href=/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/>数据库</a>
</span><span><a href=/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/>源码分析</a>
</span><span><a href=/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>设计模式</a></span></div></div><div class="sidebar-item sidebar-toc"><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#什么是自适应限流>什么是自适应限流</a></li><li><a href=#限流规则>限流规则</a><ul><li><a href=#指标介绍>指标介绍</a></li><li><a href=#滑动窗口>滑动窗口</a></li><li><a href=#限流公式>限流公式</a></li></ul></li><li><a href=#源码分析>源码分析</a></li><li><a href=#代码地址>代码地址：</a><ul><li><a href=#bbr-struct>BBR struct</a></li></ul></li><li><a href=#allow接口>Allow接口</a><ul><li><a href=#shoulddrop方法>shouldDrop方法</a></li><li><a href=#流程图>流程图</a></li></ul></li><li><a href=#压测报告>压测报告</a></li><li><a href=#原文地址>原文地址：</a></li></ul></nav></div></div></aside></main><footer><div class="container-lg clearfix"><div class="col-12 footer"><span>&copy; 2019-2024
<a href=https://daemon365.dev/>daemon365</a>
| Powered by <a href=https://github.com/dsrkafuu/hugo-theme-fuji/ target=_blank>Fuji-v2</a> & <a href=https://gohugo.io/ target=_blank>Hugo</a></span></div></div></footer><script defer src=https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js integrity="sha512-q583ppKrCRc7N5O0n2nzUiJ+suUv7Et1JGels4bXOaMFQcamPk9HjdUknZuuFjBNs7tsMuadge5k9RzdmO+1GQ==" crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1.27.0/components/prism-core.min.js integrity="sha512-LCKPTo0gtJ74zCNMbWw04ltmujpzSR4oW+fgN+Y1YclhM5ZrHCZQAJE4quEodcI/G122sRhSGU2BsSRUZ2Gu3w==" crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1.27.0/plugins/autoloader/prism-autoloader.min.js integrity="sha512-GP4x8UWxWyh4BMbyJGOGneiTbkrWEF5izsVJByzVLodP8CuJH/n936+yQDMJJrOPUHLgyPbLiGw2rXmdvGdXHA==" crossorigin=anonymous></script><script defer src=/assets/js/fuji.min.645f1123be695831f419ab54c1bcba327325895c740014006e57070d4f3e5d6b553e929c4b46f40ea707249e9c7f7c2a446d32a39ce7319f80a34525586a8e0f.js integrity="sha512-ZF8RI75pWDH0GatUwby6MnMliVx0ABQAblcHDU8+XWtVPpKcS0b0DqcHJJ6cf3wqRG0yo5znMZ+Ao0UlWGqODw=="></script></body></html>