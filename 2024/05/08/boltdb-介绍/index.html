<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=HandheldFriendly content="True"><meta http-equiv=X-UA-Compatible content="IE=edge"><meta http-equiv=Cache-Control content="no-transform"><meta http-equiv=Cache-Control content="no-siteapp"><meta name=generator content="Hugo 0.128.1"><link rel="shortcut icon" href=/imgs/icons/favicon.ico><title>boltdb 介绍 - Daemon</title>
<meta name=author content="daemon365"><meta name=description content="Don't let yourself stop."><meta name=keywords content="boltdb,etcd,golang,数据库,kubernetes"><meta property="og:title" content="boltdb 介绍"><meta name=twitter:title content="boltdb 介绍"><meta property="og:type" content="article"><meta property="og:url" content="https://daemon365.dev/2024/05/08/boltdb-%E4%BB%8B%E7%BB%8D/"><meta property="og:description" content="介绍 BoltDB 是一个用 Go 语言编写的嵌入式键/值数据库。以下是关于 BoltDB 的一些基本介绍： 键/值存储: BoltDB 为应用程序提供了简单的键/值存储接口。 事务: BoltDB 支持完整的 ACID 事务。 嵌入式: 与像 MySQL 或 PostgreSQL 这样的数据库系统不同，Bolt"><meta name=twitter:description content="介绍 BoltDB 是一个用 Go 语言编写的嵌入式键/值数据库。以下是关于 BoltDB 的一些基本介绍： 键/值存储: BoltDB 为应用程序提供了简单的键/值存储接口。 事务: BoltDB 支持完整的 ACID 事务。 嵌入式: 与像 MySQL 或 PostgreSQL 这样的数据库系统不同，Bolt"><meta property="og:image" content="https://daemon365.dev/imgs/icons/favicon.ico"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://daemon365.dev/imgs/icons/favicon.ico"><meta property="article:published_time" content="2024-05-08T20:56:00+08:00"><meta property="article:modified_time" content="2024-05-08T20:56:00+08:00"><style>@media(prefers-color-scheme:dark){body[data-theme=auto] img{filter:brightness(60%)}}body[data-theme=dark] img{filter:brightness(60%)}</style><link rel=stylesheet href=https://daemon365.dev/assets/css/fuji.min.4e0456c767a797dadceacfba968921e887d900af9fd8d0953bebc1524ea1dec6c6a4a5ec0c0b77280884a642028ce374f31206dd96c6d7d143d5ee3c372f2c31.css integrity="sha512-TgRWx2enl9rc6s+6lokh6IfZAK+f2NCVO+vBUk6h3sbGpKXsDAt3KAiEpkICjON08xIG3ZbG19FD1e48Ny8sMQ=="></head><body data-theme=light data-theme-auto=false><script data-cfasync=false>var fujiThemeData=localStorage.getItem("fuji_data-theme");fujiThemeData?fujiThemeData!=="auto"&&document.body.setAttribute("data-theme",fujiThemeData==="dark"?"dark":"light"):localStorage.setItem("fuji_data-theme","auto")</script><header><div class="container-lg clearfix"><div class="col-12 header"><a class=title-main href=https://daemon365.dev/>Daemon</a>
<span class=title-sub>Don't let yourself stop.</span></div></div></header><main><div class="container-lg clearfix"><div class="col-12 col-md-9 float-left content"><article><h2 class="post-item post-title"><a href=https://daemon365.dev/2024/05/08/boltdb-%E4%BB%8B%E7%BB%8D/>boltdb 介绍</a></h2><div class="post-item post-meta"><span><i class="iconfont icon-today-sharp"></i>&nbsp;2024-05-08</span>
<span><i class="iconfont icon-file-tray-sharp"></i>&nbsp;4592 words</span>
<span><i class="iconfont icon-pricetags-sharp"></i>&nbsp;<a href=/tags/boltdb>boltdb</a>&nbsp;<a href=/tags/etcd>etcd</a>&nbsp;<a href=/tags/golang>golang</a>&nbsp;<a href=/tags/%E6%95%B0%E6%8D%AE%E5%BA%93>数据库</a>&nbsp;<a href=/tags/kubernetes>kubernetes</a>&nbsp;</span></div><div class="post-content markdown-body"><h2 id=介绍>介绍</h2><p><code>BoltDB</code> 是一个用 Go 语言编写的嵌入式键/值数据库。以下是关于 BoltDB 的一些基本介绍：</p><ul><li><strong>键/值存储</strong>: BoltDB 为应用程序提供了简单的键/值存储接口。</li><li><strong>事务</strong>: BoltDB 支持完整的 ACID 事务。</li><li><strong>嵌入式</strong>: 与像 MySQL 或 PostgreSQL 这样的数据库系统不同，BoltDB 不运行在单独的服务器进程中。它作为一个库被直接嵌入到你的应用程序中。</li><li><strong>单文件存储</strong>: 所有的数据都存储在一个文件中，这使得备份和迁移变得简单。</li><li><strong>高效的二进制存储</strong>: 数据在磁盘上使用 B+ 树结构存储，这为随机读取提供了高性能。</li><li><strong>前缀扫描</strong>: 可以很容易地按键的前缀进行扫描，这使得它适用于范围查询。</li><li><strong>没有外部依赖</strong>: BoltDB 不依赖于任何外部系统或库。</li><li><strong>线程安全</strong>: BoltDB 是线程安全的，可以在多个 goroutines 中并发地使用。</li></ul><p>BoltDB 特别适用于需要一个轻量级、高性能、易于部署和维护的数据库解决方案的场景。</p><p>虽然 BoltDB 非常有用，但它也有其局限性。例如，它不支持分布式存储，也不适用于需要多节点复制或分片的场景。但对于许多应用程序，它提供了一个简单且高性能的存储解决方案。</p><p><strong>源码地址：</strong></p><p><a href=https://github.com/boltdb/bolt target=_blank>https://github.com/boltdb/bolt</a> 这个项目已经不维护了, <a href=https://etcd.io/ target=_blank>etcd</a> 官方维护了一个 fork 库，api 是互通的: <a href=https://github.com/etcd-io/bbolt target=_blank>https://github.com/etcd-io/bbolt</a></p><h2 id=谁在使用>谁在使用</h2><p><a href=https://github.com/etcd-io/etcd target=_blank>etcd</a>、<a href=https://github.com/pingcap/tidb target=_blank>tidb</a>、<a href=https://github.com/influxdata/influxdb target=_blank>influxdb</a>、<a href=https://github.com/hashicorp/consul target=_blank>consul</a> &mldr;&mldr;</p><h2 id=架构图>架构图</h2><p><img class=img-zoomable src=/images/6f10d17d-ca52-4fd0-a600-e92a9fc99d36.png alt=boltdb></p><h2 id=引入>引入</h2><pre><code class=language-bash>go get go.etcd.io/bbolt 
</code></pre><h2 id=使用>使用</h2><h3 id=open--a-database>open a database</h3><p>Bolt 中的顶级对象是 DB。它在你的硬盘上表示为一个单独的文件，并代表了你数据的一个一致性快照。</p><p>要打开你的数据库，只需使用 <code>bolt.Open()</code> 函数：</p><pre><code class=language-GO>package main

import (
	&quot;log&quot;

	bolt &quot;go.etcd.io/bbolt&quot;
)

func main() {
	db, err := bolt.Open(&quot;my.db&quot;, 0600, nil)
	if err != nil {
		log.Fatal(err)
	}
	defer db.Close()
}
</code></pre><p>请注意，Bolt 在数据文件上获得一个文件锁，因此多个进程不能同时打开同一个数据库。打开一个已经打开的 Bolt 数据库会导致它挂起，直到另一个进程关闭它。为了防止无限期的等待，你可以向 <code>Open()</code> 函数传递一个超时选项：</p><pre><code class=language-GO>db, err := bolt.Open(&quot;my.db&quot;, 0600, &amp;bolt.Options{Timeout: 1 * time.Second})
</code></pre><h3 id=transactions>Transactions</h3><p>Bolt一次只允许一个读写 transactions ，但允许您一次进行多个只读 transactions 。每一个 transactions 在开始时都能看到数据的一致视图。</p><p>单独的 transactions 和从它们创建的所有对象（例如桶、键）都不是线程安全的。要在多个goroutines中处理数据，您必须为每一个goroutine启动一个 transactions ，或使用锁来确保一次只有一个goroutine访问一个 transactions 。从数据库创建 transactions 是线程安全的。</p><p>transactions 不应相互依赖，并且通常不应在同一goroutine中同时打开。这可能会导致死锁，因为读写 transactions 需要定期重新映射数据文件，但在任何只读 transactions 打开时都不能这样做。即使是嵌套的只读 transactions 也可能导致死锁，因为子 transactions 可能阻止父 transactions 释放其资源。</p><h4 id=read-write-transactions>Read-write transactions</h4><p>要开始一个读写 transactions ，可以使用DB.Update()函数：</p><pre><code class=language-go>err := db.Update(func(tx *bolt.Tx) error {
	...
	return nil
})
</code></pre><p>在闭包中，您可以看到数据库的一致视图。通过在最后返回nil来提交 transactions 。您还可以通过返回错误在任何时候回滚 transactions 。所有的数据库操作都允许在一个读写 transactions 中进行。</p><p>始终检查返回错误，因为它会报告任何可能导致您的 transactions 未完成的磁盘故障。如果您在闭包内返回错误，它将被传递。</p><h4 id=read-only-transactions>Read-only transactions</h4><p>要开始一个只读 transactions ，您可以使用DB.View()函数：</p><pre><code class=language-go>err := db.View(func(tx *bolt.Tx) error {
	...
	return nil
})
</code></pre><p>在这个闭包内，您也可以看到数据库的一致视图，但在只读 transactions 中不允许进行变动操作。在一个只读 transactions 中，您只能检索桶、检索值和复制数据库。</p><h4 id=batch-read-write-transactions>Batch read-write transactions</h4><p>每个DB.Update()都会等待磁盘提交写入。这种开销可以通过使用DB.Batch()函数结合多个更新来最小化：</p><pre><code class=language-go>err := db.Batch(func(tx *bolt.Tx) error {
	...
	return nil
})
</code></pre><p>并发的Batch调用会被机会性地组合成更大的 transactions 。只有当有多个goroutines调用它时，Batch才是有用的。</p><p>权衡之处在于，Batch在 transactions 的部分失败时可以多次调用给定的函数。该函数必须是幂等的，且只有在成功从DB.Batch()返回后，副作用才会生效。</p><p>例如：不要从函数内部显示消息，而是在封闭范围内设置变量：</p><pre><code class=language-go>var id uint64
err := db.Batch(func(tx *bolt.Tx) error {
	// 在桶中查找最后一个键，解码为bigendian uint64，增加
	// 一个，编码回[]byte，并添加新键。
	...
	id = newValue
	return nil
})
if err != nil {
	return ...
}
fmt.Println(&quot;Allocated ID %d&quot;, id)
</code></pre><h4 id=managing-transactions-manually>Managing transactions manually</h4><p>DB.View()和DB.Update()函数是DB.Begin()函数的包装。这些助手函数将启动 transactions 、执行函数，然后在返回错误时安全地关闭您的 transactions 。这是使用Bolt transactions 的推荐方法。</p><p>然而，有时您可能希望手动开始和结束您的 transactions 。您可以直接使用DB.Begin()函数，但请确保关闭 transactions 。</p><pre><code class=language-go>// 开始一个可写的 transactions 。
tx, err := db.Begin(true)
if err != nil {
    return err
}
defer tx.Rollback()

// 使用 transactions ...
_, err := tx.CreateBucket([]byte(&quot;MyBucket&quot;))
if err != nil {
    return err
}

// 提交 transactions 并检查错误。
if err := tx.Commit(); err != nil {
    return err
}
</code></pre><p>DB.Begin()的第一个参数是一个布尔值，表示 transactions 是否应该是可写的。</p><h3 id=using-buckets>Using buckets</h3><p>桶是数据库中的键/值对集合。一个桶中的所有键都必须是唯一的。您可以使用Tx.CreateBucket()函数创建一个桶：</p><pre><code class=language-go>db.Update(func(tx *bolt.Tx) error {
	b, err := tx.CreateBucket([]byte(&quot;MyBucket&quot;))
	if err != nil {
		return fmt.Errorf(&quot;create bucket: %s&quot;, err)
	}
	return nil
})
</code></pre><p>您可以使用Tx.Bucket()函数检索现有的桶：</p><pre><code class=language-go>db.Update(func(tx *bolt.Tx) error {
	b := tx.Bucket([]byte(&quot;MyBucket&quot;))
	if b == nil {
		return fmt.Errorf(&quot;bucket does not exist&quot;)
	}
	return nil
})
</code></pre><p>您还可以使用Tx.CreateBucketIfNotExists()函数只在桶不存在时创建一个桶。打开数据库后，为所有的顶级桶调用此函数是一种常见的模式，这样您可以保证它们存在于未来的 transactions 中。</p><p>要删除一个桶，只需调用Tx.DeleteBucket()函数。</p><h3 id=using-keyvalue-pairs>Using key/value pairs</h3><p>要将键/值对保存到存储桶，使用<code>Bucket.Put()</code>函数：</p><pre><code class=language-go>db.Update(func(tx *bolt.Tx) error {
	b := tx.Bucket([]byte(&quot;MyBucket&quot;))
	err := b.Put([]byte(&quot;answer&quot;), []byte(&quot;42&quot;))
	return err
})
</code></pre><p>这会在<code>MyBucket</code>存储桶中将"answer"键的值设置为"42"。要检索此值，我们可以使用<code>Bucket.Get()</code>函数：</p><pre><code class=language-go>db.View(func(tx *bolt.Tx) error {
	b := tx.Bucket([]byte(&quot;MyBucket&quot;))
	v := b.Get([]byte(&quot;answer&quot;))
	fmt.Printf(&quot;The answer is: %s\n&quot;, v)
	return nil
})
</code></pre><p><code>Get()</code>函数不返回错误，因为其操作保证可以工作（除非有某种系统故障）。如果键存在，它将返回其字节切片值。如果不存在，则返回nil。重要的是要注意，您可以将零长度的值设置为一个键，这与键不存在是不同的。</p><p>使用<code>Bucket.Delete()</code>函数从存储桶中删除键：</p><pre><code class=language-go>db.Update(func (tx *bolt.Tx) error {
    b := tx.Bucket([]byte(&quot;MyBucket&quot;))
    err := b.Delete([]byte(&quot;answer&quot;))
    return err
})
</code></pre><p>这将从<code>MyBucket</code>存储桶中删除答案键。</p><p>请注意，从<code>Get()</code>返回的值只在事务打开时有效。如果您需要在事务外部使用值，则必须使用<code>copy()</code>将其复制到另一个字节切片。</p><h3 id=autoincrementing-integer-for-the-bucket>Autoincrementing integer for the bucket</h3><p>通过使用<code>NextSequence()</code>函数，您可以让Bolt确定一个序列，该序列可以用作键/值对的唯一标识符。请参阅下面的示例。</p><pre><code class=language-GO>// CreateUser saves u to the store. The new user ID is set on u once the data is persisted.
func (s *Store) CreateUser(u *User) error {
    return s.db.Update(func(tx *bolt.Tx) error {
        // Retrieve the users bucket.
        // This should be created when the DB is first opened.
        b := tx.Bucket([]byte(&quot;users&quot;))

        // Generate ID for the user.
        // This returns an error only if the Tx is closed or not writeable.
        // That can't happen in an Update() call so I ignore the error check.
        id, _ := b.NextSequence()
        u.ID = int(id)

        // Marshal user data into bytes.
        buf, err := json.Marshal(u)
        if err != nil {
            return err
        }

        // Persist bytes to users bucket.
        return b.Put(itob(u.ID), buf)
    })
}

// itob returns an 8-byte big endian representation of v.
func itob(v int) []byte {
    b := make([]byte, 8)
    binary.BigEndian.PutUint64(b, uint64(v))
    return b
}

type User struct {
    ID int
    ...
}
</code></pre><h3 id=iterating-over-keys>Iterating over keys</h3><p>Bolt在存储桶内按字节排序存储其键。这使得对这些键进行顺序迭代非常快。要迭代键，我们将使用一个Cursor：</p><pre><code class=language-go>db.View(func(tx *bolt.Tx) error {
	// Assume bucket exists and has keys
	b := tx.Bucket([]byte(&quot;MyBucket&quot;))

	c := b.Cursor()

	for k, v := c.First(); k != nil; k, v = c.Next() {
		fmt.Printf(&quot;key=%s, value=%s\n&quot;, k, v)
	}

	return nil
})
</code></pre><p>游标允许您移动到键列表中的特定点，并一次向前或向后移动一个键。</p><p>以下函数在游标上可用：</p><ul><li><code>First()</code> 移动到第一个键。</li><li><code>Last()</code> 移动到最后一个键。</li><li><code>Seek()</code> 移动到特定键。</li><li><code>Next()</code> 移动到下一个键。</li><li><code>Prev()</code> 移动到上一个键。 每个函数都有一个返回签名（key []byte, value []byte）。当您迭代到游标的末尾时，<code>Next()</code>将返回一个nil键。您必须使用<code>First()</code>、<code>Last()</code>或<code>Seek()</code>移动到某个位置，然后再调用<code>Next()</code>或<code>Prev()</code>。如果您没有移动到某个位置，那么这些函数将返回一个nil键。</li></ul><p>在迭代过程中，如果键不是nil，但值是nil，那么意味着键引用的是一个存储桶而不是一个值。使用<code>Bucket.Bucket()</code>来访问子存储桶。</p><h4 id=prefix-scans>Prefix scans</h4><p>要迭代键前缀，您可以结合使用<code>Seek()</code>和<code>bytes.HasPrefix()</code>：</p><pre><code class=language-go>db.View(func(tx *bolt.Tx) error {
	// Assume bucket exists and has keys
	c := tx.Bucket([]byte(&quot;MyBucket&quot;)).Cursor()

	prefix := []byte(&quot;1234&quot;)
	for k, v := c.Seek(prefix); k != nil &amp;&amp; bytes.HasPrefix(k, prefix); k, v = c.Next() {
		fmt.Printf(&quot;key=%s, value=%s\n&quot;, k, v)
	}

	return nil
})
</code></pre><h4 id=range-scans>Range scans</h4><p>另一个常见的用例是扫描范围，例如时间范围。如果您使用可排序的时间编码，例如RFC3339，那么您可以像这样查询特定的日期范围：</p><pre><code class=language-go>db.View(func(tx *bolt.Tx) error {
	// Assume our events bucket exists and has RFC3339 encoded time keys.
	c := tx.Bucket([]byte(&quot;Events&quot;)).Cursor()

	// Our time range spans the 90's decade.
	min := []byte(&quot;1990-01-01T00:00:00Z&quot;)
	max := []byte(&quot;2000-01-01T00:00:00Z&quot;)

	// Iterate over the 90's.
	for k, v := c.Seek(min); k != nil &amp;&amp; bytes.Compare(k, max) &lt;= 0; k, v = c.Next() {
		fmt.Printf(&quot;%s: %s\n&quot;, k, v)
	}

	return nil
})
</code></pre><p>请注意，虽然RFC3339是可排序的，但Golang的RFC3339Nano实现不使用小数点后固定数量的数字，因此不可排序。</p><h4 id=foreach>ForEach()</h4><p>如果您知道要在存储桶中迭代所有键，也可以使用<code>ForEach()</code>函数：</p><pre><code class=language-GO>db.View(func(tx *bolt.Tx) error {
	// Assume bucket exists and has keys
	b := tx.Bucket([]byte(&quot;MyBucket&quot;))

	b.ForEach(func(k, v []byte) error {
		fmt.Printf(&quot;key=%s, value=%s\n&quot;, k, v)
		return nil
	})
	return nil
})
</code></pre><p>请注意，ForEach()中的键和值仅在事务打开时有效。如果您需要在事务之外使用键或值，您必须使用copy()将其复制到另一个字节切片。</p><h3 id=nested-buckets>Nested buckets</h3><p>以下是给定文档的中文翻译：</p><p>请注意，ForEach()中的键和值仅在事务打开时有效。如果您需要在事务之外使用键或值，您必须使用copy()将其复制到另一个字节切片。</p><p><strong>嵌套的桶</strong> 您还可以在键中存储一个桶，以创建嵌套的桶。该API与DB对象上的桶管理API相同：</p><pre><code class=language-go>func (*Bucket) CreateBucket(key []byte) (*Bucket, error)
func (*Bucket) CreateBucketIfNotExists(key []byte) (*Bucket, error)
func (*Bucket) DeleteBucket(key []byte) error
</code></pre><p>假设您有一个多租户应用程序，其中根级别的桶是帐户桶。在此桶内是一系列自身为桶的帐户。在这个序列桶里，你可以拥有许多与账户自身相关的桶（如用户、笔记等），将信息隔离到逻辑分组中。</p><pre><code class=language-go>// createUser 在给定账户中创建一个新用户。
func createUser(accountID int, u *User) error {
    // 开始事务。
    tx, err := db.Begin(true)
    if err != nil {
        return err
    }
    defer tx.Rollback()

    // 检索帐户的根桶。
    // 假设在设置帐户时已经创建了此桶。
    root := tx.Bucket([]byte(strconv.FormatUint(accountID, 10)))

    // 设置用户桶。
    bkt, err := root.CreateBucketIfNotExists([]byte(&quot;USERS&quot;))
    if err != nil {
        return err
    }

    // 为新用户生成ID。
    userID, err := bkt.NextSequence()
    if err != nil {
        return err
    }
    u.ID = userID

    // 序列化并保存编码的用户。
    if buf, err := json.Marshal(u); err != nil {
        return err
    } else if err := bkt.Put([]byte(strconv.FormatUint(u.ID, 10)), buf); err != nil {
        return err
    }

    // 提交事务。
    if err := tx.Commit(); err != nil {
        return err
    }

    return nil
}
</code></pre><h3 id=数据库备份>数据库备份</h3><p>Bolt是一个单一的文件，所以备份很容易。您可以使用Tx.WriteTo()函数将数据库的一致视图写入一个写入器。如果您从只读事务中调用此函数，它将执行一个热备份，并且不会阻止您的其他数据库读取和写入。</p><p>默认情况下，它将使用一个常规的文件句柄，该句柄将利用操作系统的页面缓存。请查看Tx文档，了解有关优化大于RAM数据集的信息。</p><p>一个常见的用例是通过HTTP进行备份，这样您就可以使用像cURL这样的工具进行数据库备份：</p><pre><code class=language-go>func BackupHandleFunc(w http.ResponseWriter, req *http.Request) {
    err := db.View(func(tx *bolt.Tx) error {
        w.Header().Set(&quot;Content-Type&quot;, &quot;application/octet-stream&quot;)
        w.Header().Set(&quot;Content-Disposition&quot;, `attachment; filename=&quot;my.db&quot;`)
        w.Header().Set(&quot;Content-Length&quot;, strconv.Itoa(int(tx.Size())))
        _, err := tx.WriteTo(w)
        return err
    })
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
    }
}
</code></pre><p>然后你可以使用这个命令备份：</p><pre><code class=language-go>$ curl http://localhost/backup &gt; my.db
</code></pre><p>或者您可以打开您的浏览器访问http://localhost/backup，它将自动下载。</p><p>如果您想备份到另一个文件，您可以使用Tx.CopyFile()辅助函数。</p><p><strong>统计信息</strong> 数据库保持对其执行的许多内部操作的持续计数，这样您可以更好地了解正在发生的事情。通过在两个时间点获取这些统计的快照，我们可以看到在这个时间范围内执行了哪些操作。</p><p>例如，我们可以启动一个goroutine，每10秒记录一次统计信息：</p><pre><code class=language-go>go func() {
    // 获取初始统计。
    prev := db.Stats()

    for {
        // 等待10秒。
        time.Sleep(10 * time.Second)

        // 获取当前统计并对其进行差异处理。
        stats := db.Stats()
        diff := stats.Sub(&amp;prev)

        // 将统计信息编码为JSON并打印到STDERR。
        json.NewEncoder(os.Stderr).Encode(diff)

        // 为下一个循环保存统计。
        prev = stats
    }
}()
</code></pre><p>将这些统计信息管道到像statsd这样的服务进行监控，或者提供一个HTTP端点来执行固定长度的样本，也很有用。</p><h3 id=只读模式>只读模式</h3><p>有时创建一个共享的、只读的Bolt数据库是很有用的。要做到这一点，打开数据库时设置Options.ReadOnly标志。只读模式使用共享锁，允许多个进程从数据库中读取，但它会阻止任何进程以读写模式打开数据库。</p><pre><code class=language-go>db, err := bolt.Open(&quot;my.db&quot;, 0600, &amp;bolt.Options{ReadOnly: true})
if err != nil {
    log.Fatal(err)
}
</code></pre><p>希望这可以帮助您理解给定的文档！如果您有任何问题或需要进一步的澄清，请告诉我。</p><h2 id=referance>referance</h2><ul><li><a href=https://github.com/etcd-io/bbolt target=_blank>https://github.com/etcd-io/bbolt</a></li><li><a href=https://zhuanlan.zhihu.com/p/377572049 target=_blank>https://zhuanlan.zhihu.com/p/377572049</a></li></ul></div></article><div class="license markdown-body"><blockquote><p>Unless otherwise noted, the content of this site is licensed under <a rel=license href=http://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank>CC BY-NC-SA 4.0</a>.</p></blockquote></div></div><aside class="col-12 col-md-3 float-left sidebar"><div class="sidebar-item sidebar-pages"><h3>Pages</h3><ul><li><a href=/>Home</a></li><li><a href=/archives/>Archives</a></li><li><a href=/index.xml>RSS</a></li><li><a href=/about/>About</a></li><li><a href=/search/>Search</a></li></ul></div><div class="sidebar-item sidebar-links"><h3>Links</h3><ul><li><a href=https://github.com/daemon365 target=_blank><span>My GitHub</span></a></li></ul></div><div class="sidebar-item sidebar-tags"><h3>Tags</h3><div><span><a href=/tags/bbr/>BBR</a>
</span><span><a href=/tags/boltdb/>Boltdb</a>
</span><span><a href=/tags/breaker/>Breaker</a>
</span><span><a href=/tags/cdi/>Cdi</a>
</span><span><a href=/tags/cgroup/>Cgroup</a>
</span><span><a href=/tags/client-go/>Client-Go</a>
</span><span><a href=/tags/cni/>Cni</a>
</span><span><a href=/tags/containerd/>Containerd</a>
</span><span><a href=/tags/containerd-shim/>Containerd-Shim</a>
</span><span><a href=/tags/cri/>Cri</a>
</span><span><a href=/tags/csi/>Csi</a>
</span><span><a href=/tags/docker/>Docker</a>
</span><span><a href=/tags/etcd/>Etcd</a>
</span><span><a href=/tags/gin/>Gin</a>
</span><span><a href=/tags/go/>Go</a>
</span><span><a href=/tags/golang/>Golang</a>
</span><span><a href=/tags/grpc/>Grpc</a>
</span><span><a href=/tags/iptables/>Iptables</a>
</span><span><a href=/tags/ipvs/>Ipvs</a>
</span><span><a href=/tags/istio/>Istio</a>
</span><span><a href=/tags/kratos/>Kratos</a>
</span><span><a href=/tags/kube-proxy/>Kube-Proxy</a>
</span><span><a href=/tags/kubelet/>Kubelet</a>
</span><span><a href=/tags/kubernetes/>Kubernetes</a>
</span><span><a href=/tags/linux/>Linux</a>
</span><span><a href=/tags/lua/>Lua</a>
</span><span><a href=/tags/makefile/>Makefile</a>
</span><span><a href=/tags/mysql/>Mysql</a>
</span><span><a href=/tags/namespace/>Namespace</a>
</span><span><a href=/tags/network/>Network</a>
</span><span><a href=/tags/nginx/>Nginx</a>
</span><span><a href=/tags/opentelemetry/>Opentelemetry</a>
</span><span><a href=/tags/prometheus/>Prometheus</a>
</span><span><a href=/tags/protobuf/>Protobuf</a>
</span><span><a href=/tags/rabbitmq/>RabbitMQ</a>
</span><span><a href=/tags/redis/>Redis</a>
</span><span><a href=/tags/runc/>Runc</a>
</span><span><a href=/tags/service-mesh/>Service Mesh</a>
</span><span><a href=/tags/sidecar/>Sidecar</a>
</span><span><a href=/tags/sqlx/>Sqlx</a>
</span><span><a href=/tags/thrift/>Thrift</a>
</span><span><a href=/tags/unionfs/>UnionFS</a>
</span><span><a href=/tags/viper/>Viper</a>
</span><span><a href=/tags/vscode/>Vscode</a>
</span><span><a href=/tags/wire/>Wire</a>
</span><span><a href=/tags/zap/>Zap</a>
</span><span><a href=/tags/%E4%BA%8B%E5%8A%A1/>事务</a>
</span><span><a href=/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/>数据库</a>
</span><span><a href=/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/>源码分析</a>
</span><span><a href=/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>设计模式</a></span></div></div><div class="sidebar-item sidebar-toc"><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#介绍>介绍</a></li><li><a href=#谁在使用>谁在使用</a></li><li><a href=#架构图>架构图</a></li><li><a href=#引入>引入</a></li><li><a href=#使用>使用</a><ul><li><a href=#open--a-database>open a database</a></li><li><a href=#transactions>Transactions</a></li><li><a href=#using-buckets>Using buckets</a></li><li><a href=#using-keyvalue-pairs>Using key/value pairs</a></li><li><a href=#autoincrementing-integer-for-the-bucket>Autoincrementing integer for the bucket</a></li><li><a href=#iterating-over-keys>Iterating over keys</a></li><li><a href=#nested-buckets>Nested buckets</a></li><li><a href=#数据库备份>数据库备份</a></li><li><a href=#只读模式>只读模式</a></li></ul></li><li><a href=#referance>referance</a></li></ul></nav></div></aside></div><div class=btn><div class=btn-menu id=btn-menu><i class="iconfont icon-grid-sharp"></i></div><div class=btn-toggle-mode><i class="iconfont icon-contrast-sharp"></i></div><div class=btn-scroll-top><i class="iconfont icon-chevron-up-circle-sharp"></i></div></div><aside class=sidebar-mobile style=display:none><div class=sidebar-wrapper><div class="sidebar-item sidebar-pages"><h3>Pages</h3><ul><li><a href=/>Home</a></li><li><a href=/archives/>Archives</a></li><li><a href=/index.xml>RSS</a></li><li><a href=/about/>About</a></li><li><a href=/search/>Search</a></li></ul></div><div class="sidebar-item sidebar-links"><h3>Links</h3><ul><li><a href=https://github.com/daemon365 target=_blank><span>My GitHub</span></a></li></ul></div><div class="sidebar-item sidebar-tags"><h3>Tags</h3><div><span><a href=/tags/bbr/>BBR</a>
</span><span><a href=/tags/boltdb/>Boltdb</a>
</span><span><a href=/tags/breaker/>Breaker</a>
</span><span><a href=/tags/cdi/>Cdi</a>
</span><span><a href=/tags/cgroup/>Cgroup</a>
</span><span><a href=/tags/client-go/>Client-Go</a>
</span><span><a href=/tags/cni/>Cni</a>
</span><span><a href=/tags/containerd/>Containerd</a>
</span><span><a href=/tags/containerd-shim/>Containerd-Shim</a>
</span><span><a href=/tags/cri/>Cri</a>
</span><span><a href=/tags/csi/>Csi</a>
</span><span><a href=/tags/docker/>Docker</a>
</span><span><a href=/tags/etcd/>Etcd</a>
</span><span><a href=/tags/gin/>Gin</a>
</span><span><a href=/tags/go/>Go</a>
</span><span><a href=/tags/golang/>Golang</a>
</span><span><a href=/tags/grpc/>Grpc</a>
</span><span><a href=/tags/iptables/>Iptables</a>
</span><span><a href=/tags/ipvs/>Ipvs</a>
</span><span><a href=/tags/istio/>Istio</a>
</span><span><a href=/tags/kratos/>Kratos</a>
</span><span><a href=/tags/kube-proxy/>Kube-Proxy</a>
</span><span><a href=/tags/kubelet/>Kubelet</a>
</span><span><a href=/tags/kubernetes/>Kubernetes</a>
</span><span><a href=/tags/linux/>Linux</a>
</span><span><a href=/tags/lua/>Lua</a>
</span><span><a href=/tags/makefile/>Makefile</a>
</span><span><a href=/tags/mysql/>Mysql</a>
</span><span><a href=/tags/namespace/>Namespace</a>
</span><span><a href=/tags/network/>Network</a>
</span><span><a href=/tags/nginx/>Nginx</a>
</span><span><a href=/tags/opentelemetry/>Opentelemetry</a>
</span><span><a href=/tags/prometheus/>Prometheus</a>
</span><span><a href=/tags/protobuf/>Protobuf</a>
</span><span><a href=/tags/rabbitmq/>RabbitMQ</a>
</span><span><a href=/tags/redis/>Redis</a>
</span><span><a href=/tags/runc/>Runc</a>
</span><span><a href=/tags/service-mesh/>Service Mesh</a>
</span><span><a href=/tags/sidecar/>Sidecar</a>
</span><span><a href=/tags/sqlx/>Sqlx</a>
</span><span><a href=/tags/thrift/>Thrift</a>
</span><span><a href=/tags/unionfs/>UnionFS</a>
</span><span><a href=/tags/viper/>Viper</a>
</span><span><a href=/tags/vscode/>Vscode</a>
</span><span><a href=/tags/wire/>Wire</a>
</span><span><a href=/tags/zap/>Zap</a>
</span><span><a href=/tags/%E4%BA%8B%E5%8A%A1/>事务</a>
</span><span><a href=/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/>数据库</a>
</span><span><a href=/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/>源码分析</a>
</span><span><a href=/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>设计模式</a></span></div></div><div class="sidebar-item sidebar-toc"><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#介绍>介绍</a></li><li><a href=#谁在使用>谁在使用</a></li><li><a href=#架构图>架构图</a></li><li><a href=#引入>引入</a></li><li><a href=#使用>使用</a><ul><li><a href=#open--a-database>open a database</a></li><li><a href=#transactions>Transactions</a></li><li><a href=#using-buckets>Using buckets</a></li><li><a href=#using-keyvalue-pairs>Using key/value pairs</a></li><li><a href=#autoincrementing-integer-for-the-bucket>Autoincrementing integer for the bucket</a></li><li><a href=#iterating-over-keys>Iterating over keys</a></li><li><a href=#nested-buckets>Nested buckets</a></li><li><a href=#数据库备份>数据库备份</a></li><li><a href=#只读模式>只读模式</a></li></ul></li><li><a href=#referance>referance</a></li></ul></nav></div></div></aside></main><footer><div class="container-lg clearfix"><div class="col-12 footer"><span>&copy; 2019-2024
<a href=https://daemon365.dev/>daemon365</a>
| Powered by <a href=https://github.com/dsrkafuu/hugo-theme-fuji/ target=_blank>Fuji-v2</a> & <a href=https://gohugo.io/ target=_blank>Hugo</a></span></div></div></footer><script defer src=https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js integrity="sha512-q583ppKrCRc7N5O0n2nzUiJ+suUv7Et1JGels4bXOaMFQcamPk9HjdUknZuuFjBNs7tsMuadge5k9RzdmO+1GQ==" crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1.27.0/components/prism-core.min.js integrity="sha512-LCKPTo0gtJ74zCNMbWw04ltmujpzSR4oW+fgN+Y1YclhM5ZrHCZQAJE4quEodcI/G122sRhSGU2BsSRUZ2Gu3w==" crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1.27.0/plugins/autoloader/prism-autoloader.min.js integrity="sha512-GP4x8UWxWyh4BMbyJGOGneiTbkrWEF5izsVJByzVLodP8CuJH/n936+yQDMJJrOPUHLgyPbLiGw2rXmdvGdXHA==" crossorigin=anonymous></script><script defer src=/assets/js/fuji.min.645f1123be695831f419ab54c1bcba327325895c740014006e57070d4f3e5d6b553e929c4b46f40ea707249e9c7f7c2a446d32a39ce7319f80a34525586a8e0f.js integrity="sha512-ZF8RI75pWDH0GatUwby6MnMliVx0ABQAblcHDU8+XWtVPpKcS0b0DqcHJJ6cf3wqRG0yo5znMZ+Ao0UlWGqODw=="></script></body></html>