<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=HandheldFriendly content="True"><meta http-equiv=X-UA-Compatible content="IE=edge"><meta http-equiv=Cache-Control content="no-transform"><meta http-equiv=Cache-Control content="no-siteapp"><meta name=generator content="Hugo 0.128.1"><link rel="shortcut icon" href=/imgs/icons/favicon.ico><title>boltdb 原理 - Daemon</title>
<meta name=author content="daemon365"><meta name=description content="Don't let yourself stop."><meta name=keywords content="boltdb,etcd,golang,数据库,kubernetes,源码分析,事务"><meta property="og:title" content="boltdb 原理"><meta name=twitter:title content="boltdb 原理"><meta property="og:type" content="article"><meta property="og:url" content="https://daemon365.dev/2024/06/15/boltdb-%E5%8E%9F%E7%90%86/"><meta property="og:description" content="简介 介绍及简单使用：https://www.cnblogs.com/daemon365/p/17690167.html 源码地址：https://github.com/etcd-io/bbolt page 因为 boltdb"><meta name=twitter:description content="简介 介绍及简单使用：https://www.cnblogs.com/daemon365/p/17690167.html 源码地址：https://github.com/etcd-io/bbolt page 因为 boltdb"><meta property="og:image" content="https://daemon365.dev/imgs/icons/favicon.ico"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://daemon365.dev/imgs/icons/favicon.ico"><meta property="article:published_time" content="2024-06-15T16:14:00+08:00"><meta property="article:modified_time" content="2024-06-15T16:14:00+08:00"><style>@media(prefers-color-scheme:dark){body[data-theme=auto] img{filter:brightness(60%)}}body[data-theme=dark] img{filter:brightness(60%)}</style><link rel=stylesheet href=https://daemon365.dev/assets/css/fuji.min.4e0456c767a797dadceacfba968921e887d900af9fd8d0953bebc1524ea1dec6c6a4a5ec0c0b77280884a642028ce374f31206dd96c6d7d143d5ee3c372f2c31.css integrity="sha512-TgRWx2enl9rc6s+6lokh6IfZAK+f2NCVO+vBUk6h3sbGpKXsDAt3KAiEpkICjON08xIG3ZbG19FD1e48Ny8sMQ=="></head><body data-theme=light data-theme-auto=false><script data-cfasync=false>var fujiThemeData=localStorage.getItem("fuji_data-theme");fujiThemeData?fujiThemeData!=="auto"&&document.body.setAttribute("data-theme",fujiThemeData==="dark"?"dark":"light"):localStorage.setItem("fuji_data-theme","auto")</script><header><div class="container-lg clearfix"><div class="col-12 header"><a class=title-main href=https://daemon365.dev/>Daemon</a>
<span class=title-sub>Don't let yourself stop.</span></div></div></header><main><div class="container-lg clearfix"><div class="col-12 col-md-9 float-left content"><article><h2 class="post-item post-title"><a href=https://daemon365.dev/2024/06/15/boltdb-%E5%8E%9F%E7%90%86/>boltdb 原理</a></h2><div class="post-item post-meta"><span><i class="iconfont icon-today-sharp"></i>&nbsp;2024-06-15</span>
<span><i class="iconfont icon-file-tray-sharp"></i>&nbsp;9599 words</span>
<span><i class="iconfont icon-pricetags-sharp"></i>&nbsp;<a href=/tags/boltdb>boltdb</a>&nbsp;<a href=/tags/etcd>etcd</a>&nbsp;<a href=/tags/golang>golang</a>&nbsp;<a href=/tags/%E6%95%B0%E6%8D%AE%E5%BA%93>数据库</a>&nbsp;<a href=/tags/kubernetes>kubernetes</a>&nbsp;<a href=/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90>源码分析</a>&nbsp;<a href=/tags/%E4%BA%8B%E5%8A%A1>事务</a>&nbsp;</span></div><div class="post-content markdown-body"><h2 id=简介>简介</h2><p>介绍及简单使用：https://www.cnblogs.com/daemon365/p/17690167.html
源码地址：https://github.com/etcd-io/bbolt</p><h2 id=page>page</h2><p>因为 boltdb 是要落盘的，所以就要操作文件。为了提高效率，boltdb 会和其他数据库一样，会按 页（page）来操作文件。而且 boltdb 使用了 linux 的 <a href=https://man7.org/linux/man-pages/man2/mmap.2.html target=_blank>mmap</a> 来内存映射操作文件，这样可以提高效率。</p><p>在 linux 中，每个 page 的大小是 4KB。</p><pre><code class=language-BASH>getconf PAGESIZE
4096
</code></pre><p>对应的每页在我们的代理里也应该有一个数据结构，来存储数据。这个数据结构就是 <code>page</code>。</p><pre><code class=language-go>type Pgid uint64

type Page struct {
	id       Pgid
	flags    uint16 // page 类型
	count    uint16 // page 中的元素数量
	overflow uint32 // 是否有后序页，如果有，overflow 表示后续页的数量
}

const (
	BranchPageFlag   = 0x01
	LeafPageFlag     = 0x02
	MetaPageFlag     = 0x04
	FreelistPageFlag = 0x10 
)
</code></pre><p><code>Page</code> 里面有一个 <code>flags</code> 字段，用来标识这个 page 是什么类型的。boltdb 里面有四种类型的 page, 分别是 分支页（BranchPageFlag）、叶子页（LeafPageFlag）、元数据页（MetaPageFlag）、空闲列表页（FreelistPageFlag）。</p><ul><li>分支页：由于 boltdb 使用的是 B+ 树，所以分支页用来存储 key 和子节点的指针。</li><li>叶子页：叶子页用来存储 key 和 value。</li><li>元数据页：元数据页用来存储 boltdb 的元数据，比如 boltdb 的版本号、boltdb 的根节点等。</li><li>空闲列表页：由于 boltdb 使用 copy on write，所以当一个 page 被删除的时候，boltdb 并不会立即释放这个 page，而是把这个 page 加入到空闲列表页中，等到需要新的 page 的时候，再从空闲列表页中取出一个 page。</li></ul><p>在 page 之后会存储对用的结构，比如 meta 或者 freelist。先读取 page 判断自己的结构（定长的：8 + 2 + 2 +4），然后再根据不同的数据类型读取其他的结构（比如BranchPage）。</p><p><img class=img-zoomable src=/images/eebaffa3-116e-40f0-95be-2dfc0ee58bd6.png alt></p><h3 id=branchpage--leafpage>BranchPage && LeafPage</h3><p>这两个分别存储 B+ tree 的分支页和叶子页。对应结构为：</p><pre><code class=language-go>// branchPageElement represents a node on a branch page.
type branchPageElement struct {
	pos   uint32 // 真实数据对应的偏移量
	ksize uint32 // key 的大小
	pgid  Pgid // 指向 page 的 id
}


// leafPageElement represents a node on a leaf page.
type leafPageElement struct {
	flags uint32 // 是否是一个 bucket
	pos   uint32 // 真实数据对应的偏移量
	ksize uint32 // key 的大小
	vsize uint32 // value 的大小
}
</code></pre><p>对应的存储方式为:</p><p><img class=img-zoomable src=/images/c5206aef-62de-447a-880a-3024a75f4b3d.png alt></p><p>从 page 中拿取数据：</p><pre><code class=language-go>func (p *Page) LeafPageElements() []leafPageElement {
	if p.count == 0 {
		return nil
	}
	// 从 page 的指针 加上 page 的大小，就是第一个元素的地址
	data := UnsafeAdd(unsafe.Pointer(p), unsafe.Sizeof(*p))
	// 转换为 slice
	elems := unsafe.Slice((*leafPageElement)(data), int(p.count))
	return elems
}

func (p *Page) BranchPageElements() []branchPageElement {
	if p.count == 0 {
		return nil
	}
	data := UnsafeAdd(unsafe.Pointer(p), unsafe.Sizeof(*p))
	elems := unsafe.Slice((*branchPageElement)(data), int(p.count))
	return elems
}
</code></pre><h3 id=metapage>MetaPage</h3><pre><code class=language-go>type Meta struct {
	magic    uint32 // boltdb 的魔数
	version  uint32 // boltdb 的版本
	pageSize uint32 // boltdb 的 page 大小 ，该值和操作系统默认的页大小保持一致
	flags    uint32 
	root     InBucket // boltdb 的根节点
	freelist Pgid   // 空闲页的 id
	pgid     Pgid // 当前 page 的 id
	txid     Txid // 当前事务的 id
	checksum uint64 // 用作校验的校验和
}
</code></pre><p>它是如何写到 page 中的和从 page 中读取的呢？</p><pre><code class=language-go>// 把 meta 写到 page 中
func (m *Meta) Write(p *Page) {
	// 检查 root bucket 的 pgid 是否有效。
	// 如果 root.root 的 pgid 大于或等于 m.pgid，这是不合理的，因为这意味着它引用了一个尚未分配的 pgid。
	if m.root.root &gt;= m.pgid {
		panic(fmt.Sprintf(&quot;root bucket pgid (%d) above high water mark (%d)&quot;, m.root.root, m.pgid))

	  // 检查 freelist 的 pgid 是否有效。
	  // 如果 freelist 的 pgid 大于或等于 m.pgid 且 freelist 不是 PgidNoFreelist，
	  // 这同样表示它引用了一个尚未分配的 pgid，这是不合理的。
	} else if m.freelist &gt;= m.pgid &amp;&amp; m.freelist != PgidNoFreelist {
		panic(fmt.Sprintf(&quot;freelist pgid (%d) above high water mark (%d)&quot;, m.freelist, m.pgid))
	}

	// 指定 pageId 和 page 类型
	p.id = Pgid(m.txid % 2)
	p.SetFlags(MetaPageFlag)

	// 计算校验和
	m.checksum = m.Sum64()

	m.Copy(p.Meta())
}

// 从 page 中读取 meta
func (p *Page) Meta() *Meta {
	return (*Meta)(UnsafeAdd(unsafe.Pointer(p), unsafe.Sizeof(*p)))
}

// 把 meta 的数据拷贝到 page 中
func (m *Meta) Copy(dest *Meta) {
	*dest = *m
}

// 计算校验和
func (m *Meta) Sum64() uint64 {
	var h = fnv.New64a()
	_, _ = h.Write((*[unsafe.Offsetof(Meta{}.checksum)]byte)(unsafe.Pointer(m))[:])
	return h.Sum64()
}

</code></pre><h3 id=freelistpage>FreelistPage</h3><pre><code class=language-go>type freelist struct {
    // 表示 freelist 的类型，可能会有不同的策略或实现。
    freelistType FreelistType
    // 存储所有已释放且可供分配的页面ID。
    ids []common.Pgid
    // 记录哪个事务ID分配了特定的页面ID。
    allocs map[common.Pgid]common.Txid
    // 记录即将被释放的页面ID及其所属的事务ID。
    pending map[common.Txid]*txPending
    // 快速查找所有空闲和待处理页面ID的缓存。
    cache map[common.Pgid]struct{}
    // 按连续页面大小分类的空闲页面，键是连续页面的大小，值是具有相同大小的起始页面ID的集合。
    freemaps map[uint64]pidSet
    // 正向映射，键是起始页面ID，值是其span大小。
    forwardMap map[common.Pgid]uint64
    // 反向映射，键是结束页面ID，值是其span大小。
    backwardMap map[common.Pgid]uint64
    // 空闲页面的计数（基于哈希图的版本）。
    freePagesCount uint64
    // 分配函数，根据提供的事务ID和需求的页面数量分配页面。
    allocate func(txid common.Txid, n int) common.Pgid
    // 返回当前空闲页面数量的函数。
    free_count func() int
    // 合并连续空闲页面的函数。
    mergeSpans func(ids common.Pgids)
    // 获取所有空闲页面ID的函数。
    getFreePageIDs func() []common.Pgid
    // 读取一系列页面ID并初始化 freelist 的函数。
    readIDs func(pgids []common.Pgid)
}

// FreelistType 定义了 freelist 后端的类型，用字符串表示不同的实现策略。
type FreelistType string

// 未来的开发计划：
//  1. 默认改为使用 `FreelistMapType`；
//  2. 移除 `FreelistArrayType`，不再公开 `FreelistMapType`，
//     并从 `DB` 和 `Options` 结构体中移除 `FreelistType` 字段。
const (
    // FreelistArrayType 表示 freelist 的后端类型为数组。
    // 这种类型可能适用于需要按顺序访问空闲页的场景。
    FreelistArrayType = FreelistType(&quot;array&quot;)

    // FreelistMapType 表示 freelist 的后端类型为哈希映射。
    // 这种类型提供了更快的查找速度，适合于频繁、随机地访问空闲页的情况。
    FreelistMapType = FreelistType(&quot;hashmap&quot;)
)
</code></pre><p>把 freelist 写到 page 中：</p><pre><code class=language-go>// write 将空闲和待处理的页面ID写入到 freelist 页面。
// 在程序崩溃的事件中，所有待处理的ID都将变成空闲的，因此这些ID都需要被保存到磁盘上。
func (f *freelist) write(p *common.Page) error {

 	// 设置页头中的页类型标识
	p.SetFlags(common.FreelistPageFlag)

	// 获取需要保存的 PageID 数量。
	l := f.count()
	if l == 0 {
		// 没有 id 需要保存，直接返回。
		p.SetCount(uint16(l))
	} else if l &lt; 0xFFFF {
		// 如果数量小于 0xFFFF
		// 将 id 数量写入到页头中
		p.SetCount(uint16(l))
		// 计算指针头
		data := common.UnsafeAdd(unsafe.Pointer(p), unsafe.Sizeof(*p))
		// 开辟一个 slice 用来存储 id
		ids := unsafe.Slice((*common.Pgid)(data), l)
		// 将 id 拷贝到 page 中
		f.copyall(ids)
	} else {
		// 如果数量大于 0xFFFF ，则需要分多个 page 来保存
		// 先设置本页的数量为 0xFFFF
		p.SetCount(0xFFFF)
		// 计算指针头 
		data := common.UnsafeAdd(unsafe.Pointer(p), unsafe.Sizeof(*p))
		ids := unsafe.Slice((*common.Pgid)(data), l+1)
		// 将ID数量存储在第一个元素中
		ids[0] = common.Pgid(l)
		// 将剩余的 id 拷贝到 page 中
		f.copyall(ids[1:])
	}

	return nil
}

// copyall 将所有空闲的ID和所有待处理的ID复制到一个排序后的列表中。
// f.count 返回目标数组 dst 需要的最小长度。
func (f *freelist) copyall(dst []common.Pgid) {
    // 创建一个切片用于存放待处理的ID，容量预设为待处理ID的数量。
    m := make(common.Pgids, 0, f.pending_count())

    // 遍历所有待处理事务，并将它们的ID加入到切片 m 中。
    for _, txp := range f.pending {
        m = append(m, txp.ids...)
    }

    // 对切片 m 进行排序。
    sort.Sort(m)

    // 将已经空闲的ID和刚排序的待处理ID合并到目标切片 dst 中。
    common.Mergepgids(dst, f.getFreePageIDs(), m)
}


// Mergepgids 将两个已排序列表 a 和 b 的并集复制到 dst 中。
// 如果 dst 的长度不足以容纳结果，会触发 panic。
func Mergepgids(dst, a, b Pgids) {
    // 检查目标切片 dst 是否足够大以容纳 a 和 b 的所有元素。
    if len(dst) &lt; len(a)+len(b) {
        panic(fmt.Errorf(&quot;mergepgids bad len %d &lt; %d + %d&quot;, len(dst), len(a), len(b)))
    }

    // 如果其中一个列表为空，则直接将另一个列表复制到 dst 中。
    if len(a) == 0 {
        copy(dst, b)
        return
    }
    if len(b) == 0 {
        copy(dst, a)
        return
    }

    // 初始化一个切片 merged 来存储最终合并的结果。
    merged := dst[:0]

    // 确定哪个列表的起始值更小，并将其设为 lead，另一个设为 follow。
    lead, follow := a, b
    if b[0] &lt; a[0] {
        lead, follow = b, a
    }

    // 循环合并，直到 lead 为空。
    for len(lead) &gt; 0 {
        // 合并 lead 中所有小于 follow[0] 的元素。
        n := sort.Search(len(lead), func(i int) bool { return lead[i] &gt; follow[0] })
        merged = append(merged, lead[:n]...)
        if n &gt;= len(lead) {
            break
        }

        // 交换 lead 和 follow，继续合并过程。
        lead, follow = follow, lead[n:]
    }

    // 将剩余的 follow 元素加入到 merged 中。
    _ = append(merged, follow...)
}
</code></pre><p>从 page 中读取 freelist：</p><pre><code class=language-go>// read 从 freelist 页面读取页面ID。
func (f *freelist) read(p *common.Page) {
    // 首先检查是否为 freelist 页面，如果不是则抛出错误。
    if !p.IsFreelistPage() {
        panic(fmt.Sprintf(&quot;invalid freelist page: %d, page type is %s&quot;, p.Id(), p.Typ()))
    }

    // 从页面获取 freelist 页面的ID列表。
    ids := p.FreelistPageIds()

    // 如果获取的ID列表为空，将 f.ids 设置为 nil，表示没有空闲页面。
    if len(ids) == 0 {
        f.ids = nil
    } else {
        // 如果ID列表不为空，则创建一个新切片并复制这些ID，以避免直接修改原始页面数据。
        idsCopy := make([]common.Pgid, len(ids))
        copy(idsCopy, ids)
        // 确保复制的ID列表是排序的。
        sort.Sort(common.Pgids(idsCopy))

        // 将排序后的ID列表读入 freelist 结构。
        f.readIDs(idsCopy)
    }
}

// hashmapReadIDs 读取输入的 pgids 并初始化 freelist（基于哈希映射的版本）。
func (f *freelist) hashmapReadIDs(pgids []common.Pgid) {
    // 初始化 freelist。
    f.init(pgids)

    // 重建页面缓存。
    f.reindex()
}

// reindex 基于可用和待处理的空闲列表重建自由缓存。
func (f *freelist) reindex() {
    // 获取所有空闲页面ID。
    ids := f.getFreePageIDs()
    // 创建一个新的缓存映射。
    f.cache = make(map[common.Pgid]struct{}, len(ids))
    // 将所有空闲ID添加到缓存中。
    for _, id := range ids {
        f.cache[id] = struct{}{}
    }
    // 将所有待处理的空闲ID也添加到缓存中。
    for _, txp := range f.pending {
        for _, pendingID := range txp.ids {
            f.cache[pendingID] = struct{}{}
        }
    }
}
</code></pre><p>分配页：</p><pre><code class=language-go>// hashmapAllocate 根据传入的事务ID和请求的页面数量，分配页面。
func (f *freelist) hashmapAllocate(txid common.Txid, n int) common.Pgid {
	if n == 0 {
		// 如果请求的页面数量为0，则直接返回0，表示没有分配任何页面。
		return 0
	}

	// 检查是否存在完全匹配的空闲span。
	if bm, ok := f.freemaps[uint64(n)]; ok {
		for pid := range bm {
			// 移除这个span。
			f.delSpan(pid, uint64(n))

			// 记录这个页面ID被哪个事务分配。
			f.allocs[pid] = txid

			// 从缓存中移除已分配的页面。
			for i := common.Pgid(0); i &lt; common.Pgid(n); i++ {
				delete(f.cache, pid+i)
			}
			return pid
		}
	}

	// 在映射中查找大于请求大小的更大span。
	for size, bm := range f.freemaps {
		if size &lt; uint64(n) {
			continue
		}

		for pid := range bm {
			// 移除找到的大span。
			f.delSpan(pid, size)

			// 记录页面分配。
			f.allocs[pid] = txid

			// 计算剩余的span大小，并添加回 freelist。
			remain := size - uint64(n)
			f.addSpan(pid+common.Pgid(n), remain)

			// 从缓存中移除已分配的页面。
			for i := common.Pgid(0); i &lt; common.Pgid(n); i++ {
				delete(f.cache, pid+i)
			}
			return pid
		}
	}

	return 0
}

// delSpan 从 freelist 中删除一个span。
func (f *freelist) delSpan(start common.Pgid, size uint64) {
	// 更新前向和后向映射，移除对应的条目。
	delete(f.forwardMap, start)
	delete(f.backwardMap, start+common.Pgid(size-1))
	// 从 freemaps 中移除span。
	delete(f.freemaps[size], start)
	if len(f.freemaps[size]) == 0 {
		// 如果某个大小的span已经没有其他项，从 freemaps 中完全移除这个大小。
		delete(f.freemaps, size)
	}
	// 更新空闲页面计数。
	f.freePagesCount -= size
}

// addSpan 向 freelist 中添加一个新的span。
func (f *freelist) addSpan(start common.Pgid, size uint64) {
	// 更新前向和后向映射。
	f.backwardMap[start-1+common.Pgid(size)] = size
	f.forwardMap[start] = size
	// 确保 freemaps 中存在对应大小的映射。
	if _, ok := f.freemaps[size]; !ok {
		f.freemaps[size] = make(map[common.Pgid]struct{})
	}
	// 添加新的span到 freemaps。
	f.freemaps[size][start] = struct{}{}
	// 更新空闲页面计数。
	f.freePagesCount += size
}
</code></pre><h2 id=node>Node</h2><p>page 的操作跟多都是基于磁盘设计的，在内存中使用这些数据结构并不是很方便。所以 boltdb 会把 page 的数据结构转换为 node 的数据结构，这样在内存中操作就会方便很多。</p><pre><code class=language-go>type node struct {
	bucket     *Bucket // bucket 的指针
	isLeaf     bool // 是否是叶子节点
	unbalanced bool // 是否平衡
	spilled    bool // 是否溢出
	key        []byte // 该 node 的起始 key
	pgid       common.Pgid // 该 node 对应的 page id
	parent     *node // 父节点
	children   nodes // 子节点
	inodes     common.Inodes // 存储键值对的结构体数组
}

type Inode struct {
	flags uint32 // 用于 leaf node 是否是一个 bucket （subbucket）
	pgid  Pgid	// 用于 branch node, 子节点的 page id
	key   []byte // key
	value []byte // value
}

type Inodes []Inode

</code></pre><h3 id=page-to-node>page to node</h3><pre><code class=language-go>func (n *node) read(p *common.Page) {
	n.pgid = p.Id()
	n.isLeaf = p.IsLeafPage()
	// 读取 inodes
	n.inodes = common.ReadInodeFromPage(p)

	// 保存第一个键，以便在将节点写入到父节点时能够找到这个节点。
	if len(n.inodes) &gt; 0 {
		n.key = n.inodes[0].Key()
		common.Assert(len(n.key) &gt; 0, &quot;read: zero-length node key&quot;)
	} else {
		n.key = nil
	}
}

func ReadInodeFromPage(p *Page) Inodes {
	inodes := make(Inodes, int(p.Count()))
	isLeaf := p.IsLeafPage()
	for i := 0; i &lt; int(p.Count()); i++ {
		inode := &amp;inodes[i]
		if isLeaf {
			// 转换为 leafPageElement 结构
			elem := p.LeafPageElement(uint16(i))
			inode.SetFlags(elem.Flags())
			inode.SetKey(elem.Key())
			inode.SetValue(elem.Value())
		} else {
			// 转换为 branchPageElement 结构
			elem := p.BranchPageElement(uint16(i))
			inode.SetPgid(elem.Pgid())
			inode.SetKey(elem.Key())
		}
		Assert(len(inode.Key()) &gt; 0, &quot;read: zero-length inode key&quot;)
	}

	return inodes
}
</code></pre><h3 id=node-to-page>node to page</h3><pre><code class=language-go>// write writes the items onto one or more pages.
// The page should have p.id (might be 0 for meta or bucket-inline page) and p.overflow set
// and the rest should be zeroed.
func (n *node) write(p *common.Page) {
	common.Assert(p.Count() == 0 &amp;&amp; p.Flags() == 0, &quot;node cannot be written into a not empty page&quot;)

	// Initialize page.
	if n.isLeaf {
		p.SetFlags(common.LeafPageFlag)
	} else {
		p.SetFlags(common.BranchPageFlag)
	}

	if len(n.inodes) &gt;= 0xFFFF {
		panic(fmt.Sprintf(&quot;inode overflow: %d (pgid=%d)&quot;, len(n.inodes), p.Id()))
	}
	p.SetCount(uint16(len(n.inodes)))

	// Stop here if there are no items to write.
	if p.Count() == 0 {
		return
	}

	// 将node的inodes写入page
	common.WriteInodeToPage(n.inodes, p)

	// DEBUG ONLY: n.dump()
}
func WriteInodeToPage(inodes Inodes, p *Page) uint32 {
	// 计算写入的初始偏移量。
	off := unsafe.Sizeof(*p) + p.PageElementSize()*uintptr(len(inodes))
	isLeaf := p.IsLeafPage()
	for i, item := range inodes {
		Assert(len(item.Key()) &gt; 0, &quot;write: zero-length inode key&quot;)

		// 创建一个足够大小的切片来存放键和值。
		sz := len(item.Key()) + len(item.Value())
		b := UnsafeByteSlice(unsafe.Pointer(p), off, 0, sz)
		off += uintptr(sz)

		// Write the page element.
		if isLeaf {
			elem := p.LeafPageElement(uint16(i))
			elem.SetPos(uint32(uintptr(unsafe.Pointer(&amp;b[0])) - uintptr(unsafe.Pointer(elem))))
			elem.SetFlags(item.Flags())
			elem.SetKsize(uint32(len(item.Key())))
			elem.SetVsize(uint32(len(item.Value())))
		} else {
			elem := p.BranchPageElement(uint16(i))
			elem.SetPos(uint32(uintptr(unsafe.Pointer(&amp;b[0])) - uintptr(unsafe.Pointer(elem))))
			elem.SetKsize(uint32(len(item.Key())))
			elem.SetPgid(item.Pgid())
			Assert(elem.Pgid() != p.Id(), &quot;write: circular dependency occurred&quot;)
		}

		// 将键和值数据写入到页面的末尾。
		l := copy(b, item.Key())
		copy(b[l:], item.Value())
	}

	return uint32(off)
}
</code></pre><h2 id=bucket>Bucket</h2><p>Bucket 是 boltdb 的上层的数据结构，每个 bucket 都有一个完成的 B+ 树。将多个 page 联合起来。</p><pre><code class=language-go>type Bucket struct {
    *common.InBucket             

    tx       *Tx                    // 指向关联事务的指针，将 bucket 与其事务上下文连接。
    buckets  map[string]*Bucket     // 子 bucket 缓存；允许通过名字快速访问子 bucket。
    page     *common.Page           // 内联页面的引用，用于直接存储少量数据或作为数据节点的入口点。
    rootNode *node                  // 根页面的已实例化节点，如果 bucket 直接存储在内存中，则此节点将被激活。
    nodes    map[common.Pgid]*node  // 节点缓存，用于快速访问已加载的页面节点，避免重复读取磁盘。

    // 设置节点分裂时的填充阈值。默认情况下，bucket 将填充至 50%，
    // 但如果你知道你的写入工作负载主要是追加操作，提高这个比例可能会有用。
    //
    // 这个设置不会跨事务持久化，因此每个事务都必须设置它。
    FillPercent float64
}

type InBucket struct {
    root     Pgid   // bucket 根级页面的页面ID。如果 bucket 是内联的，则此值为 0。
    sequence uint64 // 单调递增的序列号，用于 NextSequence() 函数。
}
</code></pre><p>Bucket 有可能是 node，也可能是 page。查找某页面的键值对时，首先检查 Bucket.nodes 缓存是否有对应的 node，如果没有，再从 page 中查找。
Bucket.FillPercent 记录 node 的填充百分比。当 node 的已用空间超过其容量的某个百分比后，节点必须分裂，以减少在 B+ Tree 中插入键值对时触发再平衡的概率。默认值是 50%，仅当大量写入操作在尾部添加时，增大该值才有帮助。</p><p>bucket 存储方式：</p><p><img class=img-zoomable src=/images/04c8dda1-ff6f-4ae5-9162-bf31819e9a9c.png alt></p><h3 id=遍历-cursor>遍历 cursor</h3><pre><code class=language-go>type Cursor struct {
    bucket *Bucket  
    stack  []elemRef 
}

type elemRef struct {
    page  *common.Page
    node  *node        
    index int    
}
</code></pre><p>cursor 分为三类，定位到某一个元素的位置、在当前位置从前往后找、在当前位置从后往前找。方法为：First、Last、Next、Prev 等。</p><h4 id=seek>Seek</h4><p>如果该键存在，它会返回该键及其对应的值；如果键不存在，它则返回最近的后续键。</p><pre><code class=language-go>// Seek 方法使用B树搜索将光标移动到给定的键并返回它。
// 如果键不存在，则使用下一个键。如果没有更多的键，返回nil。
// 返回的键和值只在事务的生命周期内有效。
func (c *Cursor) Seek(seek []byte) (key []byte, value []byte) {
    // 确保数据库事务没有关闭
    common.Assert(c.bucket.tx.db != nil, &quot;tx closed&quot;)

    // 调用内部的seek方法，获取键和值
    k, v, flags := c.seek(seek)

    // 检查是否位于页面的最后一个元素之后，如果是，则移动到下一个元素。
    if ref := &amp;c.stack[len(c.stack)-1]; ref.index &gt;= ref.count() {
        k, v, flags = c.next()
    }

    // 如果k为nil，表示未找到键，返回nil。
    if k == nil {
        return nil, nil
    } else if (flags &amp; uint32(common.BucketLeafFlag)) != 0 {
        // 如果是叶子节点，返回键和nil值。
        return k, nil
    }
    // 返回找到的键和值。
    return k, v
}

// seek 方法将光标移动到给定的键，并返回该键。
// 如果键不存在，则使用下一个键。
func (c *Cursor) seek(seek []byte) (key []byte, value []byte, flags uint32) {
    // 从根页面/节点开始，遍历到正确的页面。
    c.stack = c.stack[:0]
    c.search(seek, c.bucket.RootPage())

    // 如果是桶，则返回nil值。
    return c.keyValue()
}
</code></pre><p>search</p><pre><code class=language-go>// search 方法递归地对给定的页面/节点进行二分搜索，直到找到给定的键。
func (c *Cursor) search(key []byte, pgId common.Pgid) {
    p, n := c.bucket.pageNode(pgId)
    if p != nil &amp;&amp; !p.IsBranchPage() &amp;&amp; !p.IsLeafPage() {
        panic(fmt.Sprintf(&quot;invalid page type: %d: %x&quot;, p.Id(), p.Flags()))
    }
    e := elemRef{page: p, node: n}
    c.stack = append(c.stack, e)

    // 如果我们位于叶节点页面上，则在该页面内部继续查找特定节点。
    if e.isLeaf() {
        c.nsearch(key)
        return
    }

    // 如果是节点，继续在节点内部搜索。
    if n != nil {
        c.searchNode(key, n)
        return
    }
    // 如果是页面，继续在页面内部搜索。
    c.searchPage(key, p)
}

func (c *Cursor) searchNode(key []byte, n *node) {
    var exact bool
    // 使用二分搜索确定键的位置。
    index := sort.Search(len(n.inodes), func(i int) bool {
        ret := bytes.Compare(n.inodes[i].Key(), key)
        if ret == 0 {
            exact = true
        }
        return ret != -1
    })
    if !exact &amp;&amp; index &gt; 0 {
        index--
    }
    c.stack[len(c.stack)-1].index = index

    // 递归搜索到下一页。
    c.search(key, n.inodes[index].Pgid())
}

func (c *Cursor) searchPage(key []byte, p *common.Page) {
    // 对页面进行二分搜索以确定正确的范围。
    inodes := p.BranchPageElements()

    var exact bool
    index := sort.Search(int(p.Count()), func(i int) bool {
        ret := bytes.Compare(inodes[i].Key(), key)
        if ret == 0 {
            exact = true
        }
        return ret != -1
    })
    if !exact &amp;&amp; index &gt; 0 {
        index--
    }
    c.stack[len(c.stack)-1].index = index

    // 递归搜索到下一页。
    c.search(key, inodes[index].Pgid())
}

func (c *Cursor) nsearch(key []byte) {
	e := &amp;c.stack[len(c.stack)-1]
	p, n := e.page, e.node

	// If we have a node then search its inodes.
	if n != nil {
		index := sort.Search(len(n.inodes), func(i int) bool {
			return bytes.Compare(n.inodes[i].Key(), key) != -1
		})
		e.index = index
		return
	}

	// If we have a page then search its leaf elements.
	inodes := p.LeafPageElements()
	index := sort.Search(int(p.Count()), func(i int) bool {
		return bytes.Compare(inodes[i].Key(), key) != -1
	})
	e.index = index
}
</code></pre><p>keyValue</p><pre><code class=language-go>func (c *Cursor) keyValue() ([]byte, []byte, uint32) {
	ref := &amp;c.stack[len(c.stack)-1]

	// 如果索引超出范围，则返回nil。
	if ref.count() == 0 || ref.index &gt;= ref.count() {
		return nil, nil, 0
	}

	//  从node中获取键值对。
	if ref.node != nil {
		inode := &amp;ref.node.inodes[ref.index]
		return inode.Key(), inode.Value(), inode.Flags()
	}

	// 从 page 中获取键值对。
	elem := ref.page.LeafPageElement(uint16(ref.index))
	return elem.Key(), elem.Value(), elem.Flags()
}

</code></pre><h3 id=创建-bucket-如果不存在>创建 bucket 如果不存在</h3><pre><code class=language-go>// CreateBucketIfNotExists 如果指定的存储桶不存在，则创建它，并返回一个对它的引用。
// 如果存储桶名为空或太长，则返回错误。
// 存储桶实例仅在事务的生命周期内有效。
func (b *Bucket) CreateBucketIfNotExists(key []byte) (rb *Bucket, err error) {
    // 如果日志不是被丢弃，记录创建存储桶的尝试。
    if lg := b.tx.db.Logger(); lg != discardLogger {
        lg.Debugf(&quot;Creating bucket if not exist %q&quot;, key)
        defer func() {
            if err != nil {
                lg.Errorf(&quot;Creating bucket if not exist %q failed: %v&quot;, key, err)
            } else {
                lg.Debugf(&quot;Creating bucket if not exist %q successfully&quot;, key)
            }
        }()
    }

    // 检查数据库是否关闭，检查事务是否可写，检查键名是否为空。
    if b.tx.db == nil {
        return nil, errors.ErrTxClosed
    } else if !b.tx.writable {
        return nil, errors.ErrTxNotWritable
    } else if len(key) == 0 {
        return nil, errors.ErrBucketNameRequired
    }

    // 使用克隆的键而不是原始键，以避免内存泄漏。
    newKey := cloneBytes(key)

    // 检查键是否已存在。
    if b.buckets != nil {
        if child := b.buckets[string(newKey)]; child != nil {
            return child, nil
        }
    }

    // 使用光标寻找正确的位置。
    c := b.Cursor()
    k, v, flags := c.seek(newKey)

    // 如果找到的键相同，检查是否已有相同名字的非存储桶键。
    if bytes.Equal(newKey, k) {
        if (flags &amp; common.BucketLeafFlag) != 0 {
            var child = b.openBucket(v)
            if b.buckets != nil {
                b.buckets[string(newKey)] = child
            }
            return child, nil
        }
        return nil, errors.ErrIncompatibleValue
    }

    // 创建空的内联存储桶。
    var bucket = Bucket{
        InBucket:    &amp;common.InBucket{},
        rootNode:    &amp;node{isLeaf: true},
        FillPercent: DefaultFillPercent,
    }
    var value = bucket.write()

    // 在当前节点上插入键、值、标志。
    c.node().put(newKey, newKey, value, 0, common.BucketLeafFlag)

    // 如果存在内联页面，取消引用它，使得存储桶被视为常规非内联存储桶。
    b.page = nil

    // 返回新创建的存储桶。
    return b.Bucket(newKey), nil
}
</code></pre><pre><code class=language-go>// node方法返回光标当前定位的节点。
func (c *Cursor) node() *node {
    // 确保光标栈长度大于0，否则抛出异常。
    common.Assert(len(c.stack) &gt; 0, &quot;accessing a node with a zero-length cursor stack&quot;)

    // 如果栈顶是叶子节点，直接返回该节点。
    if ref := &amp;c.stack[len(c.stack)-1]; ref.node != nil &amp;&amp; ref.isLeaf() {
        return ref.node
    }

    // 从根开始，向下遍历层级结构。
    var n = c.stack[0].node
    if n == nil {
        n = c.bucket.node(c.stack[0].page.Id(), nil)
    }
    for _, ref := range c.stack[:len(c.stack)-1] {
        common.Assert(!n.isLeaf, &quot;expected branch node&quot;)
        n = n.childAt(ref.index)
    }
    common.Assert(n.isLeaf, &quot;expected leaf node&quot;)
    return n
}
// put方法在节点中插入键值对。
func (n *node) put(oldKey, newKey, value []byte, pgId common.Pgid, flags uint32) {
    // 检查pgId是否超出限制。
    if pgId &gt;= n.bucket.tx.meta.Pgid() {
        panic(fmt.Sprintf(&quot;pgId (%d) above high water mark (%d)&quot;, pgId, n.bucket.tx.meta.Pgid()))
    } else if len(oldKey) &lt;= 0 {
        panic(&quot;put: zero-length old key&quot;)
    } else if len(newKey) &lt;= 0 {
        panic(&quot;put: zero-length new key&quot;)
    }

    // 寻找插入的位置。
    index := sort.Search(len(n.inodes), func(i int) bool { return bytes.Compare(n.inodes[i].Key(), oldKey) != -1 })

    // 如果没有找到确切匹配，增加容量并移动节点。
    exact := len(n.inodes) &gt; 0 &amp;&amp; index &lt; len(n.inodes) &amp;&amp; bytes.Equal(n.inodes[index].Key(), oldKey)
    if !exact {
        n.inodes = append(n.inodes, common.Inode{})
        copy(n.inodes[index+1:], n.inodes[index:])
    }

    // 设置inode的属性。
    inode := &amp;n.inodes[index]
    inode.SetFlags(flags)
    inode.SetKey(newKey)
    inode.SetValue(value)
    inode.SetPgid(pgId)
    common.Assert(len(inode.Key()) &gt; 0, &quot;put: zero-length inode key&quot;)
}
// Bucket方法通过名称检索嵌套桶。
// 如果桶不存在，返回nil。
// 返回的桶实例只在事务生命周期内有效。
func (b *Bucket) Bucket(name []byte) *Bucket {
    // 如果已有桶缓存，则直接返回对应桶。
    if b.buckets != nil {
        if child := b.buckets[string(name)]; child != nil {
            return child
        }
    }

    // 移动光标到键位置。
    c := b.Cursor()
    k, v, flags := c.seek(name)

    // 如果键不存在或者不是桶标志，则返回nil。
    if !bytes.Equal(name, k) || (flags &amp; common.BucketLeafFlag) == 0 {
        return nil
    }

    // 否则创建并缓存桶。
    var child = b.openBucket(v)
    if b.buckets != nil {
        b.buckets[string(name)] = child
    }

    return child
}

</code></pre><h3 id=插入-keyvalue>插入 key/value</h3><pre><code class=language-go>func (b *Bucket) Put(key []byte, value []byte) (err error) {
	if lg := b.tx.db.Logger(); lg != discardLogger {
		lg.Debugf(&quot;Putting key %q&quot;, key)
		defer func() {
			if err != nil {
				lg.Errorf(&quot;Putting key %q failed: %v&quot;, key, err)
			} else {
				lg.Debugf(&quot;Putting key %q successfully&quot;, key)
			}
		}()
	}
	if b.tx.db == nil {
		return errors.ErrTxClosed
	} else if !b.Writable() {
		return errors.ErrTxNotWritable
	} else if len(key) == 0 {
		return errors.ErrKeyRequired
	} else if len(key) &gt; MaxKeySize {
		return errors.ErrKeyTooLarge
	} else if int64(len(value)) &gt; MaxValueSize {
		return errors.ErrValueTooLarge
	}

	newKey := cloneBytes(key)

	// 移动光标到键位置。
	c := b.Cursor()
	k, _, flags := c.seek(newKey)

	// Return an error if there is an existing key with a bucket value.
	if bytes.Equal(newKey, k) &amp;&amp; (flags&amp;common.BucketLeafFlag) != 0 {
		return errors.ErrIncompatibleValue
	}

	// gofail: var beforeBucketPut struct{}

	c.node().put(newKey, newKey, value, 0, 0)

	return nil
}
</code></pre><h2 id=事务>事务</h2><p>BoltDB 支持 ACID 事务，并采用了使用读写锁机制，支持多个读操作与一个写操作并发执行，让应用程序可以更简单的处理复杂操作。每个事务都有一个 txid，其中db.meta.txid 保存了最大的已提交的写事务 id。BoltDB 对写事务和读事务执行不同的 id 分配策略：</p><ol><li>读事务：txid == db.meta.txid；</li><li>写事务：txid == db.meta.txid + 1；</li><li>当写事务成功提交时，会更新了db.meta.txid为当前写事务 id。</li></ol><p>数据库初始化时会将页号为 0 和 1 的两个页面设置为meta页，每个事务会获得一个txid，并选取txid % 2的meta页做为该事务的读取对象，每次写数据后会交替更新meta页。当其中一个出现数据校验不一致时会使用另一个meta页。
BoltDB 的写操作都是在内存中进行，若事务未 commit 时出错，不会对数据库造成影响；若是在 commit 的过程中出错，BoltDB 写入文件的顺序也保证了不会造成影响：因为数据会写在新的 page 中不会覆盖原来的数据，且此时 meta中的信息不发生变化。</p><ol><li>开始一份写事务时，会拷贝一份 meta数据；</li><li>从 rootBucket 开始，遍历 B+ Tree 查找数据位置并修改；</li><li>修改操作完成后会进行事务 commit，此时会将数据写入新的 page；</li><li>最后更新meta的信息。</li></ol><pre><code class=language-go>// Tx 代表数据库上的一个只读或读写事务。
// 只读事务可用于检索键值和创建光标。
// 读写事务可以创建和删除桶以及创建和删除键。
//
// 重要：必须在使用完事务后提交或回滚事务。
// 只有当没有事务在使用页面时，写入者才能回收这些页面。
// 长时间运行的读事务可能会导致数据库迅速增长。
type Tx struct {
	writable       bool           // 是否为可写事务
	managed        bool           // 是否为管理事务
	db             *DB            // 关联的数据库实例
	meta           *common.Meta   // 元数据指针
	root           Bucket         // 根桶
	pages          map[common.Pgid]*common.Page // 页面映射
	stats          TxStats        // 事务统计
	commitHandlers []func()       // 提交处理程序列表

	// WriteFlag 指定写相关方法（如 WriteTo()）的标志。
	// Tx 使用指定的标志打开数据库文件以复制数据。
	//
	// 默认情况下，此标志未设置，适合主要在内存中的工作负载。
	// 对于大于可用 RAM 的数据库，可以设置为 syscall.O_DIRECT 来避免淘汰页面缓存。
	WriteFlag int
}
</code></pre><h3 id=begin>Begin</h3><pre><code class=language-go>// Begin 开始一个新事务。
// 多个只读事务可以并发使用，但一次只能使用一个写事务。
// 启动多个写事务会导致调用阻塞，并序列化直到当前写事务完成。
//
// 事务不应该彼此依赖。在同一个goroutine中打开一个读事务和一个写事务可能会导致写入者死锁，
// 因为数据库需要定期重新映射自身以应对增长，并且在读事务打开的时候无法进行。
//
// 如果需要长时间运行的读事务（例如，快照事务），你可能想要将DB.InitialMmapSize设置为足够大的值
// 以避免写事务的潜在阻塞。
//
// 重要：你必须在完成后关闭只读事务，否则数据库将无法回收旧页面。
func (db *DB) Begin(writable bool) (t *Tx, err error) {
	if lg := db.Logger(); lg != discardLogger {
		lg.Debugf(&quot;Starting a new transaction [writable: %t]&quot;, writable)
		defer func() {
			if err != nil {
				lg.Errorf(&quot;Starting a new transaction [writable: %t] failed: %v&quot;, writable, err)
			} else {
				lg.Debugf(&quot;Starting a new transaction [writable: %t] successfully&quot;, writable)
			}
		}()
	}

	if writable {
		return db.beginRWTx()
	}
	return db.beginTx()
}
</code></pre><pre><code class=language-go>func (db *DB) beginRWTx() (*Tx, error) {
	// If the database was opened with Options.ReadOnly, return an error.
	if db.readOnly {
		return nil, berrors.ErrDatabaseReadOnly
	}

	// Obtain writer lock. This is released by the transaction when it closes.
	// This enforces only one writer transaction at a time.
	db.rwlock.Lock()

	// Once we have the writer lock then we can lock the meta pages so that
	// we can set up the transaction.
	db.metalock.Lock()
	defer db.metalock.Unlock()

	// Exit if the database is not open yet.
	if !db.opened {
		db.rwlock.Unlock()
		return nil, berrors.ErrDatabaseNotOpen
	}

	// Exit if the database is not correctly mapped.
	if db.data == nil {
		db.rwlock.Unlock()
		return nil, berrors.ErrInvalidMapping
	}

	// Create a transaction associated with the database.
	t := &amp;Tx{writable: true}
	t.init(db)
	db.rwtx = t
	db.freePages()
	return t, nil
}

// freePages 释放与已关闭的只读事务关联的任何页面。
func (db *DB) freePages() {
	sort.Sort(txsById(db.txs))
	minid := common.Txid(0xFFFFFFFFFFFFFFFF)
	if len(db.txs) &gt; 0 {
		minid = db.txs[0].meta.Txid()
	}
	if minid &gt; 0 {
		db.freelist.release(minid - 1)
	}
	for _, t := range db.txs {
		db.freelist.releaseRange(minid, t.meta.Txid()-1)
		minid = t.meta.Txid() + 1
	}
	db.freelist.releaseRange(minid, common.Txid(0xFFFFFFFFFFFFFFFF))
}

</code></pre><pre><code class=language-go>func (db *DB) beginTx() (*Tx, error) {
	// Lock the meta pages while we initialize the transaction. We obtain
	// the meta lock before the mmap lock because that's the order that the
	// write transaction will obtain them.
	db.metalock.Lock()

	// Obtain a read-only lock on the mmap. When the mmap is remapped it will
	// obtain a write lock so all transactions must finish before it can be
	// remapped.
	db.mmaplock.RLock()

	// Exit if the database is not open yet.
	if !db.opened {
		db.mmaplock.RUnlock()
		db.metalock.Unlock()
		return nil, berrors.ErrDatabaseNotOpen
	}

	// Exit if the database is not correctly mapped.
	if db.data == nil {
		db.mmaplock.RUnlock()
		db.metalock.Unlock()
		return nil, berrors.ErrInvalidMapping
	}

	// Create a transaction associated with the database.
	t := &amp;Tx{}
	t.init(db)

	// Keep track of transaction until it closes.
	db.txs = append(db.txs, t)
	n := len(db.txs)

	// Unlock the meta pages.
	db.metalock.Unlock()

	// Update the transaction stats.
	db.statlock.Lock()
	db.stats.TxN++
	db.stats.OpenTxN = n
	db.statlock.Unlock()

	return t, nil
}
</code></pre><h3 id=commit>Commit</h3><pre><code class=language-go>// Commit 将所有更改写入磁盘，更新元数据页，并关闭事务。
// 如果磁盘写入发生错误，或者在只读事务上调用Commit，将返回错误。
func (tx *Tx) Commit() (err error) {
    txId := tx.ID()  // 获取事务ID
    lg := tx.db.Logger()  // 获取日志记录器
    if lg != discardLogger {
        lg.Debugf(&quot;Committing transaction %d&quot;, txId)
        defer func() {
            if err != nil {
                lg.Errorf(&quot;Committing transaction failed: %v&quot;, err)
            } else {
                lg.Debugf(&quot;Committing transaction %d successfully&quot;, txId)
            }
        }()
    }

    // 检查是否为管理事务，不允许提交。
    common.Assert(!tx.managed, &quot;managed tx commit not allowed&quot;)
    if tx.db == nil {
        return berrors.ErrTxClosed  // 事务已关闭错误
    } else if !tx.writable {
        return berrors.ErrTxNotWritable  // 非写事务错误
    }

    // TODO: 使用向量化I/O写出脏页

    // 重新平衡删除后的节点
    var startTime = time.Now()
    tx.root.rebalance()
    if tx.stats.GetRebalance() &gt; 0 {
        tx.stats.IncRebalanceTime(time.Since(startTime))
    }

    opgid := tx.meta.Pgid()  // 获取旧的页面ID

    // 将数据溢出到脏页
    startTime = time.Now()
    if err = tx.root.spill(); err != nil {
        lg.Errorf(&quot;spilling data onto dirty pages failed: %v&quot;, err)
        tx.rollback()
        return err
    }
    tx.stats.IncSpillTime(time.Since(startTime))

    // 释放旧的根桶
    tx.meta.RootBucket().SetRootPage(tx.root.RootPage())

    // 释放旧的自由列表，因为提交会写出一个新的自由列表
    if tx.meta.Freelist() != common.PgidNoFreelist {
        tx.db.freelist.free(tx.meta.Txid(), tx.db.page(tx.meta.Freelist()))
    }

    if !tx.db.NoFreelistSync {
        err = tx.commitFreelist()
        if err != nil {
            lg.Errorf(&quot;committing freelist failed: %v&quot;, err)
            return err
        }
    } else {
        tx.meta.SetFreelist(common.PgidNoFreelist)
    }

    // 如果高水位标记已上移，则尝试扩大数据库
    if tx.meta.Pgid() &gt; opgid {
        if err = tx.db.grow(int(tx.meta.Pgid()+1) * tx.db.pageSize); err != nil {
            lg.Errorf(&quot;growing db size failed, pgid: %d, pagesize: %d, error: %v&quot;, tx.meta.Pgid(), tx.db.pageSize, err)
            tx.rollback()
            return err
        }
    }

    // 将脏页写入磁盘
    startTime = time.Now()
    if err = tx.write(); err != nil {
        lg.Errorf(&quot;writing data failed: %v&quot;, err)
        tx.rollback()
        return err
    }

    // 如果启用了严格模式，则执行一致性检查
    if tx.db.StrictMode {
        ch := tx.Check()
        var errs []string
        for {
            chkErr, ok := &lt;-ch
            if !ok {
                break
            }
            errs = append(errs, chkErr.Error())
        }
        if len(errs) &gt; 0 {
            panic(&quot;check fail: &quot; + strings.Join(errs, &quot;\n&quot;))
        }
    }

    // 将元数据写入磁盘
    if err = tx.writeMeta(); err != nil {
        lg.Errorf(&quot;writeMeta failed: %v&quot;, err)
        tx.rollback()
        return err
    }
    tx.stats.IncWriteTime(time.Since(startTime))

    // 结束事务
    tx.close()

    // 执行提交处理程序，锁已经移除
    for _, fn := range tx.commitHandlers {
        fn()
    }

    return nil
}
</code></pre><h3 id=rollback>Rollback</h3><pre><code class=language-go>// Rollback 关闭事务并忽略所有之前的更新。
// 只读事务必须回滚而不是提交。
func (tx *Tx) Rollback() error {
    common.Assert(!tx.managed, &quot;managed tx rollback not allowed&quot;)  // 断言此事务不是管理型事务
    if tx.db == nil {
        return berrors.ErrTxClosed  // 如果数据库已关闭，返回错误
    }
    tx.nonPhysicalRollback()  // 执行非物理性回滚
    return nil
}

// nonPhysicalRollback 在用户直接调用Rollback时被调用，在这种情况下，我们不需要从磁盘重新加载自由页面。
func (tx *Tx) nonPhysicalRollback() {
    if tx.db == nil {
        return  // 如果数据库已关闭，直接返回
    }
    if tx.writable {
        tx.db.freelist.rollback(tx.meta.Txid())  // 如果事务是可写的，回滚自由列表
    }
    tx.close()  // 关闭事务
}

// rollback 从给定的挂起事务中移除页面。
func (f *freelist) rollback(txid common.Txid) {
    // 从缓存中移除页面ID。
    txp := f.pending[txid]
    if txp == nil {
        return  // 如果没有挂起的事务，直接返回
    }
    var m common.Pgids
    for i, pgid := range txp.ids {
        delete(f.cache, pgid)  // 从缓存中删除页面ID
        tx := txp.alloctx[i]
        if tx == 0 {
            continue  // 如果未分配事务ID，继续下一个
        }
        if tx != txid {
            // 如果待释放页面被中断，恢复页面回分配列表。
            f.allocs[pgid] = tx
        } else {
            // 如果释放的页面由此事务分配，可以安全地丢弃。
            m = append(m, pgid)
        }
    }
    // 从挂起列表中移除页面，并将其标记为由txid分配的自由页面。
    delete(f.pending, txid)
    f.mergeSpans(m)
}
</code></pre><h2 id=view--update>View && Update</h2><pre><code class=language-go>// View 在管理的只读事务上下文中执行一个函数。
// 从函数返回的任何错误都会从View()方法返回。
//
// 尝试在函数内手动回滚会导致panic。
func (db *DB) View(fn func(*Tx) error) error {
    t, err := db.Begin(false)  // 开始一个只读事务
    if err != nil {
        return err  // 如果无法开始事务，返回错误
    }

    // 确保在发生panic的情况下事务能够回滚。
    defer func() {
        if t.db != nil {
            t.rollback()  // 执行回滚操作
        }
    }()

    // 标记为管理的事务，以便内部函数不能手动回滚。
    t.managed = true

    // 如果函数返回错误，则传递该错误。
    err = fn(t)
    t.managed = false
    if err != nil {
        _ = t.Rollback()  // 执行回滚
        return err
    }

    return t.Rollback()  // 完成后回滚事务
}

// Update 在读写管理事务的上下文中执行一个函数。
// 如果函数没有返回错误，则提交事务。
// 如果返回了错误，则整个事务被回滚。
// 从函数返回的任何错误或从提交返回的错误都会从Update()方法返回。
//
// 尝试在函数内手动提交或回滚将导致panic。
func (db *DB) Update(fn func(*Tx) error) error {
    t, err := db.Begin(true)  // 开始一个读写事务
    if err != nil {
        return err  // 如果无法开始事务，返回错误
    }

    // 确保在发生panic的情况下事务能够回滚。
    defer func() {
        if t.db != nil {
            t.rollback()  // 执行回滚操作
        }
    }()

    // 标记为管理的事务，以便内部函数不能手动提交。
    t.managed = true

    // 如果函数返回错误，则回滚并返回错误。
    err = fn(t)
    t.managed = false
    if err != nil {
        _ = t.Rollback()  // 执行回滚
        return err
    }

    return t.Commit()  // 无错误时提交事务
}
</code></pre><h2 id=reference>Reference</h2><ul><li><a href=https://wingsxdu.com/posts/database/boltdb/ target=_blank>https://wingsxdu.com/posts/database/boltdb/</a></li><li><a href=https://jaydenwen123.github.io/boltdb/ target=_blank>https://jaydenwen123.github.io/boltdb/</a></li><li><a href=https://youjiali1995.github.io/storage/boltdb/ target=_blank>https://youjiali1995.github.io/storage/boltdb/</a></li><li><a href=https://www.cnblogs.com/huxiao-tee/p/4660352.html target=_blank>https://www.cnblogs.com/huxiao-tee/p/4660352.html</a></li></ul></div></article><div class="license markdown-body"><blockquote><p>Unless otherwise noted, the content of this site is licensed under <a rel=license href=http://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank>CC BY-NC-SA 4.0</a>.</p></blockquote></div><div class=post-comment data-comment=utterances><span class=post-comment-notloaded><i class="iconfont icon-chatbox-ellipses-sharp"></i>&nbsp;Load comments
</span><script>function loadComment(){var e,n=document.querySelector(".post-comment"),t=document.body.getAttribute("data-theme");t==="auto"?t=window.matchMedia("(prefers-color-scheme: dark)").matches?"photon-dark":"github-light":t=t==="dark"?"photon-dark":"github-light",e=document.createElement("script"),e.src="https://utteranc.es/client.js",e.setAttribute("repo","daemon365/daemon365.github.io"),e.setAttribute("issue-term","pathname"),e.setAttribute("theme",t),e.setAttribute("crossorigin","anonymous"),e.setAttribute("async",""),document.querySelector(".post-comment").appendChild(e),document.querySelector("span.post-comment-notloaded").setAttribute("style","display: none;")}</script></div></div><aside class="col-12 col-md-3 float-left sidebar"><div class="sidebar-item sidebar-pages"><h3>Pages</h3><ul><li><a href=/>Home</a></li><li><a href=/archives/>Archives</a></li><li><a href=/index.xml>RSS</a></li><li><a href=/about/>About</a></li><li><a href=/search/>Search</a></li></ul></div><div class="sidebar-item sidebar-links"><h3>Links</h3><ul><li><a href=https://github.com/daemon365 target=_blank><span>My GitHub</span></a></li></ul></div><div class="sidebar-item sidebar-tags"><h3>Tags</h3><div><span><a href=/tags/bbr/>BBR</a>
</span><span><a href=/tags/boltdb/>Boltdb</a>
</span><span><a href=/tags/breaker/>Breaker</a>
</span><span><a href=/tags/cdi/>Cdi</a>
</span><span><a href=/tags/cgroup/>Cgroup</a>
</span><span><a href=/tags/client-go/>Client-Go</a>
</span><span><a href=/tags/cni/>Cni</a>
</span><span><a href=/tags/containerd/>Containerd</a>
</span><span><a href=/tags/containerd-shim/>Containerd-Shim</a>
</span><span><a href=/tags/cri/>Cri</a>
</span><span><a href=/tags/csi/>Csi</a>
</span><span><a href=/tags/docker/>Docker</a>
</span><span><a href=/tags/etcd/>Etcd</a>
</span><span><a href=/tags/gin/>Gin</a>
</span><span><a href=/tags/go/>Go</a>
</span><span><a href=/tags/golang/>Golang</a>
</span><span><a href=/tags/grpc/>Grpc</a>
</span><span><a href=/tags/iptables/>Iptables</a>
</span><span><a href=/tags/ipvs/>Ipvs</a>
</span><span><a href=/tags/istio/>Istio</a>
</span><span><a href=/tags/kratos/>Kratos</a>
</span><span><a href=/tags/kube-proxy/>Kube-Proxy</a>
</span><span><a href=/tags/kubelet/>Kubelet</a>
</span><span><a href=/tags/kubernetes/>Kubernetes</a>
</span><span><a href=/tags/linux/>Linux</a>
</span><span><a href=/tags/lua/>Lua</a>
</span><span><a href=/tags/makefile/>Makefile</a>
</span><span><a href=/tags/mysql/>Mysql</a>
</span><span><a href=/tags/namespace/>Namespace</a>
</span><span><a href=/tags/network/>Network</a>
</span><span><a href=/tags/nginx/>Nginx</a>
</span><span><a href=/tags/opentelemetry/>Opentelemetry</a>
</span><span><a href=/tags/prometheus/>Prometheus</a>
</span><span><a href=/tags/protobuf/>Protobuf</a>
</span><span><a href=/tags/rabbitmq/>RabbitMQ</a>
</span><span><a href=/tags/redis/>Redis</a>
</span><span><a href=/tags/runc/>Runc</a>
</span><span><a href=/tags/service-mesh/>Service Mesh</a>
</span><span><a href=/tags/sidecar/>Sidecar</a>
</span><span><a href=/tags/sqlx/>Sqlx</a>
</span><span><a href=/tags/thrift/>Thrift</a>
</span><span><a href=/tags/unionfs/>UnionFS</a>
</span><span><a href=/tags/viper/>Viper</a>
</span><span><a href=/tags/vscode/>Vscode</a>
</span><span><a href=/tags/wire/>Wire</a>
</span><span><a href=/tags/zap/>Zap</a>
</span><span><a href=/tags/%E4%BA%8B%E5%8A%A1/>事务</a>
</span><span><a href=/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/>数据库</a>
</span><span><a href=/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/>源码分析</a>
</span><span><a href=/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>设计模式</a></span></div></div><div class="sidebar-item sidebar-toc"><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#简介>简介</a></li><li><a href=#page>page</a><ul><li><a href=#branchpage--leafpage>BranchPage && LeafPage</a></li><li><a href=#metapage>MetaPage</a></li><li><a href=#freelistpage>FreelistPage</a></li></ul></li><li><a href=#node>Node</a><ul><li><a href=#page-to-node>page to node</a></li><li><a href=#node-to-page>node to page</a></li></ul></li><li><a href=#bucket>Bucket</a><ul><li><a href=#遍历-cursor>遍历 cursor</a></li><li><a href=#创建-bucket-如果不存在>创建 bucket 如果不存在</a></li><li><a href=#插入-keyvalue>插入 key/value</a></li></ul></li><li><a href=#事务>事务</a><ul><li><a href=#begin>Begin</a></li><li><a href=#commit>Commit</a></li><li><a href=#rollback>Rollback</a></li></ul></li><li><a href=#view--update>View && Update</a></li><li><a href=#reference>Reference</a></li></ul></nav></div></aside></div><div class=btn><div class=btn-menu id=btn-menu><i class="iconfont icon-grid-sharp"></i></div><div class=btn-toggle-mode><i class="iconfont icon-contrast-sharp"></i></div><div class=btn-scroll-top><i class="iconfont icon-chevron-up-circle-sharp"></i></div></div><aside class=sidebar-mobile style=display:none><div class=sidebar-wrapper><div class="sidebar-item sidebar-pages"><h3>Pages</h3><ul><li><a href=/>Home</a></li><li><a href=/archives/>Archives</a></li><li><a href=/index.xml>RSS</a></li><li><a href=/about/>About</a></li><li><a href=/search/>Search</a></li></ul></div><div class="sidebar-item sidebar-links"><h3>Links</h3><ul><li><a href=https://github.com/daemon365 target=_blank><span>My GitHub</span></a></li></ul></div><div class="sidebar-item sidebar-tags"><h3>Tags</h3><div><span><a href=/tags/bbr/>BBR</a>
</span><span><a href=/tags/boltdb/>Boltdb</a>
</span><span><a href=/tags/breaker/>Breaker</a>
</span><span><a href=/tags/cdi/>Cdi</a>
</span><span><a href=/tags/cgroup/>Cgroup</a>
</span><span><a href=/tags/client-go/>Client-Go</a>
</span><span><a href=/tags/cni/>Cni</a>
</span><span><a href=/tags/containerd/>Containerd</a>
</span><span><a href=/tags/containerd-shim/>Containerd-Shim</a>
</span><span><a href=/tags/cri/>Cri</a>
</span><span><a href=/tags/csi/>Csi</a>
</span><span><a href=/tags/docker/>Docker</a>
</span><span><a href=/tags/etcd/>Etcd</a>
</span><span><a href=/tags/gin/>Gin</a>
</span><span><a href=/tags/go/>Go</a>
</span><span><a href=/tags/golang/>Golang</a>
</span><span><a href=/tags/grpc/>Grpc</a>
</span><span><a href=/tags/iptables/>Iptables</a>
</span><span><a href=/tags/ipvs/>Ipvs</a>
</span><span><a href=/tags/istio/>Istio</a>
</span><span><a href=/tags/kratos/>Kratos</a>
</span><span><a href=/tags/kube-proxy/>Kube-Proxy</a>
</span><span><a href=/tags/kubelet/>Kubelet</a>
</span><span><a href=/tags/kubernetes/>Kubernetes</a>
</span><span><a href=/tags/linux/>Linux</a>
</span><span><a href=/tags/lua/>Lua</a>
</span><span><a href=/tags/makefile/>Makefile</a>
</span><span><a href=/tags/mysql/>Mysql</a>
</span><span><a href=/tags/namespace/>Namespace</a>
</span><span><a href=/tags/network/>Network</a>
</span><span><a href=/tags/nginx/>Nginx</a>
</span><span><a href=/tags/opentelemetry/>Opentelemetry</a>
</span><span><a href=/tags/prometheus/>Prometheus</a>
</span><span><a href=/tags/protobuf/>Protobuf</a>
</span><span><a href=/tags/rabbitmq/>RabbitMQ</a>
</span><span><a href=/tags/redis/>Redis</a>
</span><span><a href=/tags/runc/>Runc</a>
</span><span><a href=/tags/service-mesh/>Service Mesh</a>
</span><span><a href=/tags/sidecar/>Sidecar</a>
</span><span><a href=/tags/sqlx/>Sqlx</a>
</span><span><a href=/tags/thrift/>Thrift</a>
</span><span><a href=/tags/unionfs/>UnionFS</a>
</span><span><a href=/tags/viper/>Viper</a>
</span><span><a href=/tags/vscode/>Vscode</a>
</span><span><a href=/tags/wire/>Wire</a>
</span><span><a href=/tags/zap/>Zap</a>
</span><span><a href=/tags/%E4%BA%8B%E5%8A%A1/>事务</a>
</span><span><a href=/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/>数据库</a>
</span><span><a href=/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/>源码分析</a>
</span><span><a href=/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>设计模式</a></span></div></div><div class="sidebar-item sidebar-toc"><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#简介>简介</a></li><li><a href=#page>page</a><ul><li><a href=#branchpage--leafpage>BranchPage && LeafPage</a></li><li><a href=#metapage>MetaPage</a></li><li><a href=#freelistpage>FreelistPage</a></li></ul></li><li><a href=#node>Node</a><ul><li><a href=#page-to-node>page to node</a></li><li><a href=#node-to-page>node to page</a></li></ul></li><li><a href=#bucket>Bucket</a><ul><li><a href=#遍历-cursor>遍历 cursor</a></li><li><a href=#创建-bucket-如果不存在>创建 bucket 如果不存在</a></li><li><a href=#插入-keyvalue>插入 key/value</a></li></ul></li><li><a href=#事务>事务</a><ul><li><a href=#begin>Begin</a></li><li><a href=#commit>Commit</a></li><li><a href=#rollback>Rollback</a></li></ul></li><li><a href=#view--update>View && Update</a></li><li><a href=#reference>Reference</a></li></ul></nav></div></div></aside></main><footer><div class="container-lg clearfix"><div class="col-12 footer"><span>&copy; 2019-2024
<a href=https://daemon365.dev/>daemon365</a>
| Powered by <a href=https://github.com/dsrkafuu/hugo-theme-fuji/ target=_blank>Fuji-v2</a> & <a href=https://gohugo.io/ target=_blank>Hugo</a></span></div></div></footer><script defer src=https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js integrity="sha512-q583ppKrCRc7N5O0n2nzUiJ+suUv7Et1JGels4bXOaMFQcamPk9HjdUknZuuFjBNs7tsMuadge5k9RzdmO+1GQ==" crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1.27.0/components/prism-core.min.js integrity="sha512-LCKPTo0gtJ74zCNMbWw04ltmujpzSR4oW+fgN+Y1YclhM5ZrHCZQAJE4quEodcI/G122sRhSGU2BsSRUZ2Gu3w==" crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1.27.0/plugins/autoloader/prism-autoloader.min.js integrity="sha512-GP4x8UWxWyh4BMbyJGOGneiTbkrWEF5izsVJByzVLodP8CuJH/n936+yQDMJJrOPUHLgyPbLiGw2rXmdvGdXHA==" crossorigin=anonymous></script><script defer src=/assets/js/fuji.min.645f1123be695831f419ab54c1bcba327325895c740014006e57070d4f3e5d6b553e929c4b46f40ea707249e9c7f7c2a446d32a39ce7319f80a34525586a8e0f.js integrity="sha512-ZF8RI75pWDH0GatUwby6MnMliVx0ABQAblcHDU8+XWtVPpKcS0b0DqcHJJ6cf3wqRG0yo5znMZ+Ao0UlWGqODw=="></script></body></html>