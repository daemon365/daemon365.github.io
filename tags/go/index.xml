<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Go on Daemon</title><link>https://daemon365.dev/tags/go/</link><description>Recent content in Go on Daemon</description><generator>Hugo</generator><language>en</language><lastBuildDate>Mon, 25 Sep 2023 00:00:00 +0800</lastBuildDate><atom:link href="https://daemon365.dev/tags/go/index.xml" rel="self" type="application/rss+xml"/><item><title>行为模式</title><link>https://daemon365.dev/2023/09/25/%E8%A1%8C%E4%B8%BA%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 25 Sep 2023 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2023/09/25/%E8%A1%8C%E4%B8%BA%E6%A8%A1%E5%BC%8F/</guid><description>责任链模式 责任链模式是一种行为设计模式， 允许你将请求沿着处理者链进行发送。 收到请求后， 每个处理者均可对请求进行处理， 或将其传递给链上的下个处理者。比如 kratos,gin等开源库的中间件实现。 代码实现</description></item><item><title>结构型模式</title><link>https://daemon365.dev/2023/09/24/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/</link><pubDate>Sun, 24 Sep 2023 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2023/09/24/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/</guid><description>适配器模式 适配器模式用于转换一种接口适配另一种接口。比如，现在有个借口是对json字符串进行分析等，现在有一些yaml文件也要分析，这时候我我们就应该给yaml字符串就个适配器，转换成json字符串，</description></item><item><title>创建者模式</title><link>https://daemon365.dev/2023/09/23/%E5%88%9B%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F/</link><pubDate>Sat, 23 Sep 2023 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2023/09/23/%E5%88%9B%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F/</guid><description>单例模式 为什么要用单例模式 保证一个对象只有一个实例 ，减少内存开销。比如一些可以复用一个连接的网络，比如http2 client等，而且可以减少网络开销。 为什么不用个全局变量控制 因为任何代码都有可能覆盖掉</description></item><item><title>kratos http原理</title><link>https://daemon365.dev/2023/06/29/kratos-http%E5%8E%9F%E7%90%86/</link><pubDate>Thu, 29 Jun 2023 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2023/06/29/kratos-http%E5%8E%9F%E7%90%86/</guid><description>概念 kratos 为了使http协议的逻辑代码和grpc的逻辑代码使用同一份，选择了基于protobuf的IDL文件使用proto插件生成辅助代码的方式。 protoc http插件的地址为：https://github.co</description></item><item><title>隔离</title><link>https://daemon365.dev/2022/12/25/%E9%9A%94%E7%A6%BB/</link><pubDate>Sun, 25 Dec 2022 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2022/12/25/%E9%9A%94%E7%A6%BB/</guid><description>什么是隔离？ 隔离，本质上是对系统或资源进行分割，从而实现当系统发生故障时能限定传播范围和影响范围，即发生故障后只有出问题的服务不可用，保证其他服务仍然可用。 服务隔离 动静隔离 例如 CDN 小到 CPU 的 cacheline false shari</description></item><item><title>限流</title><link>https://daemon365.dev/2022/12/24/%E9%99%90%E6%B5%81/</link><pubDate>Sat, 24 Dec 2022 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2022/12/24/%E9%99%90%E6%B5%81/</guid><description>令牌桶算法 是一个存放固定容量令牌的桶，按照固定速率往桶里添加令牌。令牌桶算法的描述如下： 假设限制2r/s，则按照500毫秒的固定速率往桶中添加令牌。 桶中最多存放 b 个令牌，当桶满时，新添加的令牌被丢弃或</description></item><item><title>超时控制</title><link>https://daemon365.dev/2022/12/23/%E8%B6%85%E6%97%B6%E6%8E%A7%E5%88%B6/</link><pubDate>Fri, 23 Dec 2022 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2022/12/23/%E8%B6%85%E6%97%B6%E6%8E%A7%E5%88%B6/</guid><description>什么是超时控制？ 超时控制，使我们的服务之间调用可以快速抛错。比如API接口设置1s超时API调用A服务用了500ms，服务A调用和服务B用了600ms，n那么现在已经超时，还要调用服务C等等，再返回超</description></item><item><title>Go命令行工具cobra</title><link>https://daemon365.dev/2022/12/21/go%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7cobra/</link><pubDate>Wed, 21 Dec 2022 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2022/12/21/go%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7cobra/</guid><description>关于 Cobra 是 Go 的 CLI 框架。它包含一个用于创建功能强大的现代 CLI 应用程序的库，以及一个用于快速生成基于 Cobra 的应用程序和命令文件的工具。 Cobra 由 Go 项目成员和 hugo 作者 spf13 创建，已经被许多流行的 Go 项目采用，比如 kubernet</description></item><item><title>Go工程化 - 依赖注入</title><link>https://daemon365.dev/2021/09/30/go%E5%B7%A5%E7%A8%8B%E5%8C%96-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</link><pubDate>Thu, 30 Sep 2021 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2021/09/30/go%E5%B7%A5%E7%A8%8B%E5%8C%96-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</guid><description>我们在微服务框架kratos v2的默认项目模板中kratos-layout使用了google/wire进行依赖注入，也建议开发者在维护项目时使用该工具。 wire 乍看起来比较违反直觉，导致很多同学不理解为什么</description></item><item><title>kratos v2版本命令行工具使用</title><link>https://daemon365.dev/2021/09/12/kratos-v2%E7%89%88%E6%9C%AC%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/</link><pubDate>Sun, 12 Sep 2021 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2021/09/12/kratos-v2%E7%89%88%E6%9C%AC%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/</guid><description>使用 下载 go install github.com/go-kratos/kratos/cmd/kratos/v2@latest 查看是否安装成功 kratos -v kratos version v2.1.3 升级 kratos upgrade 查看帮助 kratos --help Kratos: An elegant toolkit for Go microservices. Usage: kratos [command] Available Commands: changelog Get a kratos change log completion generate the autocompletion script for the specified shell help Help about any command new Create a service template proto Generate the proto files run Run project upgrade Upgrade the kratos tools Flags: -h, --help help for kratos -v, --version version for kratos Use &amp;quot;kratos [command] --help&amp;quot; for more information about a</description></item><item><title>从kratos分析breaker熔断器源码实现</title><link>https://daemon365.dev/2021/09/04/%E4%BB%8Ekratos%E5%88%86%E6%9E%90breaker%E7%86%94%E6%96%AD%E5%99%A8%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0/</link><pubDate>Sat, 04 Sep 2021 17:55:01 +0800</pubDate><guid>https://daemon365.dev/2021/09/04/%E4%BB%8Ekratos%E5%88%86%E6%9E%90breaker%E7%86%94%E6%96%AD%E5%99%A8%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0/</guid><description>为什么要用熔断 前面我们讲过限流保证服务的可用性，不被突如其来的流量打爆。但是两种情况是限流解决不了的。 如果我们服务只能处理1000QPS，但是有10wQPS打过来，服务还是会炸。因为拒绝请求也需要成本</description></item><item><title>从kratos分析BBR限流源码实现</title><link>https://daemon365.dev/2021/09/04/%E4%BB%8Ekratos%E5%88%86%E6%9E%90bbr%E9%99%90%E6%B5%81%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0/</link><pubDate>Sat, 04 Sep 2021 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2021/09/04/%E4%BB%8Ekratos%E5%88%86%E6%9E%90bbr%E9%99%90%E6%B5%81%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0/</guid><description>什么是自适应限流 自适应限流从整体维度对应用入口流量进行控制，结合应用的 Load、CPU 使用率、总体平均 RT、入口 QPS 和并发线程数等几个维度的监控指标，通过自适应的流控策略，让系统的入口流量和系统的负载达</description></item><item><title>Kratos漫游指南 1 - 概览</title><link>https://daemon365.dev/2021/09/02/kratos%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%97-1-%E6%A6%82%E8%A7%88/</link><pubDate>Thu, 02 Sep 2021 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2021/09/02/kratos%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%97-1-%E6%A6%82%E8%A7%88/</guid><description>您好，地球人，欢迎来到Kratos漫游指南。 对于刚开始研究Kratos框架的开发者来说，目前的文档有些零散，这与我们的模块化设计有一些关系，不过Don&amp;rsquo;t panic，从这篇文章开始，我将试</description></item><item><title>基于 OpenTelemetry 的链路追踪</title><link>https://daemon365.dev/2021/08/23/%E5%9F%BA%E4%BA%8E-opentelemetry-%E7%9A%84%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/</link><pubDate>Mon, 23 Aug 2021 18:11:50 +0800</pubDate><guid>https://daemon365.dev/2021/08/23/%E5%9F%BA%E4%BA%8E-opentelemetry-%E7%9A%84%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/</guid><description>链路追踪的前世今生 分布式跟踪（也称为分布式请求跟踪）是一种用于分析和监控应用程序的方法，尤其是使用微服务架构构建的应用程序。分布式跟踪有助于精确定位故障发生的位置以及导致性能差的原因。 起源 链路追踪(D</description></item><item><title>通过 layout 探索 kratos 运行原理</title><link>https://daemon365.dev/2021/08/20/%E9%80%9A%E8%BF%87-layout-%E6%8E%A2%E7%B4%A2-kratos-%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/</link><pubDate>Fri, 20 Aug 2021 18:11:50 +0800</pubDate><guid>https://daemon365.dev/2021/08/20/%E9%80%9A%E8%BF%87-layout-%E6%8E%A2%E7%B4%A2-kratos-%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/</guid><description>创建项目 首先需要安装好对应的依赖环境，以及工具： go 下载 protoc go install google.golang.org/protobuf/cmd/protoc-gen-go@latest protoc-gen-go go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest # 创建项目模板 kratos new helloworld cd helloworld # 拉取项目依赖 go mod download # 生成proto模板 kratos proto add api/helloworld/helloworld.proto # 生成proto源码 kratos proto client api/helloworld/helloworld.proto # 生成server模板 kratos proto server api/helloworld/helloworld.proto</description></item><item><title>kratos 日志库的使用姿势</title><link>https://daemon365.dev/2021/08/19/kratos-%E6%97%A5%E5%BF%97%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/</link><pubDate>Thu, 19 Aug 2021 18:11:50 +0800</pubDate><guid>https://daemon365.dev/2021/08/19/kratos-%E6%97%A5%E5%BF%97%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/</guid><description>什么是日志 所谓日志（Log）是指系统所指定对象的某些操作和其操作结果按时间有序的集合。log文件就是日志文件，log文件记录了系统和系统的用户之间交互的信息，是自动捕获人与系统终端之间交互的类型、内容</description></item><item><title>golang map实现原理</title><link>https://daemon365.dev/2021/05/22/golang-map%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</link><pubDate>Sat, 22 May 2021 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2021/05/22/golang-map%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</guid><description>这篇文章主要讲 map 的赋值、删除、查询、扩容的具体执行过程，仍然是从底层的角度展开。结合源码，看完本文一定会彻底明白 map 底层原理。 我要说明的是，这里对 map 的基本用法涉及比较少，我相信可以通过阅读其他入门书籍了</description></item><item><title>zap高性能日志</title><link>https://daemon365.dev/2021/03/23/zap%E9%AB%98%E6%80%A7%E8%83%BD%E6%97%A5%E5%BF%97/</link><pubDate>Tue, 23 Mar 2021 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2021/03/23/zap%E9%AB%98%E6%80%A7%E8%83%BD%E6%97%A5%E5%BF%97/</guid><description>摘要 日志在整个工程实践中的重要性不言而喻，在选择日志组件的时候也有多方面的考量。详细、正确和及时的反馈是必不可少的，但是整个性能表现是否也是必要考虑的点呢？在长期的实践中发现有的日志组件对于计算资源的</description></item><item><title>golang channel原理</title><link>https://daemon365.dev/2021/02/21/golang-channel%E5%8E%9F%E7%90%86/</link><pubDate>Sun, 21 Feb 2021 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2021/02/21/golang-channel%E5%8E%9F%E7%90%86/</guid><description>channel介绍 channel一个类型管道，通过它可以在goroutine之间发送和接收消息。它是Golang在语言层面提供的goroutine间的通信方式。 众所周知，Go依赖于称为CSP（Comm</description></item><item><title>golang GC 垃圾回收机制</title><link>https://daemon365.dev/2021/02/20/golang-gc-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</link><pubDate>Sat, 20 Feb 2021 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2021/02/20/golang-gc-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</guid><description>垃圾回收(Garbage Collection，简称GC)是编程语言中提供的自动的内存管理机制，自动释放不需要的对象，让出存储器资源，无需程序员手动执行。 Golang中的垃圾回收主要应用三色标记法，GC</description></item><item><title>viper配置管理</title><link>https://daemon365.dev/2021/01/23/viper%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86/</link><pubDate>Sat, 23 Jan 2021 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2021/01/23/viper%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86/</guid><description>安装 go get github.com/spf13/viper viper支持的功能 1、可以设置默认值 2、可以加载多种格式的配置文件，如JSON，TOML，YAML，HCL和Java属性配置文件 3、应用程序运行过程中，保持监听和重新读取配置文件 4、可以从</description></item><item><title>golangHTML标签提取器soup</title><link>https://daemon365.dev/2021/01/05/golanghtml%E6%A0%87%E7%AD%BE%E6%8F%90%E5%8F%96%E5%99%A8soup/</link><pubDate>Tue, 05 Jan 2021 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2021/01/05/golanghtml%E6%A0%87%E7%AD%BE%E6%8F%90%E5%8F%96%E5%99%A8soup/</guid><description>什么是soup 类似python中beatifulsoup，用于提取html标签提取，多用于爬虫。它可以很好的处理不规范标记并生成剖析树(parse tree)。 它提供简单又常用的导航，搜索以及修改剖析树</description></item><item><title>thrift的介绍及其使用</title><link>https://daemon365.dev/2020/12/30/thrift%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8/</link><pubDate>Wed, 30 Dec 2020 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2020/12/30/thrift%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8/</guid><description>什么是thrift Thrift是Facebook于2007年开发的跨语言的rpc服框架，提供多语言的编译功能，并提供多种服务器工作模式；用户通过Thrift的IDL（接口定义语言）来描述接口函数及数据</description></item><item><title>grpc服务发现与负载均衡</title><link>https://daemon365.dev/2020/12/20/grpc%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E4%B8%8E%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</link><pubDate>Sun, 20 Dec 2020 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2020/12/20/grpc%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E4%B8%8E%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</guid><description>前言 在后台服务开发中，高可用性是构建中核心且重要的一环。服务发现（Service discovery）和负载均衡（Load Balance）一直都是我关注的话题。今天来谈一下我在实际中是如何理解及落地的。</description></item><item><title>grpc基础</title><link>https://daemon365.dev/2020/12/10/grpc%E5%9F%BA%E7%A1%80/</link><pubDate>Thu, 10 Dec 2020 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2020/12/10/grpc%E5%9F%BA%E7%A1%80/</guid><description>RPC 框架原理 RPC 框架的目标就是让远程服务调用更加简单、透明，RPC 框架负责屏蔽底层的传输方式（TCP 或者 UDP）、序列化方式（XML/Json/ 二进制）和通信细节。服务调用者可以像调用本地接口一样调用远程</description></item><item><title>golang jwt</title><link>https://daemon365.dev/2020/05/20/golang-jwt/</link><pubDate>Wed, 20 May 2020 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2020/05/20/golang-jwt/</guid><description>什么是JWT？ JWT全称JSON Web Token是一种跨域认证解决方案，属于一个开放的标准，它规定了一种Token实现方式，目前多用于前后端分离项目和OAuth2.0业务场景下。 JWT作用？ JWT就是一种</description></item><item><title>golang web源码解析</title><link>https://daemon365.dev/2020/03/21/golang-web%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</link><pubDate>Sat, 21 Mar 2020 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2020/03/21/golang-web%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</guid><description>Go的web工作原理 在Go中使用及其简单的代码即可开启一个web服务。如下： //开启web服务 func test(){ http.HandleFunc(&amp;quot;/&amp;quot;, sayHello) err := http.ListenAndServe(&amp;quot;:9090&amp;quot;,nil) if err!=nil { log.Fatal(&amp;quot;ListenAndServer:&amp;quot;,err) } } func sayHello(w http.ResponseWriter, r *http.Request){ r.ParseForm() fmt.Println(&amp;quot;path&amp;quot;,r.URL.Path) fmt.Println(&amp;quot;scheme&amp;quot;,r.URL.Scheme) fmt.Fprintf(w, &amp;quot;Hello Guest!&amp;quot;) } 在使用ListenAndServe这个方法时，系统就会给</description></item><item><title>golang nethttp包</title><link>https://daemon365.dev/2020/01/11/golang-nethttp%E5%8C%85/</link><pubDate>Sat, 11 Jan 2020 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2020/01/11/golang-nethttp%E5%8C%85/</guid><description>http协议 超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络传输协议，所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收</description></item><item><title>nethttp和gin 路由</title><link>https://daemon365.dev/2019/12/23/nethttp%E5%92%8Cgin-%E8%B7%AF%E7%94%B1/</link><pubDate>Mon, 23 Dec 2019 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2019/12/23/nethttp%E5%92%8Cgin-%E8%B7%AF%E7%94%B1/</guid><description>net/http 路由注册 func test1() { http.HandleFunc(&amp;quot;/&amp;quot;, func(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, &amp;quot;Hello world!&amp;quot;) }) err := http.ListenAndServe(&amp;quot;:9001&amp;quot;, nil) if err != nil { log.Fatal(&amp;quot;ListenAndServer:&amp;quot;, err) } } 在使用ListenAndServe这个方法时，系统就会给我们指派一个路由器，DefaultServeMux是系统默认使用的路由器，如果Li</description></item><item><title>proto buffer</title><link>https://daemon365.dev/2019/12/01/proto-buffer/</link><pubDate>Sun, 01 Dec 2019 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2019/12/01/proto-buffer/</guid><description>protobuf是一种高效的数据格式，平台无关、语言无关、可扩展，可用于 RPC 系统和持续数据存储系统。 protobuf介绍 Protobuf是Protocol Buffer的简称，它是Google公司于200</description></item><item><title>go mod</title><link>https://daemon365.dev/2019/10/01/go-mod/</link><pubDate>Tue, 01 Oct 2019 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2019/10/01/go-mod/</guid><description>go module是 Go1.11版本之后官方推出的版本管理工具，并且从Go1.13版本开始，go module将是Go语言默认的依赖管理工具。 GO111MODULE 要启用go module支持首先要设置环境变量GO111MODU</description></item><item><title>golang 模板 htmltemplate与texttemplate</title><link>https://daemon365.dev/2019/07/13/golang-%E6%A8%A1%E6%9D%BF-htmltemplate%E4%B8%8Etexttemplate/</link><pubDate>Sat, 13 Jul 2019 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2019/07/13/golang-%E6%A8%A1%E6%9D%BF-htmltemplate%E4%B8%8Etexttemplate/</guid><description>html模板生成: html/template包实现了数据驱动的模板，用于生成可对抗代码注入的安全HTML输出。它提供了和text/template包相同的接口，Go语言中输出HTML的场景都应使用te</description></item><item><title>golang 反射</title><link>https://daemon365.dev/2019/07/12/golang-%E5%8F%8D%E5%B0%84/</link><pubDate>Fri, 12 Jul 2019 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2019/07/12/golang-%E5%8F%8D%E5%B0%84/</guid><description>变量的内在机制 Go语言中的变量是分为两部分的: 类型信息：预先定义好的元信息。 值信息：程序运行过程中可动态变化的。 反射介绍 反射是指在程序运行期对程序本身进行访问和修改的能力。程序在编译时，变量被转换为内</description></item><item><title>Gin框架介绍及使用</title><link>https://daemon365.dev/2019/06/30/gin%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D%E5%8F%8A%E4%BD%BF%E7%94%A8/</link><pubDate>Sun, 30 Jun 2019 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2019/06/30/gin%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D%E5%8F%8A%E4%BD%BF%E7%94%A8/</guid><description>Gin框架介绍 基于httprouter开发的Web框架。 中文文档，齐全。 简单易用的轻量级框架。 Gin框架安装 go get -u github.com/gin-gonic/gin 实例: package main import ( &amp;quot;fmt&amp;quot; &amp;quot;github.com/gin-gonic/gin&amp;quot; ) func main() { r := gin.Default() // 创建一个默认的路由引擎 // 也可以用gin.New()</description></item><item><title>goalng包和命令工具</title><link>https://daemon365.dev/2019/06/29/goalng%E5%8C%85%E5%92%8C%E5%91%BD%E4%BB%A4%E5%B7%A5%E5%85%B7/</link><pubDate>Sat, 29 Jun 2019 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2019/06/29/goalng%E5%8C%85%E5%92%8C%E5%91%BD%E4%BB%A4%E5%B7%A5%E5%85%B7/</guid><description>包简介 任何包系统设计的目的都是为了简化大型程序的设计和维护工作，通过将一组相关的特性放进一个独立的单元以便于理解和更新，在每个单元更新的同时保持和程序中其它单元的相对独立性。这种模块化的特性允许每个包</description></item><item><title>golang 单元测试</title><link>https://daemon365.dev/2019/06/29/golang-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</link><pubDate>Sat, 29 Jun 2019 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2019/06/29/golang-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</guid><description>go test go test命令是一个按照一定的约定和组织来测试代码的程序。在包目录内，所有以_test.go为后缀名的源文件在执行go build时不会被构建成包的一部分，它们是go test测试的一部分。 go test</description></item><item><title>golang context包</title><link>https://daemon365.dev/2019/06/28/golang-context%E5%8C%85/</link><pubDate>Fri, 28 Jun 2019 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2019/06/28/golang-context%E5%8C%85/</guid><description>go context标准库 context包在Go1.7版本时加入到标准库中。其设计目标是给Golang提供一个标准接口来给其他任务发送取消信号和传递数据。其具体作用为： 可以通过context发送取消信号。</description></item><item><title>golang channel</title><link>https://daemon365.dev/2019/06/26/golang-channel/</link><pubDate>Wed, 26 Jun 2019 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2019/06/26/golang-channel/</guid><description>什么是channel channels 是一种类型安全的消息队列，充当两个 goroutine 之间的管道，将通过它同步的进行任意资源的交换。chan 控制 goroutines 交互的能力从而创建了 Go 同步机制。当创建的 chan 没有容量时，称为无缓冲通道。反过来，使用</description></item><item><title>golang并发</title><link>https://daemon365.dev/2019/06/26/golang%E5%B9%B6%E5%8F%91/</link><pubDate>Wed, 26 Jun 2019 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2019/06/26/golang%E5%B9%B6%E5%8F%91/</guid><description>goroutine goroutine是Go并行设计的核心。goroutine说到底其实就是线程，但是它比线程更小，十几个goroutine可能体现在底层就是五六个线程，Go语言内部帮你实现了这些goroutine之间</description></item><item><title>go语言文件系统</title><link>https://daemon365.dev/2019/06/23/go%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</link><pubDate>Sun, 23 Jun 2019 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2019/06/23/go%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</guid><description>检测文件是否存在 //存在返回 true，不存在返回 false func fileIfExist(filename string) bool { _, err := os.Stat(filename) if nil != err { fmt.Println(filename, &amp;quot;is not exist!&amp;quot;) return false } if os.IsNotExist(err) { return false } return true } 打开文件 f, err := os.Open(filename) if nil != err { fmt.Println(&amp;quot;open&amp;quot;, filename, &amp;quot;failed!&amp;quot;) return } defer f.Close() 如果文件不存在，就会返回错误，如果存在就以只读的方</description></item><item><title>golang函数</title><link>https://daemon365.dev/2019/06/22/golang%E5%87%BD%E6%95%B0/</link><pubDate>Sat, 22 Jun 2019 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2019/06/22/golang%E5%87%BD%E6%95%B0/</guid><description>函数声明 函数声明包括函数名、形式参数列表、返回值列表（可省略）以及函数体。 func function-name(param...) (result...) { body } 形式参数列表描述了函数的参数名以及参数类型。这些参数作为局部变量，其值由参数调用者提供。返回值列表描述了函数返回值</description></item><item><title>golang基础类型</title><link>https://daemon365.dev/2019/06/22/golang%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/</link><pubDate>Sat, 22 Jun 2019 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2019/06/22/golang%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/</guid><description>整型 Go语言同时提供了有符号和无符号类型的整数运算。这里有int8、int16、int32和int64四种截然不同大小的有符号整数类型，分别对应8、16、32、64bit大小的有符号整数，与此对应的是</description></item><item><title>golang基础结构</title><link>https://daemon365.dev/2019/06/22/golang%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84/</link><pubDate>Sat, 22 Jun 2019 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2019/06/22/golang%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84/</guid><description>命名 Go语言中的函数名、变量名、常量名、类型名、语句标号和包名等所有的命名,都遵循一个简单的命名规则：一个名字必须以一个字母（Unicode字母）或下划线开头,后面可以跟任意数量的字母、数字或下划线.</description></item><item><title>golang复杂数据结构</title><link>https://daemon365.dev/2019/06/22/golang%E5%A4%8D%E6%9D%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link><pubDate>Sat, 22 Jun 2019 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2019/06/22/golang%E5%A4%8D%E6%9D%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid><description>数组 **数组是一个由固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成。**因为数组的长度是固定的，因此在Go语言中很少直接使用数组。 数组的每个元素可以通过索引下标来访问，索引下标的范</description></item><item><title>golang接口</title><link>https://daemon365.dev/2019/06/22/golang%E6%8E%A5%E5%8F%A3/</link><pubDate>Sat, 22 Jun 2019 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2019/06/22/golang%E6%8E%A5%E5%8F%A3/</guid><description>接口的定义 接口类型是对其它类型行为的抽象和概括；因为接口类型不会和特定的实现细节绑定在一起，通过这种抽象的方式我们可以让我们的函数更加灵活和更具有适应能力。 很多面向对象的语言都有相似的接口概念，但Go</description></item><item><title>golang方法</title><link>https://daemon365.dev/2019/06/22/golang%E6%96%B9%E6%B3%95/</link><pubDate>Sat, 22 Jun 2019 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2019/06/22/golang%E6%96%B9%E6%B3%95/</guid><description>方法声明 在函数声明时，在其名字之前放上一个变量，即是一个方法。这个附加的参数会将该函数附加到这种类型上，即相当于为这种类型定义了一个独占的方法。 package main import &amp;quot;fmt&amp;quot; type People struct { name string age uint8 } func (p People) SayHello() { fmt.Println(p.name, &amp;quot;: hello world&amp;quot;) p.age = 20 } func main()</description></item><item><title>golang time包</title><link>https://daemon365.dev/2019/06/21/golang-time%E5%8C%85/</link><pubDate>Fri, 21 Jun 2019 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2019/06/21/golang-time%E5%8C%85/</guid><description>时间类型 time.Time类型表示时间。 func demo() { now := time.Now() //获取当前时间 fmt.Printf(&amp;quot;Now:%v\n&amp;quot;, now) // Now:2020-08-19 21:53:31.1633023 +0800 CST m=+0.003989401 year := now.Year() //年 month := now.Month() //月 day := now.Day() //日 hour := now.Hour() //小时 minute := now.Minute() //分钟 second := now.Second() //秒 fmt.Printf(&amp;quot;%d-%02d-%02d %02d:%02d:%02d\n&amp;quot;, year, month, day, hour, minute, second) // 2020-08-19 21:53:31 } 时间戳 func stamp() { now :=</description></item><item><title>golang error错误处理</title><link>https://daemon365.dev/2019/06/20/golang-error%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</link><pubDate>Thu, 20 Jun 2019 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2019/06/20/golang-error%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</guid><description>error定义 数据结构 go语言error是一普通的值，实现方式为简单一个接口。 // The error built-in interface type is the conventional interface for // representing an error condition, with the nil value representing no error. type error interface { Error() string } 创建error 使用errors.New() // New returns an error that formats as the given</description></item><item><title>golang fmt包</title><link>https://daemon365.dev/2019/06/20/golang-fmt%E5%8C%85/</link><pubDate>Thu, 20 Jun 2019 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2019/06/20/golang-fmt%E5%8C%85/</guid><description>fmt fmt包实现了类似C语言printf和scanf的格式化I/O。主要分为向外输出内容和获取输入内容两大部分。 向外输出 标准库fmt提供了以下几种输出相关函数。 Print Print系列函数会将内容输出到系统的标</description></item></channel></rss>