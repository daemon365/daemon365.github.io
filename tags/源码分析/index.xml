<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>源码分析 on Daemon</title><link>https://daemon365.dev/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link><description>Recent content in 源码分析 on Daemon</description><generator>Hugo</generator><language>en</language><lastBuildDate>Sat, 15 Jun 2024 16:14:00 +0800</lastBuildDate><atom:link href="https://daemon365.dev/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/index.xml" rel="self" type="application/rss+xml"/><item><title>boltdb 原理</title><link>https://daemon365.dev/2024/06/15/boltdb-%E5%8E%9F%E7%90%86/</link><pubDate>Sat, 15 Jun 2024 16:14:00 +0800</pubDate><guid>https://daemon365.dev/2024/06/15/boltdb-%E5%8E%9F%E7%90%86/</guid><description>简介 介绍及简单使用：https://www.cnblogs.com/daemon365/p/17690167.html 源码地址：https://github.com/etcd-io/bbolt page 因为 boltdb</description></item><item><title>kubelet 原理分析</title><link>https://daemon365.dev/2024/05/01/kubelet-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</link><pubDate>Wed, 01 May 2024 12:40:00 +0800</pubDate><guid>https://daemon365.dev/2024/05/01/kubelet-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</guid><description>Reference https://atbug.com/kubelet-source-code-analysis/ kubelet 简介 kubernetes 分为控制面和数据面，kubelet 就是数据面最主要的组件，在每个节点上启动，主要负责容器的创建、启停、监控、日志收集等工作。它是一个在每个集群节点上运行的代理，负责确保节点上的容器根据Po</description></item><item><title>容器启动流程（containerd 和 runc）</title><link>https://daemon365.dev/2023/12/07/%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8Bcontainerd-%E5%92%8C-runc/</link><pubDate>Thu, 07 Dec 2023 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2023/12/07/%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8Bcontainerd-%E5%92%8C-runc/</guid><description>启动流程 containerd 作为一个 api 服务，提供了一系列的接口供外部调用，比如创建容器、删除容器、创建镜像、删除镜像等等。使用 docker 和 ctr 等工具，都是通过调用 containerd 的 api 来实现的。 kubelet 通过 cri 调用 containerd 和这些不一样，后续我会介绍到。 containerd 创建</description></item><item><title>kratos http原理</title><link>https://daemon365.dev/2023/06/29/kratos-http%E5%8E%9F%E7%90%86/</link><pubDate>Thu, 29 Jun 2023 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2023/06/29/kratos-http%E5%8E%9F%E7%90%86/</guid><description>概念 kratos 为了使http协议的逻辑代码和grpc的逻辑代码使用同一份，选择了基于protobuf的IDL文件使用proto插件生成辅助代码的方式。 protoc http插件的地址为：https://github.co</description></item><item><title>从kratos分析breaker熔断器源码实现</title><link>https://daemon365.dev/2021/09/04/%E4%BB%8Ekratos%E5%88%86%E6%9E%90breaker%E7%86%94%E6%96%AD%E5%99%A8%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0/</link><pubDate>Sat, 04 Sep 2021 17:55:01 +0800</pubDate><guid>https://daemon365.dev/2021/09/04/%E4%BB%8Ekratos%E5%88%86%E6%9E%90breaker%E7%86%94%E6%96%AD%E5%99%A8%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0/</guid><description>为什么要用熔断 前面我们讲过限流保证服务的可用性，不被突如其来的流量打爆。但是两种情况是限流解决不了的。 如果我们服务只能处理1000QPS，但是有10wQPS打过来，服务还是会炸。因为拒绝请求也需要成本</description></item><item><title>从kratos分析BBR限流源码实现</title><link>https://daemon365.dev/2021/09/04/%E4%BB%8Ekratos%E5%88%86%E6%9E%90bbr%E9%99%90%E6%B5%81%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0/</link><pubDate>Sat, 04 Sep 2021 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2021/09/04/%E4%BB%8Ekratos%E5%88%86%E6%9E%90bbr%E9%99%90%E6%B5%81%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0/</guid><description>什么是自适应限流 自适应限流从整体维度对应用入口流量进行控制，结合应用的 Load、CPU 使用率、总体平均 RT、入口 QPS 和并发线程数等几个维度的监控指标，通过自适应的流控策略，让系统的入口流量和系统的负载达</description></item><item><title>golang map实现原理</title><link>https://daemon365.dev/2021/05/22/golang-map%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</link><pubDate>Sat, 22 May 2021 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2021/05/22/golang-map%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</guid><description>这篇文章主要讲 map 的赋值、删除、查询、扩容的具体执行过程，仍然是从底层的角度展开。结合源码，看完本文一定会彻底明白 map 底层原理。 我要说明的是，这里对 map 的基本用法涉及比较少，我相信可以通过阅读其他入门书籍了</description></item><item><title>golang channel原理</title><link>https://daemon365.dev/2021/02/21/golang-channel%E5%8E%9F%E7%90%86/</link><pubDate>Sun, 21 Feb 2021 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2021/02/21/golang-channel%E5%8E%9F%E7%90%86/</guid><description>channel介绍 channel一个类型管道，通过它可以在goroutine之间发送和接收消息。它是Golang在语言层面提供的goroutine间的通信方式。 众所周知，Go依赖于称为CSP（Comm</description></item><item><title>golang web源码解析</title><link>https://daemon365.dev/2020/03/21/golang-web%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</link><pubDate>Sat, 21 Mar 2020 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2020/03/21/golang-web%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</guid><description>Go的web工作原理 在Go中使用及其简单的代码即可开启一个web服务。如下： //开启web服务 func test(){ http.HandleFunc(&amp;quot;/&amp;quot;, sayHello) err := http.ListenAndServe(&amp;quot;:9090&amp;quot;,nil) if err!=nil { log.Fatal(&amp;quot;ListenAndServer:&amp;quot;,err) } } func sayHello(w http.ResponseWriter, r *http.Request){ r.ParseForm() fmt.Println(&amp;quot;path&amp;quot;,r.URL.Path) fmt.Println(&amp;quot;scheme&amp;quot;,r.URL.Scheme) fmt.Fprintf(w, &amp;quot;Hello Guest!&amp;quot;) } 在使用ListenAndServe这个方法时，系统就会给</description></item></channel></rss>