<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Cri on Daemon</title><link>https://daemon365.dev/tags/cri/</link><description>Recent content in Cri on Daemon</description><generator>Hugo</generator><language>en</language><lastBuildDate>Thu, 09 May 2024 20:56:00 +0800</lastBuildDate><atom:link href="https://daemon365.dev/tags/cri/index.xml" rel="self" type="application/rss+xml"/><item><title>docker containerd runc containerd-shim等组件的关系</title><link>https://daemon365.dev/2024/05/09/docker-containerd-runc-containerd-shim%E7%AD%89%E7%BB%84%E4%BB%B6%E7%9A%84%E5%85%B3%E7%B3%BB/</link><pubDate>Thu, 09 May 2024 20:56:00 +0800</pubDate><guid>https://daemon365.dev/2024/05/09/docker-containerd-runc-containerd-shim%E7%AD%89%E7%BB%84%E4%BB%B6%E7%9A%84%E5%85%B3%E7%B3%BB/</guid><description>早期 kubelet 创建容器工作原理 因为 docker 出生的比 k8s 早，所以 k8s 早期的容器运行时都是基于 docker 的，kubelet 通过 docker 的 api 创建容器。后来，k8s 官方不想绑死在 docker 这架马车上，就把容器运行时抽象出来，定义了一个接口，叫 CRI (container runtime</description></item></channel></rss>