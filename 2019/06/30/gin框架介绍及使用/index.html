<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=HandheldFriendly content="True"><meta http-equiv=X-UA-Compatible content="IE=edge"><meta http-equiv=Cache-Control content="no-transform"><meta http-equiv=Cache-Control content="no-siteapp"><meta name=generator content="Hugo 0.128.2"><link rel="shortcut icon" href=/imgs/icons/favicon.ico><title>Gin框架介绍及使用 - Daemon</title>
<meta name=author content="daemon365"><meta name=description content="Don't let yourself stop."><meta name=keywords content="go,gin"><meta property="og:title" content="Gin框架介绍及使用"><meta name=twitter:title content="Gin框架介绍及使用"><meta property="og:type" content="article"><meta property="og:url" content="https://daemon365.dev/2019/06/30/gin%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D%E5%8F%8A%E4%BD%BF%E7%94%A8/"><meta property="og:description" content='Gin框架介绍 基于httprouter开发的Web框架。 中文文档，齐全。 简单易用的轻量级框架。 Gin框架安装 go get -u github.com/gin-gonic/gin 实例: package main import ( "fmt" "github.com/gin-gonic/gin" ) func main() { r := gin.Default() // 创建一个默认的路由引擎 // 也可以用gin.New()'><meta name=twitter:description content='Gin框架介绍 基于httprouter开发的Web框架。 中文文档，齐全。 简单易用的轻量级框架。 Gin框架安装 go get -u github.com/gin-gonic/gin 实例: package main import ( "fmt" "github.com/gin-gonic/gin" ) func main() { r := gin.Default() // 创建一个默认的路由引擎 // 也可以用gin.New()'><meta property="og:image" content="https://daemon365.dev/imgs/icons/favicon.ico"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://daemon365.dev/imgs/icons/favicon.ico"><meta property="article:published_time" content="2019-06-30T00:00:00+08:00"><meta property="article:modified_time" content="2019-06-30T00:00:00+08:00"><style>@media(prefers-color-scheme:dark){body[data-theme=auto] img{filter:brightness(60%)}}body[data-theme=dark] img{filter:brightness(60%)}</style><link rel=stylesheet href=https://daemon365.dev/assets/css/fuji.min.4705982b44df69092424841b031cb53013b315bd3fc70b72a14573d9be9705d6c11ab2f470b6bfab457823a2d1514588c57fa2a790745edd3d30f0ca51c06e4f.css integrity="sha512-RwWYK0TfaQkkJIQbAxy1MBOzFb0/xwtyoUVz2b6XBdbBGrL0cLa/q0V4I6LRUUWIxX+ip5B0Xt09MPDKUcBuTw=="></head><body data-theme=light data-theme-auto=false><script data-cfasync=false>var fujiThemeData=localStorage.getItem("fuji_data-theme");fujiThemeData?fujiThemeData!=="auto"&&document.body.setAttribute("data-theme",fujiThemeData==="dark"?"dark":"light"):localStorage.setItem("fuji_data-theme","auto")</script><header><div class="container-lg clearfix"><div class="col-12 header"><a class=title-main href=https://daemon365.dev/>Daemon</a>
<span class=title-sub>Don't let yourself stop.</span></div></div></header><main><div class="container-lg clearfix"><div class="col-12 col-md-9 float-left content"><article><h2 class="post-item post-title"><a href=https://daemon365.dev/2019/06/30/gin%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D%E5%8F%8A%E4%BD%BF%E7%94%A8/>Gin框架介绍及使用</a></h2><div class="post-item post-meta"><span><i class="iconfont icon-today-sharp"></i>&nbsp;2019-06-30</span>
<span><i class="iconfont icon-file-tray-sharp"></i>&nbsp;3316 words</span>
<span><i class="iconfont icon-pricetags-sharp"></i>&nbsp;<a href=/tags/go>go</a>&nbsp;<a href=/tags/gin>gin</a>&nbsp;</span></div><div class="post-content markdown-body"><h2 id=gin框架介绍>Gin框架介绍</h2><ul><li>基于<a href=https://github.com/julienschmidt/httprouter target=_blank>httprouter</a>开发的Web框架。</li><li><a href=https://gin-gonic.com/zh-cn/docs/ target=_blank>中文文档</a>，齐全。</li><li>简单易用的轻量级框架。</li></ul><h2 id=gin框架安装>Gin框架安装</h2><pre><code class=language-bash>go get -u github.com/gin-gonic/gin
</code></pre><p><strong>实例:</strong></p><pre><code class=language-go>package main
import (
	&quot;fmt&quot;
	&quot;github.com/gin-gonic/gin&quot;
)
func main() {

	r := gin.Default()
	// 创建一个默认的路由引擎
	// 也可以用gin.New() gin.Default()多用了日志和panic的recover中间件
	r.GET(&quot;/helloworld&quot;, func(c *gin.Context) {
		c.JSON(200, gin.H{
			// c.JSON：返回JSON格式的数据
			&quot;msg&quot;: &quot;Hello world!&quot;,
		})
	})
	err := r.Run(&quot;127.0.0.1:8001&quot;)
	// 启动HTTP服务，默认在127.0.0.1:8001启动服务
	if err != nil {
		fmt.Println(&quot;run gin field&quot;)
		return
	}
}
</code></pre><p><img class=img-zoomable src=/images/a78c08f7-e35f-41f2-bc49-9388ef405408.png alt></p><h2 id=restful-api>RESTful API</h2><p>REST与技术无关，代表的是一种软件架构风格，REST是Representational State Transfer的简称，中文翻译为“表征状态转移”或“表现层状态转化”。</p><p>简单来说，REST的含义就是客户端与Web服务器之间进行交互的时候，使用HTTP协议中的4个请求方法代表不同的动作。</p><ul><li>GET用来获取资源</li><li>POST用来新建资源</li><li>PUT用来更新资源</li><li>DELETE用来删除资源。</li></ul><p>只要API程序遵循了REST风格，那就可以称其为RESTful API。目前在前后端分离的架构中，前后端基本都是通过RESTful API来进行交互。</p><p>例如，我们现在要编写一个管理书籍的系统，我们可以查询对一本书进行查询、创建、更新和删除等操作，我们在编写程序的时候就要设计客户端浏览器与我们Web服务端交互的方式和路径。按照经验我们通常会设计成如下模式：</p><table><thead><tr><th>请求方法</th><th>URL</th><th>含义</th></tr></thead><tbody><tr><td>GET</td><td>/book</td><td>查询书籍信息</td></tr><tr><td>POST</td><td>/create_book</td><td>创建书籍记录</td></tr><tr><td>POST</td><td>/update_book</td><td>更新书籍信息</td></tr><tr><td>POST</td><td>/delete_book</td><td>删除书籍信息</td></tr></tbody></table><p>同样的需求我们按照RESTful API设计如下：</p><table><thead><tr><th>请求方法</th><th>URL</th><th>含义</th></tr></thead><tbody><tr><td>GET</td><td>/book</td><td>查询书籍信息</td></tr><tr><td>POST</td><td>/book</td><td>创建书籍记录</td></tr><tr><td>PUT</td><td>/book</td><td>更新书籍信息</td></tr><tr><td>DELETE</td><td>/book</td><td>删除书籍信息</td></tr></tbody></table><p>Gin框架支持开发RESTful API的开发。</p><pre><code class=language-go>func main() {
	r := gin.Default()
	r.GET(&quot;/book&quot;, func(c *gin.Context) {
		c.JSON(200, gin.H{
			&quot;message&quot;: &quot;GET&quot;,
		})
	})
	r.POST(&quot;/book&quot;, func(c *gin.Context) {
		c.JSON(200, gin.H{
			&quot;message&quot;: &quot;POST&quot;,
		})
	})
	r.PUT(&quot;/book&quot;, func(c *gin.Context) {
		c.JSON(200, gin.H{
			&quot;message&quot;: &quot;PUT&quot;,
		})
	})
	r.DELETE(&quot;/book&quot;, func(c *gin.Context) {
		c.JSON(200, gin.H{
			&quot;message&quot;: &quot;DELETE&quot;,
		})
	})
}
</code></pre><p>开发RESTful API的时候我们通常使用<a href=https://www.getpostman.com/ target=_blank>Postman</a>来作为客户端的测试工具。</p><h2 id=gin渲染>Gin渲染</h2><h3 id=html渲染>HTML渲染</h3><p>我们首先定义一个存放模板文件的templates文件夹，然后在其内部按照业务分别定义一个posts文件夹和一个users文件夹。posts/index.html文件的内容如下：</p><pre><code class=language-go>{{define &quot;posts/index.html&quot;}}
    posts/index
    {{.title}}
{{end}}
</code></pre><p>users/index.html文件的内容如下：</p><pre><code class=language-go>{{define &quot;users/index.html&quot;}}
    users/index
    {{.title}}
{{end}}
</code></pre><p>Gin框架中使用LoadHTMLGlob()或者LoadHTMLFiles()方法进行HTML模板渲染。</p><pre><code class=language-go>func main() {
	r := gin.Default()
	r.LoadHTMLGlob(&quot;templates/**/*&quot;)
	//r.LoadHTMLFiles(&quot;templates/posts/index.html&quot;, &quot;templates/users/index.html&quot;)
	r.GET(&quot;/posts/index&quot;, func(c *gin.Context) {
		c.HTML(http.StatusOK, &quot;posts/index.html&quot;, gin.H{
			&quot;title&quot;: &quot;posts/index&quot;,
		})
	})
	r.GET(&quot;users/index&quot;, func(c *gin.Context) {
		c.HTML(http.StatusOK, &quot;users/index.html&quot;, gin.H{
			&quot;title&quot;: &quot;users/index&quot;,
		})
	})
	r.Run(&quot;:8080&quot;)
}
</code></pre><h3 id=静态文件处理>静态文件处理</h3><p>当我们渲染的HTML文件中引用了静态文件时，我们只需要按照以下方式在渲染页面前调用gin.Static方法即可。</p><pre><code class=language-go>func main() {
	r := gin.Default()
	r.Static(&quot;/static&quot;, &quot;./static&quot;)
	r.LoadHTMLGlob(&quot;templates/**/*&quot;)
   ...
	r.Run(&quot;:8080&quot;)
}
</code></pre><h3 id=补充文件路径处理>补充文件路径处理</h3><p>关于模板文件和静态文件的路径，我们需要根据公司/项目的要求进行设置。可以使用下面的函数获取当前执行程序的路径。</p><pre><code class=language-go>func getCurrentPath() string {
	if ex, err := os.Executable(); err == nil {
		return filepath.Dir(ex)
	}
	return &quot;./&quot;
}
</code></pre><h3 id=json渲染>JSON渲染</h3><pre><code class=language-go>func main() {
	r := gin.Default()
	// gin.H 是map[string]interface{}的缩写
	r.GET(&quot;/someJSON&quot;, func(c *gin.Context) {
		// 方式一：自己拼接JSON
		c.JSON(http.StatusOK, gin.H{&quot;message&quot;: &quot;Hello world!&quot;})
	})
	r.GET(&quot;/moreJSON&quot;, func(c *gin.Context) {
		// 方法二：使用结构体
		var msg struct {
			Name    string `json:&quot;user&quot;`
			Message string
			Age     int
		}
		msg.Name = &quot;zhy&quot;
		msg.Message = &quot;Hello world!&quot;
		msg.Age = 18
		c.JSON(http.StatusOK, msg)
	})
	r.Run(&quot;:8080&quot;)
}
</code></pre><h3 id=xml渲染>XML渲染</h3><p>注意需要使用具名的结构体类型。</p><pre><code class=language-go>func main() {
	r := gin.Default()
	// gin.H 是map[string]interface{}的缩写
	r.GET(&quot;/someXML&quot;, func(c *gin.Context) {
		// 方式一：自己拼接JSON
		c.XML(http.StatusOK, gin.H{&quot;message&quot;: &quot;Hello world!&quot;})
	})
	r.GET(&quot;/moreXML&quot;, func(c *gin.Context) {
		// 方法二：使用结构体
		type MessageRecord struct {
			Name    string
			Message string
			Age     int
		}
		var msg MessageRecord
		msg.Name = &quot;小王子&quot;
		msg.Message = &quot;Hello world!&quot;
		msg.Age = 18
		c.XML(http.StatusOK, msg)
	})
	r.Run(&quot;:8080&quot;)
}
</code></pre><h3 id=ymal渲染>YMAL渲染</h3><pre><code class=language-go>r.GET(&quot;/someYAML&quot;, func(c *gin.Context) {
	c.YAML(http.StatusOK, gin.H{&quot;message&quot;: &quot;ok&quot;, &quot;status&quot;: http.StatusOK})
})
</code></pre><h3 id=protobuf渲染>protobuf渲染</h3><pre><code class=language-protobuf>// protobuf文件
syntax = &quot;proto3&quot;;
package models;
message hello {
    string content = 1;
}
</code></pre><pre><code class=language-go>package main
import (
	&quot;net/http&quot;
	&quot;test/models&quot;
	&quot;github.com/gin-gonic/gin&quot;
)
func main() {
	r := gin.Default()
	r.GET(&quot;/hello&quot;,func (c *gin.Context)  {
		res := &amp;models.Hello{
			Content: &quot;你好&quot;,
		}
		c.ProtoBuf(http.StatusOK,res)
	})
	_ = r.Run(&quot;127.0.0.1:8001&quot;)
}
</code></pre><h2 id=获取参数>获取参数</h2><h3 id=获取querystring参数>获取querystring参数</h3><p>querystring指的是URL中?后面携带的参数，例如：/user?username=赵海宇&amp;address=地球一角。</p><ol><li>c.DefaultQuery有默认值 如果没有传去默认值</li><li>c.Query没有默认值 如果没传 为空</li></ol><pre><code class=language-go>package main
import (
	&quot;net/http&quot;
	&quot;github.com/gin-gonic/gin&quot;
)
func main() {
	r := gin.Default()
	r.GET(&quot;/user&quot;, func(c *gin.Context) {
		username := c.DefaultQuery(&quot;username&quot;, &quot;zhy&quot;)
		address := c.Query(&quot;address&quot;)
		c.JSON(http.StatusOK, gin.H{
			&quot;username&quot;: username,
			&quot;address&quot;:  address,
		})
	})
	_ = r.Run(&quot;127.0.0.1:8001&quot;)
}
</code></pre><h3 id=获取form参数>获取form参数</h3><p>请求的数据通过form表单来提交，例如向/user发送一个POST请求，获取请求数据的方式如下：c.PostForm</p><pre><code class=language-go>package main
import (
	&quot;net/http&quot;
	&quot;github.com/gin-gonic/gin&quot;
)
func main() {
	r := gin.Default()
	r.POST(&quot;/user&quot;, func(c *gin.Context) {
		username := c.PostForm(&quot;username&quot;)
		address := c.PostForm(&quot;address&quot;)
		c.JSON(http.StatusOK, gin.H{
			&quot;username&quot;: username,
			&quot;address&quot;:  address,
		})
	})
	_ = r.Run(&quot;127.0.0.1:8001&quot;)
}
</code></pre><h3 id=获取path参数>获取path参数</h3><p>请求的参数通过URL路径传递，例如：/user/zhaohaiyu/地球一角/路由:/user/:username/:address方法:c.Param</p><pre><code class=language-go>package main
import (
	&quot;net/http&quot;
	&quot;github.com/gin-gonic/gin&quot;
)
func main() {
	r := gin.Default()
	r.GET(&quot;/user/:username/:address&quot;, func(c *gin.Context) {
		username := c.Param(&quot;username&quot;)
		address := c.Param(&quot;address&quot;)
		c.JSON(http.StatusOK, gin.H{
			&quot;username&quot;: username,
			&quot;address&quot;:  address,
		})
	})
	_ = r.Run(&quot;127.0.0.1:8001&quot;)
}
</code></pre><h3 id=参数绑定>参数绑定</h3><p>为了能够更方便的获取请求相关参数，提高开发效率，我们可以基于请求的content-type识别请求数据类型并利用反射机制自动提取请求中querystring、form表单、JSON、XML等参数到结构体中。</p><pre><code class=language-go>package main
import (
	&quot;fmt&quot;
	&quot;net/http&quot;
	&quot;github.com/gin-gonic/gin&quot;
)
// Binding from JSON
type Login struct {
	User     string `form:&quot;user&quot; json:&quot;user&quot; binding:&quot;required&quot;`
	Password string `form:&quot;password&quot; json:&quot;password&quot; binding:&quot;required&quot;`
}
func main() {
	r := gin.Default()
	// 绑定JSON的示例 ({&quot;user&quot;: &quot;root&quot;, &quot;password&quot;: &quot;123&quot;})
	r.POST(&quot;/loginJSON&quot;, func(c *gin.Context) {
		var login Login
		if err := c.ShouldBindJSON(&amp;login); err == nil {
			fmt.Printf(&quot;login info:%#v\n&quot;, login)
			c.JSON(http.StatusOK, login)
		} else {
			c.JSON(http.StatusBadRequest, gin.H{&quot;error&quot;: err.Error()})
		}
	})
	// 绑定form表单示例 (user=root&amp;password=123)
	r.POST(&quot;/loginForm&quot;, func(c *gin.Context) {
		var login Login
		// ShouldBind()会根据请求的Content-Type自行选择绑定器
		if err := c.ShouldBind(&amp;login); err == nil {
			c.JSON(http.StatusOK, login)
		} else {
			c.JSON(http.StatusBadRequest, gin.H{&quot;error&quot;: err.Error()})
		}
	})
	// 绑定querystring示例 (user=root&amp;password=123)
	r.GET(&quot;/loginForm&quot;, func(c *gin.Context) {
		var login Login
		// ShouldBind()会根据请求的Content-Type自行选择绑定器
		if err := c.ShouldBind(&amp;login); err == nil {
			c.JSON(http.StatusOK, login)
		} else {
			c.JSON(http.StatusBadRequest, gin.H{&quot;error&quot;: err.Error()})
		}
	})
	_ = r.Run(&quot;127.0.0.1:8001&quot;)
}

</code></pre><h2 id=文件上传>文件上传</h2><pre><code class=language-go>func main() {
	router := gin.Default() // 处理multipart forms提交文件时默认的内存限制是32 MiB
	// 可以通过下面的方式修改
	// router.MaxMultipartMemory = 8 &lt;&lt; 20 // 8 MiB
	router.POST(&quot;/upload&quot;, func(c *gin.Context) {
		// 单个文件
		file, err := c.FormFile(&quot;file&quot;)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{&quot;message&quot;: err.Error()})
			return
		}
		log.Println(file.Filename)
		dst := fmt.Sprintf(&quot;C:/tmp/%s&quot;, file.Filename) // 上传文件到指定的目录
		c.SaveUploadedFile(file, dst)
		c.JSON(http.StatusOK, gin.H{&quot;message&quot;: fmt.Sprintf(&quot;'%s' uploaded!&quot;, file.Filename)})
	})
	router.Run()
}
</code></pre><h3 id=多个文件上传>多个文件上传</h3><pre><code class=language-go>func main() {
	router := gin.Default()
	// 处理multipart forms提交文件时默认的内存限制是32 MiB
	// 可以通过下面的方式修改
	// router.MaxMultipartMemory = 8 &lt;&lt; 20  // 8 MiB
	router.POST(&quot;/upload&quot;, func(c *gin.Context) {
		// Multipart form
		form, _ := c.MultipartForm()
		files := form.File[&quot;file&quot;]
		for index, file := range files {
			log.Println(file.Filename)
			dst := fmt.Sprintf(&quot;C:/tmp/%s_%d&quot;, file.Filename, index)
			// 上传文件到指定的目录
			c.SaveUploadedFile(file, dst)
		}
		c.JSON(http.StatusOK, gin.H{
			&quot;message&quot;: fmt.Sprintf(&quot;%d files uploaded!&quot;, len(files)),
		})
	})
	router.Run()
}
</code></pre><h2 id=gin中间件>Gin中间件</h2><p>Gin框架允许开发者在处理请求的过程中，加入用户自己的钩子（Hook）函数。这个钩子函数就叫中间件，中间件适合处理一些公共的业务逻辑，比如登录校验、日志打印、耗时统计等。</p><p>Gin中的中间件必须是一个gin.HandlerFunc类型。例如我们像下面的代码一样定义一个中间件。</p><pre><code class=language-go>// StatCost 是一个统计耗时请求耗时的中间件
func StatCost() gin.HandlerFunc {
	return func(c *gin.Context) {
		start := time.Now()
		c.Set(&quot;name&quot;, &quot;小王子&quot;)
		// 执行其他中间件
		c.Next()
		// 计算耗时
		cost := time.S***art)
		log.Println(cost)
	}
}
</code></pre><p>然后注册中间件的时候，可以在全局注册。</p><pre><code class=language-go>func main() {
	// 新建一个没有任何默认中间件的路由
	r := gin.New()
	// 注册一个全局中间件
	r.Use(StatCost())

	r.GET(&quot;/test&quot;, func(c *gin.Context) {
		name := c.MustGet(&quot;name&quot;).(string)
		log.Println(name)
		c.JSON(http.StatusOK, gin.H{
			&quot;message&quot;: &quot;Hello world!&quot;,
		})
	})
	r.Run()
}
</code></pre><p>也可以给某个路由单独注册中间件。</p><pre><code class=language-go>// 给/test2路由单独注册中间件（可注册多个）
	r.GET(&quot;/test2&quot;, StatCost(), func(c *gin.Context) {
		name := c.MustGet(&quot;name&quot;).(string)
		log.Println(name)
		c.JSON(http.StatusOK, gin.H{
			&quot;message&quot;: &quot;Hello world!&quot;,
		})
	})
</code></pre><h3 id=重定向>重定向</h3><h4 id=http重定向>HTTP重定向</h4><p>HTTP 重定向很容易。 内部、外部重定向均支持。</p><pre><code class=language-go>r.GET(&quot;/test&quot;, func(c *gin.Context) {
	c.Redirect(http.StatusMovedPermanently, &quot;http://www.google.com/&quot;)
})
</code></pre><h4 id=路由重定向>路由重定向</h4><p>路由重定向，使用HandleContext：</p><pre><code class=language-go>r.GET(&quot;/test&quot;, func(c *gin.Context) {
    // 指定重定向的URL
    c.Request.URL.Path = &quot;/test2&quot;
    r.HandleContext(c)
})
r.GET(&quot;/test2&quot;, func(c *gin.Context) {
    c.JSON(http.StatusOK, gin.H{&quot;hello&quot;: &quot;world&quot;})
})
</code></pre><h2 id=gin路由>Gin路由</h2><h3 id=普通路由>普通路由</h3><pre><code class=language-go>r.GET(&quot;/index&quot;, func(c *gin.Context) {...})
r.GET(&quot;/login&quot;, func(c *gin.Context) {...})
r.POST(&quot;/login&quot;, func(c *gin.Context) {...})
</code></pre><p>此外，还有一个可以匹配所有请求方法的Any方法如下：</p><pre><code class=language-go>r.Any(&quot;/test&quot;, func(c *gin.Context) {...})
</code></pre><p>为没有配置处理函数的路由添加处理程序。默认情况下它返回404代码。</p><pre><code class=language-go>r.NoRoute(func(c *gin.Context) {
		c.HTML(http.StatusNotFound, &quot;views/404.html&quot;, nil)
	})
</code></pre><h3 id=路由组>路由组</h3><p>我们可以将拥有共同URL前缀的路由划分为一个路由组。</p><pre><code class=language-go>func main() {
	r := gin.Default()
	userGroup := r.Group(&quot;/user&quot;)
	{
		userGroup.GET(&quot;/index&quot;, func(c *gin.Context) {...})
		userGroup.GET(&quot;/login&quot;, func(c *gin.Context) {...})
		userGroup.POST(&quot;/login&quot;, func(c *gin.Context) {...})
	}
	shopGroup := r.Group(&quot;/shop&quot;)
	{
		shopGroup.GET(&quot;/index&quot;, func(c *gin.Context) {...})
		shopGroup.GET(&quot;/cart&quot;, func(c *gin.Context) {...})
		shopGroup.POST(&quot;/checkout&quot;, func(c *gin.Context) {...})
	}
	r.Run()
}
</code></pre><p>通常我们将路由分组用在划分业务逻辑或划分API版本时。</p><h3 id=路由分文件>路由分文件</h3><ol><li>在route中初始化route和切片路由组</li><li>在各个文件写路由</li><li>在main中把路由函数放入函数路由组</li></ol><pre><code class=language-go>// route中go
package route
import &quot;github.com/gin-gonic/gin&quot;
type Option func(*gin.Engine)
var options = []Option{} // 路由函数组
// 注册app的路由配置
func Include(opts ...Option) {
	options = append(options, opts...) // 路由函数组添加函数
}
// 初始化
func Init() *gin.Engine {
	r := gin.New()
	for _, function := range options {
		function(r) // 执行路由函数组中所有函数
	}
	return r
}
</code></pre><pre><code class=language-go>// shop中的文件
package shop
import &quot;github.com/gin-gonic/gin&quot;
func Routers(e *gin.Engine) {// 路由函数
	e.GET(&quot;/post&quot;, func(c *gin.Context) {
		c.String(200,&quot;psot shop&quot;)
	})
	e.GET(&quot;/comment&quot;, func(c *gin.Context) {
		c.String(200,&quot;comment shop&quot;)
	})
}
</code></pre><pre><code class=language-go>// main.go
package main
import (
	&quot;test/demo1/route&quot;
	&quot;test/demo1/shop&quot;
)
func main() {
	route.Include(shop.Routers)
	// 初始化路由
	r := route.Init() 
	_ = r.Run()
}
</code></pre><h3 id=路由原理>路由原理</h3><p>Gin框架中的路由使用的是<a href=https://github.com/julienschmidt/httprouter target=_blank>httprouter</a>这个库。</p><p>其基本原理就是构造一个路由地址的前缀树。</p><h2 id=参考文章>参考文章</h2><ul><li><a href=https://www.liwenzhou.com/posts/Go/Gin_framework/ target=_blank>https://www.liwenzhou.com/posts/Go/Gin_framework/</a></li></ul></div></article><div class="license markdown-body"><blockquote><p>Unless otherwise noted, the content of this site is licensed under <a rel=license href=http://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank>CC BY-NC-SA 4.0</a>.</p></blockquote></div><div class=post-comment data-comment=utterances><span class=post-comment-notloaded><i class="iconfont icon-chatbox-ellipses-sharp"></i>&nbsp;Load comments
</span><script>function loadComment(){var e,n=document.querySelector(".post-comment"),t=document.body.getAttribute("data-theme");t==="auto"?t=window.matchMedia("(prefers-color-scheme: dark)").matches?"photon-dark":"github-light":t=t==="dark"?"photon-dark":"github-light",e=document.createElement("script"),e.src="https://utteranc.es/client.js",e.setAttribute("repo","daemon365/daemon365.github.io"),e.setAttribute("issue-term","pathname"),e.setAttribute("theme",t),e.setAttribute("crossorigin","anonymous"),e.setAttribute("async",""),document.querySelector(".post-comment").appendChild(e),document.querySelector("span.post-comment-notloaded").setAttribute("style","display: none;")}</script></div></div><aside class="col-12 col-md-3 float-left sidebar"><div class="sidebar-item sidebar-pages"><h3>Pages</h3><ul><li><a href=/>Home</a></li><li><a href=/archives/>Archives</a></li><li><a href=/index.xml>RSS</a></li><li><a href=/about/>About</a></li><li><a href=/search/>Search</a></li></ul></div><div class="sidebar-item sidebar-links"><h3>Links</h3><ul><li><a href=https://github.com/daemon365 target=_blank><span>My GitHub</span></a></li></ul></div><div class="sidebar-item sidebar-tags"><h3>Tags</h3><div><span><a href=/tags/bbr/>BBR</a>
</span><span><a href=/tags/boltdb/>Boltdb</a>
</span><span><a href=/tags/breaker/>Breaker</a>
</span><span><a href=/tags/cdi/>Cdi</a>
</span><span><a href=/tags/cgroup/>Cgroup</a>
</span><span><a href=/tags/client-go/>Client-Go</a>
</span><span><a href=/tags/cni/>Cni</a>
</span><span><a href=/tags/containerd/>Containerd</a>
</span><span><a href=/tags/containerd-shim/>Containerd-Shim</a>
</span><span><a href=/tags/cri/>Cri</a>
</span><span><a href=/tags/csi/>Csi</a>
</span><span><a href=/tags/docker/>Docker</a>
</span><span><a href=/tags/etcd/>Etcd</a>
</span><span><a href=/tags/gin/>Gin</a>
</span><span><a href=/tags/go/>Go</a>
</span><span><a href=/tags/golang/>Golang</a>
</span><span><a href=/tags/grpc/>Grpc</a>
</span><span><a href=/tags/iptables/>Iptables</a>
</span><span><a href=/tags/ipvs/>Ipvs</a>
</span><span><a href=/tags/istio/>Istio</a>
</span><span><a href=/tags/kratos/>Kratos</a>
</span><span><a href=/tags/kube-proxy/>Kube-Proxy</a>
</span><span><a href=/tags/kubelet/>Kubelet</a>
</span><span><a href=/tags/kubernetes/>Kubernetes</a>
</span><span><a href=/tags/linux/>Linux</a>
</span><span><a href=/tags/lua/>Lua</a>
</span><span><a href=/tags/makefile/>Makefile</a>
</span><span><a href=/tags/mysql/>Mysql</a>
</span><span><a href=/tags/namespace/>Namespace</a>
</span><span><a href=/tags/network/>Network</a>
</span><span><a href=/tags/nginx/>Nginx</a>
</span><span><a href=/tags/opentelemetry/>Opentelemetry</a>
</span><span><a href=/tags/prometheus/>Prometheus</a>
</span><span><a href=/tags/protobuf/>Protobuf</a>
</span><span><a href=/tags/rabbitmq/>RabbitMQ</a>
</span><span><a href=/tags/redis/>Redis</a>
</span><span><a href=/tags/runc/>Runc</a>
</span><span><a href=/tags/service-mesh/>Service Mesh</a>
</span><span><a href=/tags/sidecar/>Sidecar</a>
</span><span><a href=/tags/sqlx/>Sqlx</a>
</span><span><a href=/tags/thrift/>Thrift</a>
</span><span><a href=/tags/unionfs/>UnionFS</a>
</span><span><a href=/tags/viper/>Viper</a>
</span><span><a href=/tags/vscode/>Vscode</a>
</span><span><a href=/tags/wire/>Wire</a>
</span><span><a href=/tags/zap/>Zap</a>
</span><span><a href=/tags/%E4%BA%8B%E5%8A%A1/>事务</a>
</span><span><a href=/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/>数据库</a>
</span><span><a href=/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/>源码分析</a>
</span><span><a href=/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>设计模式</a></span></div></div><div class="sidebar-item sidebar-toc"><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#gin框架介绍>Gin框架介绍</a></li><li><a href=#gin框架安装>Gin框架安装</a></li><li><a href=#restful-api>RESTful API</a></li><li><a href=#gin渲染>Gin渲染</a><ul><li><a href=#html渲染>HTML渲染</a></li><li><a href=#静态文件处理>静态文件处理</a></li><li><a href=#补充文件路径处理>补充文件路径处理</a></li><li><a href=#json渲染>JSON渲染</a></li><li><a href=#xml渲染>XML渲染</a></li><li><a href=#ymal渲染>YMAL渲染</a></li><li><a href=#protobuf渲染>protobuf渲染</a></li></ul></li><li><a href=#获取参数>获取参数</a><ul><li><a href=#获取querystring参数>获取querystring参数</a></li><li><a href=#获取form参数>获取form参数</a></li><li><a href=#获取path参数>获取path参数</a></li><li><a href=#参数绑定>参数绑定</a></li></ul></li><li><a href=#文件上传>文件上传</a><ul><li><a href=#多个文件上传>多个文件上传</a></li></ul></li><li><a href=#gin中间件>Gin中间件</a><ul><li><a href=#重定向>重定向</a></li></ul></li><li><a href=#gin路由>Gin路由</a><ul><li><a href=#普通路由>普通路由</a></li><li><a href=#路由组>路由组</a></li><li><a href=#路由分文件>路由分文件</a></li><li><a href=#路由原理>路由原理</a></li></ul></li><li><a href=#参考文章>参考文章</a></li></ul></nav></div></aside></div><div class=btn><div class=btn-menu id=btn-menu><i class="iconfont icon-grid-sharp"></i></div><div class=btn-toggle-mode><i class="iconfont icon-contrast-sharp"></i></div><div class=btn-scroll-top><i class="iconfont icon-chevron-up-circle-sharp"></i></div></div><aside class=sidebar-mobile style=display:none><div class=sidebar-wrapper><div class="sidebar-item sidebar-pages"><h3>Pages</h3><ul><li><a href=/>Home</a></li><li><a href=/archives/>Archives</a></li><li><a href=/index.xml>RSS</a></li><li><a href=/about/>About</a></li><li><a href=/search/>Search</a></li></ul></div><div class="sidebar-item sidebar-links"><h3>Links</h3><ul><li><a href=https://github.com/daemon365 target=_blank><span>My GitHub</span></a></li></ul></div><div class="sidebar-item sidebar-tags"><h3>Tags</h3><div><span><a href=/tags/bbr/>BBR</a>
</span><span><a href=/tags/boltdb/>Boltdb</a>
</span><span><a href=/tags/breaker/>Breaker</a>
</span><span><a href=/tags/cdi/>Cdi</a>
</span><span><a href=/tags/cgroup/>Cgroup</a>
</span><span><a href=/tags/client-go/>Client-Go</a>
</span><span><a href=/tags/cni/>Cni</a>
</span><span><a href=/tags/containerd/>Containerd</a>
</span><span><a href=/tags/containerd-shim/>Containerd-Shim</a>
</span><span><a href=/tags/cri/>Cri</a>
</span><span><a href=/tags/csi/>Csi</a>
</span><span><a href=/tags/docker/>Docker</a>
</span><span><a href=/tags/etcd/>Etcd</a>
</span><span><a href=/tags/gin/>Gin</a>
</span><span><a href=/tags/go/>Go</a>
</span><span><a href=/tags/golang/>Golang</a>
</span><span><a href=/tags/grpc/>Grpc</a>
</span><span><a href=/tags/iptables/>Iptables</a>
</span><span><a href=/tags/ipvs/>Ipvs</a>
</span><span><a href=/tags/istio/>Istio</a>
</span><span><a href=/tags/kratos/>Kratos</a>
</span><span><a href=/tags/kube-proxy/>Kube-Proxy</a>
</span><span><a href=/tags/kubelet/>Kubelet</a>
</span><span><a href=/tags/kubernetes/>Kubernetes</a>
</span><span><a href=/tags/linux/>Linux</a>
</span><span><a href=/tags/lua/>Lua</a>
</span><span><a href=/tags/makefile/>Makefile</a>
</span><span><a href=/tags/mysql/>Mysql</a>
</span><span><a href=/tags/namespace/>Namespace</a>
</span><span><a href=/tags/network/>Network</a>
</span><span><a href=/tags/nginx/>Nginx</a>
</span><span><a href=/tags/opentelemetry/>Opentelemetry</a>
</span><span><a href=/tags/prometheus/>Prometheus</a>
</span><span><a href=/tags/protobuf/>Protobuf</a>
</span><span><a href=/tags/rabbitmq/>RabbitMQ</a>
</span><span><a href=/tags/redis/>Redis</a>
</span><span><a href=/tags/runc/>Runc</a>
</span><span><a href=/tags/service-mesh/>Service Mesh</a>
</span><span><a href=/tags/sidecar/>Sidecar</a>
</span><span><a href=/tags/sqlx/>Sqlx</a>
</span><span><a href=/tags/thrift/>Thrift</a>
</span><span><a href=/tags/unionfs/>UnionFS</a>
</span><span><a href=/tags/viper/>Viper</a>
</span><span><a href=/tags/vscode/>Vscode</a>
</span><span><a href=/tags/wire/>Wire</a>
</span><span><a href=/tags/zap/>Zap</a>
</span><span><a href=/tags/%E4%BA%8B%E5%8A%A1/>事务</a>
</span><span><a href=/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/>数据库</a>
</span><span><a href=/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/>源码分析</a>
</span><span><a href=/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>设计模式</a></span></div></div><div class="sidebar-item sidebar-toc"><h3>Table of Contents</h3><nav id=TableOfContents><ul><li><a href=#gin框架介绍>Gin框架介绍</a></li><li><a href=#gin框架安装>Gin框架安装</a></li><li><a href=#restful-api>RESTful API</a></li><li><a href=#gin渲染>Gin渲染</a><ul><li><a href=#html渲染>HTML渲染</a></li><li><a href=#静态文件处理>静态文件处理</a></li><li><a href=#补充文件路径处理>补充文件路径处理</a></li><li><a href=#json渲染>JSON渲染</a></li><li><a href=#xml渲染>XML渲染</a></li><li><a href=#ymal渲染>YMAL渲染</a></li><li><a href=#protobuf渲染>protobuf渲染</a></li></ul></li><li><a href=#获取参数>获取参数</a><ul><li><a href=#获取querystring参数>获取querystring参数</a></li><li><a href=#获取form参数>获取form参数</a></li><li><a href=#获取path参数>获取path参数</a></li><li><a href=#参数绑定>参数绑定</a></li></ul></li><li><a href=#文件上传>文件上传</a><ul><li><a href=#多个文件上传>多个文件上传</a></li></ul></li><li><a href=#gin中间件>Gin中间件</a><ul><li><a href=#重定向>重定向</a></li></ul></li><li><a href=#gin路由>Gin路由</a><ul><li><a href=#普通路由>普通路由</a></li><li><a href=#路由组>路由组</a></li><li><a href=#路由分文件>路由分文件</a></li><li><a href=#路由原理>路由原理</a></li></ul></li><li><a href=#参考文章>参考文章</a></li></ul></nav></div></div></aside></main><footer><div class="container-lg clearfix"><div class="col-12 footer"><span>&copy; 2019-2024
<a href=https://daemon365.dev/>daemon365</a>
| Powered by <a href=https://github.com/dsrkafuu/hugo-theme-fuji/ target=_blank>Fuji-v2</a> & <a href=https://gohugo.io/ target=_blank>Hugo</a></span></div></div></footer><script defer src=https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js integrity="sha512-q583ppKrCRc7N5O0n2nzUiJ+suUv7Et1JGels4bXOaMFQcamPk9HjdUknZuuFjBNs7tsMuadge5k9RzdmO+1GQ==" crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1.27.0/components/prism-core.min.js integrity="sha512-LCKPTo0gtJ74zCNMbWw04ltmujpzSR4oW+fgN+Y1YclhM5ZrHCZQAJE4quEodcI/G122sRhSGU2BsSRUZ2Gu3w==" crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/prismjs@1.27.0/plugins/autoloader/prism-autoloader.min.js integrity="sha512-GP4x8UWxWyh4BMbyJGOGneiTbkrWEF5izsVJByzVLodP8CuJH/n936+yQDMJJrOPUHLgyPbLiGw2rXmdvGdXHA==" crossorigin=anonymous></script><script defer src=/assets/js/fuji.min.645f1123be695831f419ab54c1bcba327325895c740014006e57070d4f3e5d6b553e929c4b46f40ea707249e9c7f7c2a446d32a39ce7319f80a34525586a8e0f.js integrity="sha512-ZF8RI75pWDH0GatUwby6MnMliVx0ABQAblcHDU8+XWtVPpKcS0b0DqcHJJ6cf3wqRG0yo5znMZ+Ao0UlWGqODw=="></script></body></html>