<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Daemon</title><link>https://daemon365.dev/</link><description>Recent content on Daemon</description><generator>Hugo</generator><language>en</language><lastBuildDate>Sat, 15 Jun 2024 16:14:00 +0800</lastBuildDate><atom:link href="https://daemon365.dev/index.xml" rel="self" type="application/rss+xml"/><item><title>boltdb 原理</title><link>https://daemon365.dev/2024/06/15/boltdb-%E5%8E%9F%E7%90%86/</link><pubDate>Sat, 15 Jun 2024 16:14:00 +0800</pubDate><guid>https://daemon365.dev/2024/06/15/boltdb-%E5%8E%9F%E7%90%86/</guid><description>简介 介绍及简单使用：https://www.cnblogs.com/daemon365/p/17690167.html 源码地址：https://github.com/etcd-io/bbolt page 因为 boltdb</description></item><item><title>etcd watch 实现原理</title><link>https://daemon365.dev/2024/06/10/etcd-watch-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</link><pubDate>Mon, 10 Jun 2024 14:16:00 +0800</pubDate><guid>https://daemon365.dev/2024/06/10/etcd-watch-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</guid><description>介绍 在 etcd 中，watch 是一个非常重要的特性，它可以让客户端监控 etcd 中的 key 或者一组 key，当 key 发生变化时，etcd 会通知客户端。本文将介绍 etcd watch 的实现原理。 etcdctl watch /test # 当 /test 的值发生变化时，会输出如下信息 PUT /test a PUT</description></item><item><title>etcd MVCC 存储结构及流程</title><link>https://daemon365.dev/2024/05/26/etcd-mvcc-%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%8F%8A%E6%B5%81%E7%A8%8B/</link><pubDate>Sun, 26 May 2024 18:00:00 +0800</pubDate><guid>https://daemon365.dev/2024/05/26/etcd-mvcc-%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%8F%8A%E6%B5%81%E7%A8%8B/</guid><description>什么是 MVCC MVCC 是 Multi-Version Concurrency Control 的缩写，即多版本并发控制。它是一种并发控制的方法，用于在数据库系统中实现事务的隔离性。MVCC 是一种乐观锁机制，它通过保存数据的多个版本来实现事务的隔禽性。在 etcd 中，MVCC 是用于实现</description></item><item><title>istio sidecar 工作方式</title><link>https://daemon365.dev/2024/05/12/istio-sidecar-%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F/</link><pubDate>Sun, 12 May 2024 17:40:00 +0800</pubDate><guid>https://daemon365.dev/2024/05/12/istio-sidecar-%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F/</guid><description>istio 是什么 Istio 是一个开放源代码的服务网格，它为基于微服务的应用程序提供了一种统一的方式来连接、保护、监控和管理服务。Istio 主要解决的是在微服务架构中的服务间通信的复杂性问题，它通过提供服务间的负载均衡</description></item><item><title>docker containerd runc containerd-shim等组件的关系</title><link>https://daemon365.dev/2024/05/09/docker-containerd-runc-containerd-shim%E7%AD%89%E7%BB%84%E4%BB%B6%E7%9A%84%E5%85%B3%E7%B3%BB/</link><pubDate>Thu, 09 May 2024 20:56:00 +0800</pubDate><guid>https://daemon365.dev/2024/05/09/docker-containerd-runc-containerd-shim%E7%AD%89%E7%BB%84%E4%BB%B6%E7%9A%84%E5%85%B3%E7%B3%BB/</guid><description>早期 kubelet 创建容器工作原理 因为 docker 出生的比 k8s 早，所以 k8s 早期的容器运行时都是基于 docker 的，kubelet 通过 docker 的 api 创建容器。后来，k8s 官方不想绑死在 docker 这架马车上，就把容器运行时抽象出来，定义了一个接口，叫 CRI (container runtime</description></item><item><title>boltdb 介绍</title><link>https://daemon365.dev/2024/05/08/boltdb-%E4%BB%8B%E7%BB%8D/</link><pubDate>Wed, 08 May 2024 20:56:00 +0800</pubDate><guid>https://daemon365.dev/2024/05/08/boltdb-%E4%BB%8B%E7%BB%8D/</guid><description>介绍 BoltDB 是一个用 Go 语言编写的嵌入式键/值数据库。以下是关于 BoltDB 的一些基本介绍： 键/值存储: BoltDB 为应用程序提供了简单的键/值存储接口。 事务: BoltDB 支持完整的 ACID 事务。 嵌入式: 与像 MySQL 或 PostgreSQL 这样的数据库系统不同，Bolt</description></item><item><title>kube-proxy 流量流转方式</title><link>https://daemon365.dev/2024/05/08/kube-proxy-%E6%B5%81%E9%87%8F%E6%B5%81%E8%BD%AC%E6%96%B9%E5%BC%8F/</link><pubDate>Wed, 08 May 2024 17:40:00 +0800</pubDate><guid>https://daemon365.dev/2024/05/08/kube-proxy-%E6%B5%81%E9%87%8F%E6%B5%81%E8%BD%AC%E6%96%B9%E5%BC%8F/</guid><description>简介 kube-proxy 是 Kubernetes 集群中负责服务发现和负载均衡的组件之一。它是一个网络代理，运行在每个节点上, 用于 service 资源的负载均衡。它有两种模式：iptables 和 ipvs。 iptables iptables 是 Linux 系统中的一个用户空间实用程序，用于配置内核</description></item><item><title>kubernetes 存储流程</title><link>https://daemon365.dev/2024/05/03/kubernetes-%E5%AD%98%E5%82%A8%E6%B5%81%E7%A8%8B/</link><pubDate>Fri, 03 May 2024 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2024/05/03/kubernetes-%E5%AD%98%E5%82%A8%E6%B5%81%E7%A8%8B/</guid><description>PV 与 PVC PVC (PersistentVolumeClaim)，命名空间（namespace）级别的资源，由 用户 or StatefulSet 控制器（根据VolumeClaimTemplate） 创建。PVC 类似于 Pod，Pod 消耗 Node 资</description></item><item><title>kubelet 原理分析</title><link>https://daemon365.dev/2024/05/01/kubelet-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</link><pubDate>Wed, 01 May 2024 12:40:00 +0800</pubDate><guid>https://daemon365.dev/2024/05/01/kubelet-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</guid><description>Reference https://atbug.com/kubelet-source-code-analysis/ kubelet 简介 kubernetes 分为控制面和数据面，kubelet 就是数据面最主要的组件，在每个节点上启动，主要负责容器的创建、启停、监控、日志收集等工作。它是一个在每个集群节点上运行的代理，负责确保节点上的容器根据Po</description></item><item><title>kubernetes CNI(Container Network Inferface)</title><link>https://daemon365.dev/2024/04/20/kubernetes-cnicontainer-network-inferface/</link><pubDate>Sat, 20 Apr 2024 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2024/04/20/kubernetes-cnicontainer-network-inferface/</guid><description>为什么需要 CNI 在 kubernetes 中，pod 的网络是使用 network namespace 隔离的，但是我们有时又需要互相访问网络，这就需要一个网络插件来实现 pod 之间的网络通信。CNI 就是为了解决这个问题而诞生的。CNI 是 container network interface 的缩写，它是一个规范，定</description></item><item><title>kubernetes client-go功能介绍</title><link>https://daemon365.dev/2024/03/08/kubernetes-client-go%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D/</link><pubDate>Fri, 08 Mar 2024 17:11:00 +0800</pubDate><guid>https://daemon365.dev/2024/03/08/kubernetes-client-go%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D/</guid><description>原文地址 https://haiyux.cc/2023/02/26/k8s-client-go/ client-go是什么？ client-go是Kubernetes官方提供的Go语言客户端库，用于与Kubernetes API服务器交互。使用client-go，您可以编写Go语言程序来创建</description></item><item><title>容器启动流程（containerd 和 runc）</title><link>https://daemon365.dev/2023/12/07/%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8Bcontainerd-%E5%92%8C-runc/</link><pubDate>Thu, 07 Dec 2023 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2023/12/07/%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8Bcontainerd-%E5%92%8C-runc/</guid><description>启动流程 containerd 作为一个 api 服务，提供了一系列的接口供外部调用，比如创建容器、删除容器、创建镜像、删除镜像等等。使用 docker 和 ctr 等工具，都是通过调用 containerd 的 api 来实现的。 kubelet 通过 cri 调用 containerd 和这些不一样，后续我会介绍到。 containerd 创建</description></item><item><title>kubernetes container device interface (CDI)</title><link>https://daemon365.dev/2023/11/19/kubernetes-container-device-interface-cdi/</link><pubDate>Sun, 19 Nov 2023 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2023/11/19/kubernetes-container-device-interface-cdi/</guid><description>CDI 是什么？ Container Device Interface (CDI) 是一个提议的标准，它定义了如何在容器运行时环境中向容器提供设备。这个提议的目的是使得设备供应商能够更容易地将其设备集成到 Kubernetes 集群中，而不必修改 Kubernetes 核心代码。 CDI 插件通常负责： 配置设备以供容</description></item><item><title>行为模式</title><link>https://daemon365.dev/2023/09/25/%E8%A1%8C%E4%B8%BA%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 25 Sep 2023 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2023/09/25/%E8%A1%8C%E4%B8%BA%E6%A8%A1%E5%BC%8F/</guid><description>责任链模式 责任链模式是一种行为设计模式， 允许你将请求沿着处理者链进行发送。 收到请求后， 每个处理者均可对请求进行处理， 或将其传递给链上的下个处理者。比如 kratos,gin等开源库的中间件实现。 代码实现</description></item><item><title>结构型模式</title><link>https://daemon365.dev/2023/09/24/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/</link><pubDate>Sun, 24 Sep 2023 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2023/09/24/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/</guid><description>适配器模式 适配器模式用于转换一种接口适配另一种接口。比如，现在有个借口是对json字符串进行分析等，现在有一些yaml文件也要分析，这时候我我们就应该给yaml字符串就个适配器，转换成json字符串，</description></item><item><title>创建者模式</title><link>https://daemon365.dev/2023/09/23/%E5%88%9B%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F/</link><pubDate>Sat, 23 Sep 2023 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2023/09/23/%E5%88%9B%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F/</guid><description>单例模式 为什么要用单例模式 保证一个对象只有一个实例 ，减少内存开销。比如一些可以复用一个连接的网络，比如http2 client等，而且可以减少网络开销。 为什么不用个全局变量控制 因为任何代码都有可能覆盖掉</description></item><item><title>redis主从同步</title><link>https://daemon365.dev/2023/08/20/redis%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5/</link><pubDate>Sun, 20 Aug 2023 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2023/08/20/redis%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5/</guid><description>redis主从同步 原理： 从服务器向主服务器发送 SYNC 命令。 接到 SYNC 命令的主服务器会调用BGSAVE 命令，创建一个 RDB 文件，并使用缓冲区记录接下来执行的所有写命令。 当主服务器执行完 BGSAVE 命令时，它会向从服务器发送 RDB</description></item><item><title>kratos http原理</title><link>https://daemon365.dev/2023/06/29/kratos-http%E5%8E%9F%E7%90%86/</link><pubDate>Thu, 29 Jun 2023 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2023/06/29/kratos-http%E5%8E%9F%E7%90%86/</guid><description>概念 kratos 为了使http协议的逻辑代码和grpc的逻辑代码使用同一份，选择了基于protobuf的IDL文件使用proto插件生成辅助代码的方式。 protoc http插件的地址为：https://github.co</description></item><item><title>容器基础-- namespace,Cgroup 和 UnionFS</title><link>https://daemon365.dev/2023/06/24/%E5%AE%B9%E5%99%A8%E5%9F%BA%E7%A1%80--namespacecgroup-%E5%92%8C-unionfs/</link><pubDate>Sat, 24 Jun 2023 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2023/06/24/%E5%AE%B9%E5%99%A8%E5%9F%BA%E7%A1%80--namespacecgroup-%E5%92%8C-unionfs/</guid><description>Namespace 什么是 Namespace ？ 这里的 &amp;ldquo;namespace&amp;rdquo; 指的是 Linux namespace 技术，它是 Linux 内核实现的一种隔离方案。简而言之，Linux 操作系统能够为不同的进程分配不同的 namespace，每个 namespace 都具有独立的资源分配，从而实现了进程间的隔离。如果你的</description></item><item><title>RabbitMQ消息队列</title><link>https://daemon365.dev/2023/05/20/rabbitmq%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</link><pubDate>Sat, 20 May 2023 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2023/05/20/rabbitmq%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</guid><description>消息队列 本篇文章主要介绍了 RabbitMQ 这种消息队列，从消息队列的概念、应用场景、安装方式到它的核心概念、五种工作模式。在安装的时候推荐使用 Docker 方式进行安装。重点需要理解的就是消息队列的应用场景、核心概念和 RabbitMQ 的五种</description></item><item><title>http和https</title><link>https://daemon365.dev/2023/01/25/http%E5%92%8Chttps/</link><pubDate>Wed, 25 Jan 2023 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2023/01/25/http%E5%92%8Chttps/</guid><description>HTTP协议是什么？ HTTP协议是超文本传输协议的缩写，英文是Hyper Text Transfer Protocol。它是从WEB服务器传输超文本标记语言(HTML)到本地浏览器的传送协议。 设计HTTP最初的目的是为了提供一</description></item><item><title>golang操作etcd</title><link>https://daemon365.dev/2023/01/08/golang%E6%93%8D%E4%BD%9Cetcd/</link><pubDate>Sun, 08 Jan 2023 20:56:00 +0800</pubDate><guid>https://daemon365.dev/2023/01/08/golang%E6%93%8D%E4%BD%9Cetcd/</guid><description>etcd是近几年比较火热的一个开源的、分布式的键值对数据存储系统，提供共享配置、服务的注册和发现，本文主要介绍etcd的安装和使用。 etcd介绍 etcd是使用Go语言开发的一个开源的、高可用的分布式k</description></item><item><title>隔离</title><link>https://daemon365.dev/2022/12/25/%E9%9A%94%E7%A6%BB/</link><pubDate>Sun, 25 Dec 2022 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2022/12/25/%E9%9A%94%E7%A6%BB/</guid><description>什么是隔离？ 隔离，本质上是对系统或资源进行分割，从而实现当系统发生故障时能限定传播范围和影响范围，即发生故障后只有出问题的服务不可用，保证其他服务仍然可用。 服务隔离 动静隔离 例如 CDN 小到 CPU 的 cacheline false shari</description></item><item><title>限流</title><link>https://daemon365.dev/2022/12/24/%E9%99%90%E6%B5%81/</link><pubDate>Sat, 24 Dec 2022 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2022/12/24/%E9%99%90%E6%B5%81/</guid><description>令牌桶算法 是一个存放固定容量令牌的桶，按照固定速率往桶里添加令牌。令牌桶算法的描述如下： 假设限制2r/s，则按照500毫秒的固定速率往桶中添加令牌。 桶中最多存放 b 个令牌，当桶满时，新添加的令牌被丢弃或</description></item><item><title>超时控制</title><link>https://daemon365.dev/2022/12/23/%E8%B6%85%E6%97%B6%E6%8E%A7%E5%88%B6/</link><pubDate>Fri, 23 Dec 2022 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2022/12/23/%E8%B6%85%E6%97%B6%E6%8E%A7%E5%88%B6/</guid><description>什么是超时控制？ 超时控制，使我们的服务之间调用可以快速抛错。比如API接口设置1s超时API调用A服务用了500ms，服务A调用和服务B用了600ms，n那么现在已经超时，还要调用服务C等等，再返回超</description></item><item><title>Go命令行工具cobra</title><link>https://daemon365.dev/2022/12/21/go%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7cobra/</link><pubDate>Wed, 21 Dec 2022 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2022/12/21/go%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7cobra/</guid><description>关于 Cobra 是 Go 的 CLI 框架。它包含一个用于创建功能强大的现代 CLI 应用程序的库，以及一个用于快速生成基于 Cobra 的应用程序和命令文件的工具。 Cobra 由 Go 项目成员和 hugo 作者 spf13 创建，已经被许多流行的 Go 项目采用，比如 kubernet</description></item><item><title>lua基础</title><link>https://daemon365.dev/2022/10/25/lua%E5%9F%BA%E7%A1%80/</link><pubDate>Tue, 25 Oct 2022 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2022/10/25/lua%E5%9F%BA%E7%A1%80/</guid><description>什么是lua Lua是一个小巧的脚本语言。它是巴西里约热内卢天主教大学（Pontifical Catholic University of Rio de Janeiro）里的一个由Roberto Ierusalimschy、Waldemar Celes 和 Luiz Henrique de Fig</description></item><item><title>kubernetes集群最新版安装</title><link>https://daemon365.dev/2022/09/22/kubernetes%E9%9B%86%E7%BE%A4%E6%9C%80%E6%96%B0%E7%89%88%E5%AE%89%E8%A3%85/</link><pubDate>Thu, 22 Sep 2022 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2022/09/22/kubernetes%E9%9B%86%E7%BE%A4%E6%9C%80%E6%96%B0%E7%89%88%E5%AE%89%E8%A3%85/</guid><description>原文地址：https://haiyux.cc/2022/09/21/k8s-install/ 虚拟机准备 我这里准备了三台虚拟机，分别部署一个master和两个node，操作系统位ubuntu 20.04。</description></item><item><title>redis发布订阅</title><link>https://daemon365.dev/2022/08/20/redis%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/</link><pubDate>Sat, 20 Aug 2022 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2022/08/20/redis%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/</guid><description>什么是发布和订阅 Redis 发布订阅 (pub/sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。 Redis 客户端可以订阅任意数量的频道。 发布和订阅 1、客户端可以订阅频道如下图 2、当给这个频道发布消息后，消息就会发送给订阅</description></item><item><title>vscode常用快捷键及插件</title><link>https://daemon365.dev/2022/03/25/vscode%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%8F%8A%E6%8F%92%E4%BB%B6/</link><pubDate>Fri, 25 Mar 2022 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2022/03/25/vscode%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%8F%8A%E6%8F%92%E4%BB%B6/</guid><description>macOS 全局 Command + Shift + P / F1 显示命令面板 Command + P 快速打开 Command + Shift + N 打开新窗口 Command + W 关闭窗口 基本 Command + X 剪切（未选中文本的情况下，剪切光标所在行） Command + C 复制（未选中文本的情况下，复制光标所在行） ``Option + Up` 向上移动行 Option +</description></item><item><title>makefile</title><link>https://daemon365.dev/2021/12/15/makefile/</link><pubDate>Wed, 15 Dec 2021 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2021/12/15/makefile/</guid><description>make make是一个构建自动化工具，会在当前目录下寻找Makefile或makefile文件。如果存在相应的文件，它就会依据其中定义好的规则完成构建任务。 makefile 什么是makefile？或许很多Winodws的</description></item><item><title>Go工程化 - 依赖注入</title><link>https://daemon365.dev/2021/09/30/go%E5%B7%A5%E7%A8%8B%E5%8C%96-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</link><pubDate>Thu, 30 Sep 2021 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2021/09/30/go%E5%B7%A5%E7%A8%8B%E5%8C%96-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</guid><description>我们在微服务框架kratos v2的默认项目模板中kratos-layout使用了google/wire进行依赖注入，也建议开发者在维护项目时使用该工具。 wire 乍看起来比较违反直觉，导致很多同学不理解为什么</description></item><item><title>kratos v2版本命令行工具使用</title><link>https://daemon365.dev/2021/09/12/kratos-v2%E7%89%88%E6%9C%AC%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/</link><pubDate>Sun, 12 Sep 2021 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2021/09/12/kratos-v2%E7%89%88%E6%9C%AC%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/</guid><description>使用 下载 go install github.com/go-kratos/kratos/cmd/kratos/v2@latest 查看是否安装成功 kratos -v kratos version v2.1.3 升级 kratos upgrade 查看帮助 kratos --help Kratos: An elegant toolkit for Go microservices. Usage: kratos [command] Available Commands: changelog Get a kratos change log completion generate the autocompletion script for the specified shell help Help about any command new Create a service template proto Generate the proto files run Run project upgrade Upgrade the kratos tools Flags: -h, --help help for kratos -v, --version version for kratos Use &amp;quot;kratos [command] --help&amp;quot; for more information about a</description></item><item><title>从kratos分析breaker熔断器源码实现</title><link>https://daemon365.dev/2021/09/04/%E4%BB%8Ekratos%E5%88%86%E6%9E%90breaker%E7%86%94%E6%96%AD%E5%99%A8%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0/</link><pubDate>Sat, 04 Sep 2021 17:55:01 +0800</pubDate><guid>https://daemon365.dev/2021/09/04/%E4%BB%8Ekratos%E5%88%86%E6%9E%90breaker%E7%86%94%E6%96%AD%E5%99%A8%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0/</guid><description>为什么要用熔断 前面我们讲过限流保证服务的可用性，不被突如其来的流量打爆。但是两种情况是限流解决不了的。 如果我们服务只能处理1000QPS，但是有10wQPS打过来，服务还是会炸。因为拒绝请求也需要成本</description></item><item><title>从kratos分析BBR限流源码实现</title><link>https://daemon365.dev/2021/09/04/%E4%BB%8Ekratos%E5%88%86%E6%9E%90bbr%E9%99%90%E6%B5%81%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0/</link><pubDate>Sat, 04 Sep 2021 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2021/09/04/%E4%BB%8Ekratos%E5%88%86%E6%9E%90bbr%E9%99%90%E6%B5%81%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0/</guid><description>什么是自适应限流 自适应限流从整体维度对应用入口流量进行控制，结合应用的 Load、CPU 使用率、总体平均 RT、入口 QPS 和并发线程数等几个维度的监控指标，通过自适应的流控策略，让系统的入口流量和系统的负载达</description></item><item><title>Kratos漫游指南 1 - 概览</title><link>https://daemon365.dev/2021/09/02/kratos%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%97-1-%E6%A6%82%E8%A7%88/</link><pubDate>Thu, 02 Sep 2021 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2021/09/02/kratos%E6%BC%AB%E6%B8%B8%E6%8C%87%E5%8D%97-1-%E6%A6%82%E8%A7%88/</guid><description>您好，地球人，欢迎来到Kratos漫游指南。 对于刚开始研究Kratos框架的开发者来说，目前的文档有些零散，这与我们的模块化设计有一些关系，不过Don&amp;rsquo;t panic，从这篇文章开始，我将试</description></item><item><title>基于 OpenTelemetry 的链路追踪</title><link>https://daemon365.dev/2021/08/23/%E5%9F%BA%E4%BA%8E-opentelemetry-%E7%9A%84%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/</link><pubDate>Mon, 23 Aug 2021 18:11:50 +0800</pubDate><guid>https://daemon365.dev/2021/08/23/%E5%9F%BA%E4%BA%8E-opentelemetry-%E7%9A%84%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/</guid><description>链路追踪的前世今生 分布式跟踪（也称为分布式请求跟踪）是一种用于分析和监控应用程序的方法，尤其是使用微服务架构构建的应用程序。分布式跟踪有助于精确定位故障发生的位置以及导致性能差的原因。 起源 链路追踪(D</description></item><item><title>通过 layout 探索 kratos 运行原理</title><link>https://daemon365.dev/2021/08/20/%E9%80%9A%E8%BF%87-layout-%E6%8E%A2%E7%B4%A2-kratos-%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/</link><pubDate>Fri, 20 Aug 2021 18:11:50 +0800</pubDate><guid>https://daemon365.dev/2021/08/20/%E9%80%9A%E8%BF%87-layout-%E6%8E%A2%E7%B4%A2-kratos-%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/</guid><description>创建项目 首先需要安装好对应的依赖环境，以及工具： go 下载 protoc go install google.golang.org/protobuf/cmd/protoc-gen-go@latest protoc-gen-go go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest # 创建项目模板 kratos new helloworld cd helloworld # 拉取项目依赖 go mod download # 生成proto模板 kratos proto add api/helloworld/helloworld.proto # 生成proto源码 kratos proto client api/helloworld/helloworld.proto # 生成server模板 kratos proto server api/helloworld/helloworld.proto</description></item><item><title>Prometheus</title><link>https://daemon365.dev/2021/08/20/prometheus/</link><pubDate>Fri, 20 Aug 2021 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2021/08/20/prometheus/</guid><description>Prometheus简介 什么是 Prometheus Prometheus 是在 Soundcloud 以开源软件的形式进行研发的系统监控和告警工具包，自此以后，许多公司和组织都采用了 Prometheus 作为监控告警工具。Prometheus 的开发者和用户社区非常活跃，它现在是一个</description></item><item><title>kratos 日志库的使用姿势</title><link>https://daemon365.dev/2021/08/19/kratos-%E6%97%A5%E5%BF%97%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/</link><pubDate>Thu, 19 Aug 2021 18:11:50 +0800</pubDate><guid>https://daemon365.dev/2021/08/19/kratos-%E6%97%A5%E5%BF%97%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/</guid><description>什么是日志 所谓日志（Log）是指系统所指定对象的某些操作和其操作结果按时间有序的集合。log文件就是日志文件，log文件记录了系统和系统的用户之间交互的信息，是自动捕获人与系统终端之间交互的类型、内容</description></item><item><title>Linux基础系统优化</title><link>https://daemon365.dev/2021/08/19/linux%E5%9F%BA%E7%A1%80%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96/</link><pubDate>Thu, 19 Aug 2021 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2021/08/19/linux%E5%9F%BA%E7%A1%80%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96/</guid><description>Linux基础系统优化 Linux的网络功能相当强悍，一时之间我们无法了解所有的网络命令，在配置服务器基础环境时，先了解下网络参数设定命令。 ifconfig 查询、设置网卡和ip等参数 ifup,ifdown 脚本命令，更简单的方式启动关闭网</description></item><item><title>Linux核心知识</title><link>https://daemon365.dev/2021/08/15/linux%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/</link><pubDate>Sun, 15 Aug 2021 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2021/08/15/linux%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/</guid><description>电脑：辅助人脑的工具 现在的人们几乎无时无刻都会碰电脑！不管是桌上型电脑(桌机)、笔记型电脑(笔电)、平板电脑、智慧型手机等等，这些东西都算是电脑。虽然接触的这么多，但是，你了解电脑里面的元件有什么吗？</description></item><item><title>Linux常用命令</title><link>https://daemon365.dev/2021/08/11/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link><pubDate>Wed, 11 Aug 2021 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2021/08/11/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid><description>常用指令 ls 显示文件或目录 -l 列出文件详细信息l(list) -a 列出当前目录下所有文件及目录，包括隐藏的a(all) mkdir 创建目录 -p 创建目录，若无父目录，则创建p(parent) cd 切换目录 touch 创建空文件 echo 创建带有</description></item><item><title>微服务架构及raft协议</title><link>https://daemon365.dev/2021/05/30/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E5%8F%8Araft%E5%8D%8F%E8%AE%AE/</link><pubDate>Sun, 30 May 2021 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2021/05/30/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E5%8F%8Araft%E5%8D%8F%E8%AE%AE/</guid><description>微服务架构全景图 服务注册和发现 Client side implement 调用需要维护所有调用服务的地址 有一定的技术难度，需要rpc框架支持 Server side implement 架构简单 有单点故障 注册中心 etcd注册中心 分布式一致性系统 基于raft一致性协议 etcd使用</description></item><item><title>golang map实现原理</title><link>https://daemon365.dev/2021/05/22/golang-map%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</link><pubDate>Sat, 22 May 2021 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2021/05/22/golang-map%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</guid><description>这篇文章主要讲 map 的赋值、删除、查询、扩容的具体执行过程，仍然是从底层的角度展开。结合源码，看完本文一定会彻底明白 map 底层原理。 我要说明的是，这里对 map 的基本用法涉及比较少，我相信可以通过阅读其他入门书籍了</description></item><item><title>分布式ID生成器及redis，etcd分布式锁</title><link>https://daemon365.dev/2021/04/30/%E5%88%86%E5%B8%83%E5%BC%8Fid%E7%94%9F%E6%88%90%E5%99%A8%E5%8F%8Aredisetcd%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</link><pubDate>Fri, 30 Apr 2021 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2021/04/30/%E5%88%86%E5%B8%83%E5%BC%8Fid%E7%94%9F%E6%88%90%E5%99%A8%E5%8F%8Aredisetcd%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</guid><description>分布式id生成器 有时我们需要能够生成类似MySQL自增ID这样不断增大，同时又不会重复的id。以支持业务中的高并发场景。比较典型的，电商促销时，短时间内会有大量的订单涌入到系统，比如每秒10w+。明星</description></item><item><title>zap高性能日志</title><link>https://daemon365.dev/2021/03/23/zap%E9%AB%98%E6%80%A7%E8%83%BD%E6%97%A5%E5%BF%97/</link><pubDate>Tue, 23 Mar 2021 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2021/03/23/zap%E9%AB%98%E6%80%A7%E8%83%BD%E6%97%A5%E5%BF%97/</guid><description>摘要 日志在整个工程实践中的重要性不言而喻，在选择日志组件的时候也有多方面的考量。详细、正确和及时的反馈是必不可少的，但是整个性能表现是否也是必要考虑的点呢？在长期的实践中发现有的日志组件对于计算资源的</description></item><item><title>golang channel原理</title><link>https://daemon365.dev/2021/02/21/golang-channel%E5%8E%9F%E7%90%86/</link><pubDate>Sun, 21 Feb 2021 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2021/02/21/golang-channel%E5%8E%9F%E7%90%86/</guid><description>channel介绍 channel一个类型管道，通过它可以在goroutine之间发送和接收消息。它是Golang在语言层面提供的goroutine间的通信方式。 众所周知，Go依赖于称为CSP（Comm</description></item><item><title>golang GC 垃圾回收机制</title><link>https://daemon365.dev/2021/02/20/golang-gc-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</link><pubDate>Sat, 20 Feb 2021 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2021/02/20/golang-gc-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</guid><description>垃圾回收(Garbage Collection，简称GC)是编程语言中提供的自动的内存管理机制，自动释放不需要的对象，让出存储器资源，无需程序员手动执行。 Golang中的垃圾回收主要应用三色标记法，GC</description></item><item><title>viper配置管理</title><link>https://daemon365.dev/2021/01/23/viper%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86/</link><pubDate>Sat, 23 Jan 2021 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2021/01/23/viper%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86/</guid><description>安装 go get github.com/spf13/viper viper支持的功能 1、可以设置默认值 2、可以加载多种格式的配置文件，如JSON，TOML，YAML，HCL和Java属性配置文件 3、应用程序运行过程中，保持监听和重新读取配置文件 4、可以从</description></item><item><title>docker</title><link>https://daemon365.dev/2021/01/10/docker/</link><pubDate>Sun, 10 Jan 2021 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2021/01/10/docker/</guid><description>docker的定义 Docker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公司内部项目，于 2013 年 3 月以 Apache 2.0 授权协议开源，主要项目代码在 GitHub 上进行维护。 Docker 使用 Google 公司推出的 Go 语言 进行开发实现。 docker是linux容器</description></item><item><title>golangHTML标签提取器soup</title><link>https://daemon365.dev/2021/01/05/golanghtml%E6%A0%87%E7%AD%BE%E6%8F%90%E5%8F%96%E5%99%A8soup/</link><pubDate>Tue, 05 Jan 2021 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2021/01/05/golanghtml%E6%A0%87%E7%AD%BE%E6%8F%90%E5%8F%96%E5%99%A8soup/</guid><description>什么是soup 类似python中beatifulsoup，用于提取html标签提取，多用于爬虫。它可以很好的处理不规范标记并生成剖析树(parse tree)。 它提供简单又常用的导航，搜索以及修改剖析树</description></item><item><title>thrift的介绍及其使用</title><link>https://daemon365.dev/2020/12/30/thrift%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8/</link><pubDate>Wed, 30 Dec 2020 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2020/12/30/thrift%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8/</guid><description>什么是thrift Thrift是Facebook于2007年开发的跨语言的rpc服框架，提供多语言的编译功能，并提供多种服务器工作模式；用户通过Thrift的IDL（接口定义语言）来描述接口函数及数据</description></item><item><title>grpc服务发现与负载均衡</title><link>https://daemon365.dev/2020/12/20/grpc%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E4%B8%8E%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</link><pubDate>Sun, 20 Dec 2020 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2020/12/20/grpc%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E4%B8%8E%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</guid><description>前言 在后台服务开发中，高可用性是构建中核心且重要的一环。服务发现（Service discovery）和负载均衡（Load Balance）一直都是我关注的话题。今天来谈一下我在实际中是如何理解及落地的。</description></item><item><title>grpc基础</title><link>https://daemon365.dev/2020/12/10/grpc%E5%9F%BA%E7%A1%80/</link><pubDate>Thu, 10 Dec 2020 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2020/12/10/grpc%E5%9F%BA%E7%A1%80/</guid><description>RPC 框架原理 RPC 框架的目标就是让远程服务调用更加简单、透明，RPC 框架负责屏蔽底层的传输方式（TCP 或者 UDP）、序列化方式（XML/Json/ 二进制）和通信细节。服务调用者可以像调用本地接口一样调用远程</description></item><item><title>SQL查询语句执行流程</title><link>https://daemon365.dev/2020/05/21/sql%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/</link><pubDate>Thu, 21 May 2020 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2020/05/21/sql%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/</guid><description>msyql执行流程 你有个最简单的表，表里只有一个 ID 字段，在执行下面这个查询语句时：： select * from T where ID=10； 我们看到的只是输入一条语句，返回一个结果，却不知道这条语句在 MySQL 内部的执行过程。 下面我给出的是 MySQL</description></item><item><title>golang jwt</title><link>https://daemon365.dev/2020/05/20/golang-jwt/</link><pubDate>Wed, 20 May 2020 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2020/05/20/golang-jwt/</guid><description>什么是JWT？ JWT全称JSON Web Token是一种跨域认证解决方案，属于一个开放的标准，它规定了一种Token实现方式，目前多用于前后端分离项目和OAuth2.0业务场景下。 JWT作用？ JWT就是一种</description></item><item><title>mysql索引</title><link>https://daemon365.dev/2020/04/20/mysql%E7%B4%A2%E5%BC%95/</link><pubDate>Mon, 20 Apr 2020 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2020/04/20/mysql%E7%B4%A2%E5%BC%95/</guid><description>什么是索引 一般的应用系统，都是读多写少。而且插入操作和一般的更新操作很少出现性能问题（因为有redo log锁cache缓存）。在生产环境中，我们遇到最多的，也是最容易出问题的，还是一些复杂的查询操作，</description></item><item><title>mysql事务</title><link>https://daemon365.dev/2020/04/03/mysql%E4%BA%8B%E5%8A%A1/</link><pubDate>Fri, 03 Apr 2020 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2020/04/03/mysql%E4%BA%8B%E5%8A%A1/</guid><description>事务是什么 事务就是指逻辑上的一组SQL语句操作，组成这组操作的各个SQL语句，执行时要么全成功要么全失败。 在 MySQL 中，事务支持是在引擎层实现的。MySQL 是一个支持多引擎的系统，但并不是所有的引擎都支持事</description></item><item><title>mysql 锁</title><link>https://daemon365.dev/2020/04/02/mysql-%E9%94%81/</link><pubDate>Thu, 02 Apr 2020 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2020/04/02/mysql-%E9%94%81/</guid><description>MySQL中的锁 数据库锁设计的初衷是处理并发问题。作为多用户共享的资源，当出现并发访问的时候，数据库需要合理地控制资源的访问规则。而锁就是用来实现这些访问规则的重要数据结构。 根据加锁的范围，MySQL</description></item><item><title>msyql redo log和binlog</title><link>https://daemon365.dev/2020/04/01/msyql-redo-log%E5%92%8Cbinlog/</link><pubDate>Wed, 01 Apr 2020 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2020/04/01/msyql-redo-log%E5%92%8Cbinlog/</guid><description>更新语句执行流程 下面是这个表的创建语句，这个表有一个主键 ID 和一个整型字段 c： create table T(ID int primary key, c int); 如果要将 ID=2 这一行的值加 1，SQL 语句就会这么写： update T set c=c+1 where ID=2; 前面我有跟你介绍过 SQL 语句基本的执行链路，这里我再</description></item><item><title>MySQL基础数据类型</title><link>https://daemon365.dev/2020/03/31/mysql%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link><pubDate>Tue, 31 Mar 2020 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2020/03/31/mysql%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid><description>数值类型 MySQL支持所有标准SQL数值数据类型。 这些类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL和NUMERIC)，以及近似数值数据类型(FLOAT、REAL和DOUB</description></item><item><title>MySQL数据完整性约束</title><link>https://daemon365.dev/2020/03/31/mysql%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7%E7%BA%A6%E6%9D%9F/</link><pubDate>Tue, 31 Mar 2020 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2020/03/31/mysql%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7%E7%BA%A6%E6%9D%9F/</guid><description>主键约束 主键可以是表中的某一列，也可以是表中的多个列所构成的一个组合；其中，由多个列组合而成的主键也称为复合主键。在MySQL中，主键列必须遵守以下规则。 （1）每一个表只能定义一个主键。 （2）唯一性原</description></item><item><title>golang web源码解析</title><link>https://daemon365.dev/2020/03/21/golang-web%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</link><pubDate>Sat, 21 Mar 2020 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2020/03/21/golang-web%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</guid><description>Go的web工作原理 在Go中使用及其简单的代码即可开启一个web服务。如下： //开启web服务 func test(){ http.HandleFunc(&amp;quot;/&amp;quot;, sayHello) err := http.ListenAndServe(&amp;quot;:9090&amp;quot;,nil) if err!=nil { log.Fatal(&amp;quot;ListenAndServer:&amp;quot;,err) } } func sayHello(w http.ResponseWriter, r *http.Request){ r.ParseForm() fmt.Println(&amp;quot;path&amp;quot;,r.URL.Path) fmt.Println(&amp;quot;scheme&amp;quot;,r.URL.Scheme) fmt.Fprintf(w, &amp;quot;Hello Guest!&amp;quot;) } 在使用ListenAndServe这个方法时，系统就会给</description></item><item><title>redis持久化</title><link>https://daemon365.dev/2020/03/21/redis%E6%8C%81%E4%B9%85%E5%8C%96/</link><pubDate>Sat, 21 Mar 2020 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2020/03/21/redis%E6%8C%81%E4%B9%85%E5%8C%96/</guid><description>Redis是一种内存型数据库，一旦服务器进程退出，数据库的数据就会丢失，为了解决这个问题，Redis提供了两种持久化的方案，将内存中的数据保存到磁盘中，避免数据的丢失。 RDB持久化 redis提供了RD</description></item><item><title>redis基础</title><link>https://daemon365.dev/2020/03/20/redis%E5%9F%BA%E7%A1%80/</link><pubDate>Fri, 20 Mar 2020 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2020/03/20/redis%E5%9F%BA%E7%A1%80/</guid><description>redis介绍 Redis 是完全开源的，遵守 BSD 协议，是一个高性能的 key-value 数据库。 Redis 与其他 key - value 缓存产品有以下三个特点： Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。 Re</description></item><item><title>nginx简介,使用</title><link>https://daemon365.dev/2020/03/10/nginx%E7%AE%80%E4%BB%8B%E4%BD%BF%E7%94%A8/</link><pubDate>Tue, 10 Mar 2020 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2020/03/10/nginx%E7%AE%80%E4%BB%8B%E4%BD%BF%E7%94%A8/</guid><description>nginx是什么 nginx是一个开源的，支持高性能，高并发的www服务和代理服务软件。 支持高并发，能支持几万并发连接 资源消耗少，在3万并发连接下开启10个nginx线程消耗的内存不到200M 可以做ht</description></item><item><title>golang sqlx</title><link>https://daemon365.dev/2020/01/13/golang-sqlx/</link><pubDate>Mon, 13 Jan 2020 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2020/01/13/golang-sqlx/</guid><description>在项目中我们通常可能会使用database/sql连接MySQL数据库。本文借助使用sqlx实现批量插入数据的例子，介绍了sqlx中可能被你忽视了的sqlx.In和DB.NamedExec方法。 sql</description></item><item><title>golang redis</title><link>https://daemon365.dev/2020/01/12/golang-redis/</link><pubDate>Sun, 12 Jan 2020 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2020/01/12/golang-redis/</guid><description>安装 下载第三方包: go get -u github.com/go-redis/redis/v9 连接 // 定义一个rdis客户端 var redisdb *redis.Client // 初始化 func initClient() (err error) { redisdb = redis.NewClient(&amp;amp;redis.Options{ Addr: &amp;quot;localhost:6379&amp;quot;, // post端口 Password: &amp;quot;&amp;quot;, // 密码 DB: 0, // 使用redis的库 }) _, err = redisdb.Ping(context.Background()).Result() if err != nil { fmt.Println(&amp;quot;连接失败</description></item><item><title>golang nethttp包</title><link>https://daemon365.dev/2020/01/11/golang-nethttp%E5%8C%85/</link><pubDate>Sat, 11 Jan 2020 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2020/01/11/golang-nethttp%E5%8C%85/</guid><description>http协议 超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络传输协议，所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收</description></item><item><title>nethttp和gin 路由</title><link>https://daemon365.dev/2019/12/23/nethttp%E5%92%8Cgin-%E8%B7%AF%E7%94%B1/</link><pubDate>Mon, 23 Dec 2019 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2019/12/23/nethttp%E5%92%8Cgin-%E8%B7%AF%E7%94%B1/</guid><description>net/http 路由注册 func test1() { http.HandleFunc(&amp;quot;/&amp;quot;, func(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, &amp;quot;Hello world!&amp;quot;) }) err := http.ListenAndServe(&amp;quot;:9001&amp;quot;, nil) if err != nil { log.Fatal(&amp;quot;ListenAndServer:&amp;quot;, err) } } 在使用ListenAndServe这个方法时，系统就会给我们指派一个路由器，DefaultServeMux是系统默认使用的路由器，如果Li</description></item><item><title>网络编程</title><link>https://daemon365.dev/2019/12/21/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</link><pubDate>Sat, 21 Dec 2019 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2019/12/21/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</guid><description>网络层次划分 为了使不同计算机厂家生产的计算机能够相互通信，以便在更大的范围内建立计算机网络，国际标准化组织（ISO）在1978年提出了&amp;quot;开放系统互联参考模型&amp;quot;，即著名的OSI/RM</description></item><item><title>proto buffer</title><link>https://daemon365.dev/2019/12/01/proto-buffer/</link><pubDate>Sun, 01 Dec 2019 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2019/12/01/proto-buffer/</guid><description>protobuf是一种高效的数据格式，平台无关、语言无关、可扩展，可用于 RPC 系统和持续数据存储系统。 protobuf介绍 Protobuf是Protocol Buffer的简称，它是Google公司于200</description></item><item><title>go mod</title><link>https://daemon365.dev/2019/10/01/go-mod/</link><pubDate>Tue, 01 Oct 2019 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2019/10/01/go-mod/</guid><description>go module是 Go1.11版本之后官方推出的版本管理工具，并且从Go1.13版本开始，go module将是Go语言默认的依赖管理工具。 GO111MODULE 要启用go module支持首先要设置环境变量GO111MODU</description></item><item><title>golang 模板 htmltemplate与texttemplate</title><link>https://daemon365.dev/2019/07/13/golang-%E6%A8%A1%E6%9D%BF-htmltemplate%E4%B8%8Etexttemplate/</link><pubDate>Sat, 13 Jul 2019 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2019/07/13/golang-%E6%A8%A1%E6%9D%BF-htmltemplate%E4%B8%8Etexttemplate/</guid><description>html模板生成: html/template包实现了数据驱动的模板，用于生成可对抗代码注入的安全HTML输出。它提供了和text/template包相同的接口，Go语言中输出HTML的场景都应使用te</description></item><item><title>golang 反射</title><link>https://daemon365.dev/2019/07/12/golang-%E5%8F%8D%E5%B0%84/</link><pubDate>Fri, 12 Jul 2019 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2019/07/12/golang-%E5%8F%8D%E5%B0%84/</guid><description>变量的内在机制 Go语言中的变量是分为两部分的: 类型信息：预先定义好的元信息。 值信息：程序运行过程中可动态变化的。 反射介绍 反射是指在程序运行期对程序本身进行访问和修改的能力。程序在编译时，变量被转换为内</description></item><item><title>Gin框架介绍及使用</title><link>https://daemon365.dev/2019/06/30/gin%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D%E5%8F%8A%E4%BD%BF%E7%94%A8/</link><pubDate>Sun, 30 Jun 2019 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2019/06/30/gin%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D%E5%8F%8A%E4%BD%BF%E7%94%A8/</guid><description>Gin框架介绍 基于httprouter开发的Web框架。 中文文档，齐全。 简单易用的轻量级框架。 Gin框架安装 go get -u github.com/gin-gonic/gin 实例: package main import ( &amp;quot;fmt&amp;quot; &amp;quot;github.com/gin-gonic/gin&amp;quot; ) func main() { r := gin.Default() // 创建一个默认的路由引擎 // 也可以用gin.New()</description></item><item><title>goalng包和命令工具</title><link>https://daemon365.dev/2019/06/29/goalng%E5%8C%85%E5%92%8C%E5%91%BD%E4%BB%A4%E5%B7%A5%E5%85%B7/</link><pubDate>Sat, 29 Jun 2019 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2019/06/29/goalng%E5%8C%85%E5%92%8C%E5%91%BD%E4%BB%A4%E5%B7%A5%E5%85%B7/</guid><description>包简介 任何包系统设计的目的都是为了简化大型程序的设计和维护工作，通过将一组相关的特性放进一个独立的单元以便于理解和更新，在每个单元更新的同时保持和程序中其它单元的相对独立性。这种模块化的特性允许每个包</description></item><item><title>golang 单元测试</title><link>https://daemon365.dev/2019/06/29/golang-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</link><pubDate>Sat, 29 Jun 2019 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2019/06/29/golang-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</guid><description>go test go test命令是一个按照一定的约定和组织来测试代码的程序。在包目录内，所有以_test.go为后缀名的源文件在执行go build时不会被构建成包的一部分，它们是go test测试的一部分。 go test</description></item><item><title>golang context包</title><link>https://daemon365.dev/2019/06/28/golang-context%E5%8C%85/</link><pubDate>Fri, 28 Jun 2019 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2019/06/28/golang-context%E5%8C%85/</guid><description>go context标准库 context包在Go1.7版本时加入到标准库中。其设计目标是给Golang提供一个标准接口来给其他任务发送取消信号和传递数据。其具体作用为： 可以通过context发送取消信号。</description></item><item><title>golang channel</title><link>https://daemon365.dev/2019/06/26/golang-channel/</link><pubDate>Wed, 26 Jun 2019 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2019/06/26/golang-channel/</guid><description>什么是channel channels 是一种类型安全的消息队列，充当两个 goroutine 之间的管道，将通过它同步的进行任意资源的交换。chan 控制 goroutines 交互的能力从而创建了 Go 同步机制。当创建的 chan 没有容量时，称为无缓冲通道。反过来，使用</description></item><item><title>golang并发</title><link>https://daemon365.dev/2019/06/26/golang%E5%B9%B6%E5%8F%91/</link><pubDate>Wed, 26 Jun 2019 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2019/06/26/golang%E5%B9%B6%E5%8F%91/</guid><description>goroutine goroutine是Go并行设计的核心。goroutine说到底其实就是线程，但是它比线程更小，十几个goroutine可能体现在底层就是五六个线程，Go语言内部帮你实现了这些goroutine之间</description></item><item><title>go语言文件系统</title><link>https://daemon365.dev/2019/06/23/go%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</link><pubDate>Sun, 23 Jun 2019 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2019/06/23/go%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</guid><description>检测文件是否存在 //存在返回 true，不存在返回 false func fileIfExist(filename string) bool { _, err := os.Stat(filename) if nil != err { fmt.Println(filename, &amp;quot;is not exist!&amp;quot;) return false } if os.IsNotExist(err) { return false } return true } 打开文件 f, err := os.Open(filename) if nil != err { fmt.Println(&amp;quot;open&amp;quot;, filename, &amp;quot;failed!&amp;quot;) return } defer f.Close() 如果文件不存在，就会返回错误，如果存在就以只读的方</description></item><item><title>golang函数</title><link>https://daemon365.dev/2019/06/22/golang%E5%87%BD%E6%95%B0/</link><pubDate>Sat, 22 Jun 2019 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2019/06/22/golang%E5%87%BD%E6%95%B0/</guid><description>函数声明 函数声明包括函数名、形式参数列表、返回值列表（可省略）以及函数体。 func function-name(param...) (result...) { body } 形式参数列表描述了函数的参数名以及参数类型。这些参数作为局部变量，其值由参数调用者提供。返回值列表描述了函数返回值</description></item><item><title>golang基础类型</title><link>https://daemon365.dev/2019/06/22/golang%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/</link><pubDate>Sat, 22 Jun 2019 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2019/06/22/golang%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/</guid><description>整型 Go语言同时提供了有符号和无符号类型的整数运算。这里有int8、int16、int32和int64四种截然不同大小的有符号整数类型，分别对应8、16、32、64bit大小的有符号整数，与此对应的是</description></item><item><title>golang基础结构</title><link>https://daemon365.dev/2019/06/22/golang%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84/</link><pubDate>Sat, 22 Jun 2019 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2019/06/22/golang%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84/</guid><description>命名 Go语言中的函数名、变量名、常量名、类型名、语句标号和包名等所有的命名,都遵循一个简单的命名规则：一个名字必须以一个字母（Unicode字母）或下划线开头,后面可以跟任意数量的字母、数字或下划线.</description></item><item><title>golang复杂数据结构</title><link>https://daemon365.dev/2019/06/22/golang%E5%A4%8D%E6%9D%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link><pubDate>Sat, 22 Jun 2019 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2019/06/22/golang%E5%A4%8D%E6%9D%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid><description>数组 **数组是一个由固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成。**因为数组的长度是固定的，因此在Go语言中很少直接使用数组。 数组的每个元素可以通过索引下标来访问，索引下标的范</description></item><item><title>golang接口</title><link>https://daemon365.dev/2019/06/22/golang%E6%8E%A5%E5%8F%A3/</link><pubDate>Sat, 22 Jun 2019 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2019/06/22/golang%E6%8E%A5%E5%8F%A3/</guid><description>接口的定义 接口类型是对其它类型行为的抽象和概括；因为接口类型不会和特定的实现细节绑定在一起，通过这种抽象的方式我们可以让我们的函数更加灵活和更具有适应能力。 很多面向对象的语言都有相似的接口概念，但Go</description></item><item><title>golang方法</title><link>https://daemon365.dev/2019/06/22/golang%E6%96%B9%E6%B3%95/</link><pubDate>Sat, 22 Jun 2019 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2019/06/22/golang%E6%96%B9%E6%B3%95/</guid><description>方法声明 在函数声明时，在其名字之前放上一个变量，即是一个方法。这个附加的参数会将该函数附加到这种类型上，即相当于为这种类型定义了一个独占的方法。 package main import &amp;quot;fmt&amp;quot; type People struct { name string age uint8 } func (p People) SayHello() { fmt.Println(p.name, &amp;quot;: hello world&amp;quot;) p.age = 20 } func main()</description></item><item><title>golang time包</title><link>https://daemon365.dev/2019/06/21/golang-time%E5%8C%85/</link><pubDate>Fri, 21 Jun 2019 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2019/06/21/golang-time%E5%8C%85/</guid><description>时间类型 time.Time类型表示时间。 func demo() { now := time.Now() //获取当前时间 fmt.Printf(&amp;quot;Now:%v\n&amp;quot;, now) // Now:2020-08-19 21:53:31.1633023 +0800 CST m=+0.003989401 year := now.Year() //年 month := now.Month() //月 day := now.Day() //日 hour := now.Hour() //小时 minute := now.Minute() //分钟 second := now.Second() //秒 fmt.Printf(&amp;quot;%d-%02d-%02d %02d:%02d:%02d\n&amp;quot;, year, month, day, hour, minute, second) // 2020-08-19 21:53:31 } 时间戳 func stamp() { now :=</description></item><item><title>About me</title><link>https://daemon365.dev/about/</link><pubDate>Thu, 20 Jun 2019 12:00:00 +0800</pubDate><guid>https://daemon365.dev/about/</guid><description>Follow Me My Github My Nilibili</description></item><item><title>golang error错误处理</title><link>https://daemon365.dev/2019/06/20/golang-error%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</link><pubDate>Thu, 20 Jun 2019 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2019/06/20/golang-error%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</guid><description>error定义 数据结构 go语言error是一普通的值，实现方式为简单一个接口。 // The error built-in interface type is the conventional interface for // representing an error condition, with the nil value representing no error. type error interface { Error() string } 创建error 使用errors.New() // New returns an error that formats as the given</description></item><item><title>golang fmt包</title><link>https://daemon365.dev/2019/06/20/golang-fmt%E5%8C%85/</link><pubDate>Thu, 20 Jun 2019 00:00:00 +0800</pubDate><guid>https://daemon365.dev/2019/06/20/golang-fmt%E5%8C%85/</guid><description>fmt fmt包实现了类似C语言printf和scanf的格式化I/O。主要分为向外输出内容和获取输入内容两大部分。 向外输出 标准库fmt提供了以下几种输出相关函数。 Print Print系列函数会将内容输出到系统的标</description></item></channel></rss>